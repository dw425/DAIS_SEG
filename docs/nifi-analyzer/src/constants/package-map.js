// Package dependency map — pip packages and Databricks library info per system
export const PACKAGE_MAP = {
  kafka: { pip: ['confluent-kafka'], dbx: 'Pre-installed on DBR', desc: 'Kafka' },
  oracle: { pip: ['oracledb'], dbx: 'JDBC driver via cluster library', desc: 'Oracle Database' },
  mysql: { pip: ['mysql-connector-python'], dbx: 'JDBC driver via cluster library', desc: 'MySQL' },
  postgresql: { pip: ['psycopg2-binary'], dbx: 'JDBC driver via cluster library', desc: 'PostgreSQL' },
  sqlserver: { pip: ['pymssql'], dbx: 'JDBC driver via cluster library', desc: 'SQL Server' },
  mongodb: { pip: ['pymongo'], dbx: 'MongoDB Spark Connector', desc: 'MongoDB' },
  elasticsearch: { pip: ['elasticsearch'], dbx: 'Elasticsearch Spark library', desc: 'Elasticsearch' },
  cassandra: { pip: ['cassandra-driver'], dbx: 'Spark Cassandra Connector', desc: 'Cassandra' },
  redis: { pip: ['redis'], dbx: 'Custom library install', desc: 'Redis' },
  hbase: { pip: [], dbx: 'Delta Lake migration', desc: 'HBase' },
  kudu: { pip: [], dbx: 'Delta Lake (direct replacement)', desc: 'Kudu' },
  s3: { pip: ['boto3'], dbx: 'Pre-installed on DBR', desc: 'AWS S3' },
  azure_blob: { pip: ['azure-storage-blob'], dbx: 'Pre-installed on DBR', desc: 'Azure Blob' },
  azure_adls: { pip: ['azure-storage-file-datalake'], dbx: 'Pre-installed on DBR', desc: 'Azure Data Lake' },
  gcs: { pip: ['google-cloud-storage'], dbx: 'GCS Spark connector', desc: 'GCS' },
  hdfs: { pip: [], dbx: 'dbutils.fs (pre-installed)', desc: 'HDFS' },
  sftp: { pip: ['paramiko'], dbx: 'Volumes-based staging', desc: 'SFTP/FTP' },
  http: { pip: ['requests'], dbx: 'Pre-installed on DBR', desc: 'HTTP/REST' },
  email: { pip: ['sendgrid'], dbx: 'Webhook notification', desc: 'Email' },
  mqtt: { pip: ['paho-mqtt'], dbx: 'Custom library', desc: 'MQTT' },
  jms: { pip: ['stomp.py'], dbx: 'Custom library', desc: 'JMS/AMQP' },
  snowflake: { pip: ['snowflake-connector-python'], dbx: 'Snowflake Spark Connector', desc: 'Snowflake' },
  neo4j: { pip: ['neo4j'], dbx: 'Neo4j Spark Connector', desc: 'Neo4j' },
  splunk: { pip: ['splunklib'], dbx: 'Splunk Spark Add-on', desc: 'Splunk' },
  influxdb: { pip: ['influxdb-client'], dbx: 'Custom library', desc: 'InfluxDB' },
  solr: { pip: ['pysolr'], dbx: 'Solr Spark library', desc: 'Solr' },
  hive: { pip: [], dbx: 'Pre-installed (Spark SQL)', desc: 'Hive' },
  iceberg: { pip: [], dbx: 'Pre-installed on DBR 13+', desc: 'Iceberg' },
  teradata: { pip: ['teradatasql'], dbx: 'JDBC driver', desc: 'Teradata' },
  slack: { pip: ['slack-sdk'], dbx: 'Webhook integration', desc: 'Slack' },
  kerberos: { pip: [], dbx: 'Unity Catalog identity federation', desc: 'Kerberos' },
  azure_eventhub: { pip: ['azure-eventhub'], dbx: 'Pre-installed on DBR', desc: 'Azure Event Hubs' },
  azure_servicebus: { pip: ['azure-servicebus'], dbx: 'Custom library install', desc: 'Azure Service Bus' },
  azure_cosmos: { pip: [], dbx: 'Pre-installed (Cosmos Spark connector)', desc: 'Azure Cosmos DB' },
  azure_queue: { pip: ['azure-storage-queue'], dbx: 'Custom library install', desc: 'Azure Queue Storage' },
  gcp_pubsub: { pip: ['google-cloud-pubsub'], dbx: 'Custom library install', desc: 'GCP Pub/Sub' },
  gcp_bigquery: { pip: ['google-cloud-bigquery'], dbx: 'BigQuery Spark connector', desc: 'GCP BigQuery' },
  clickhouse: { pip: ['clickhouse-driver'], dbx: 'ClickHouse JDBC driver', desc: 'ClickHouse' },
  druid: { pip: [], dbx: 'Druid JDBC driver', desc: 'Apache Druid' },
  hudi: { pip: [], dbx: 'Pre-installed on DBR 13+', desc: 'Apache Hudi' },
  kinesis: { pip: ['boto3'], dbx: 'Kinesis Spark connector', desc: 'AWS Kinesis' },
  cloudwatch: { pip: ['boto3'], dbx: 'Pre-installed on DBR', desc: 'AWS CloudWatch' },
  sqs: { pip: ['boto3'], dbx: 'Pre-installed on DBR', desc: 'AWS SQS' },
  sns: { pip: ['boto3'], dbx: 'Pre-installed on DBR', desc: 'AWS SNS' },
  dynamodb: { pip: ['boto3'], dbx: 'Pre-installed on DBR', desc: 'AWS DynamoDB' },
  lambda_aws: { pip: ['boto3'], dbx: 'Pre-installed on DBR', desc: 'AWS Lambda' },
  pagerduty: { pip: ['pdpyras'], dbx: 'Custom library install', desc: 'PagerDuty' },
  opsgenie: { pip: ['opsgenie-sdk'], dbx: 'Custom library install', desc: 'OpsGenie' },
  telegram: { pip: [], dbx: 'HTTP API (no SDK needed)', desc: 'Telegram' },
  geoip: { pip: ['geoip2'], dbx: 'Custom library install', desc: 'GeoIP' },
  exchange: { pip: ['exchangelib'], dbx: 'Custom library install', desc: 'Microsoft Exchange' },
  whois: { pip: ['python-whois'], dbx: 'Custom library install', desc: 'WHOIS' },
  snmp: { pip: ['pysnmp'], dbx: 'Custom library install', desc: 'SNMP' },
  datadog: { pip: ['datadog-api-client'], dbx: 'Datadog integration', desc: 'Datadog' },
  prometheus: { pip: ['prometheus-client'], dbx: 'Custom library install', desc: 'Prometheus' },
  grafana: { pip: [], dbx: 'Grafana REST API', desc: 'Grafana' },
  phoenix: { pip: [], dbx: 'Phoenix JDBC driver', desc: 'Apache Phoenix' },
  cockroachdb: { pip: ['psycopg2-binary'], dbx: 'PostgreSQL JDBC driver', desc: 'CockroachDB' },
  timescaledb: { pip: ['psycopg2-binary'], dbx: 'PostgreSQL JDBC driver', desc: 'TimescaleDB' },
  greenplum: { pip: ['psycopg2-binary'], dbx: 'PostgreSQL JDBC driver', desc: 'Greenplum' },
  vertica: { pip: ['vertica-python'], dbx: 'Vertica JDBC driver', desc: 'Vertica' },
  saphana: { pip: ['hdbcli'], dbx: 'SAP HANA JDBC driver', desc: 'SAP HANA' },
  presto: { pip: [], dbx: 'Presto JDBC driver', desc: 'Presto' },
  trino: { pip: ['trino'], dbx: 'Trino JDBC driver', desc: 'Trino' },
};

// Processor type substring → PACKAGE_MAP key
export const PROC_PACKAGE_KEYS = {
  ClickHouse: 'clickhouse', Druid: 'druid', Hudi: 'hudi', Kinesis: 'kinesis',
  CloudWatch: 'cloudwatch', SQS: 'sqs', SNS: 'sns', DynamoDB: 'dynamodb',
  Lambda: 'lambda_aws', PagerDuty: 'pagerduty', OpsGenie: 'opsgenie',
  GeoIP: 'geoip', Exchange: 'exchange', SNMP: 'snmp', Datadog: 'datadog',
  Prometheus: 'prometheus', Grafana: 'grafana', Phoenix: 'phoenix',
  CockroachDB: 'cockroachdb', TimescaleDB: 'timescaledb', Greenplum: 'greenplum',
  Vertica: 'vertica', SAPHANA: 'saphana', Presto: 'presto', Trino: 'trino',
  CosmosDB: 'azure_cosmos', ServiceBus: 'azure_servicebus', EventHub: 'azure_eventhub',
  PubSub: 'gcp_pubsub', BigQuery: 'gcp_bigquery', Kafka: 'kafka', Oracle: 'oracle',
  MySQL: 'mysql', Postgres: 'postgresql', Mongo: 'mongodb', Elastic: 'elasticsearch',
  Cassandra: 'cassandra', Redis: 'redis', HBase: 'hbase', Kudu: 'kudu',
  S3: 's3', AzureBlob: 'azure_blob', ADLS: 'azure_adls', GCS: 'gcs',
  HDFS: 'hdfs', SFTP: 'sftp', FTP: 'sftp', HTTP: 'http', InvokeHTTP: 'http',
  Email: 'email', MQTT: 'mqtt', JMS: 'jms', AMQP: 'jms', Snowflake: 'snowflake',
  Neo4j: 'neo4j', Splunk: 'splunk', InfluxDB: 'influxdb', Solr: 'solr',
  Hive: 'hive', Iceberg: 'iceberg', Teradata: 'teradata', Syslog: 'syslog',
  Slack: 'slack'
};

// Given a processor type string, return matching package info objects
export function getProcessorPackages(pt) {
  const r = new Set();
  for (const [k, v] of Object.entries(PROC_PACKAGE_KEYS)) {
    if (pt.includes(k)) r.add(v);
  }
  return [...r].map(k => PACKAGE_MAP[k]).filter(Boolean);
}
