<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>SEG — Synthetic Environment Generator Demo</title>
<style>
:root {
  --bg: #0e1117; --surface: #1a1d27; --surface2: #262730;
  --border: #363842; --text: #fafafa; --text2: #808495;
  --primary: #ff4b4b; --primary-hover: #ff6b6b;
  --green: #21c354; --amber: #faca15; --red: #ff4b4b;
  --blue: #1d4ed8; --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --mono: 'SF Mono', 'Fira Code', monospace;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { background: var(--bg); color: var(--text); font-family: var(--font); line-height: 1.6; }
.container { max-width: 1200px; margin: 0 auto; padding: 20px; }
h1 { font-size: 2rem; margin-bottom: 4px; }
h2 { font-size: 1.4rem; margin: 24px 0 12px; border-bottom: 1px solid var(--border); padding-bottom: 8px; }
h3 { font-size: 1.1rem; margin: 16px 0 8px; }
.caption { color: var(--text2); font-size: 0.9rem; margin-bottom: 20px; }
.tabs { display: flex; gap: 0; border-bottom: 2px solid var(--border); margin-bottom: 24px; overflow-x: auto; }
.tab { padding: 10px 20px; cursor: pointer; color: var(--text2); border-bottom: 2px solid transparent;
  margin-bottom: -2px; white-space: nowrap; font-size: 0.95rem; transition: all 0.2s; }
.tab:hover { color: var(--text); }
.tab.active { color: var(--primary); border-bottom-color: var(--primary); font-weight: 600; }
.panel { display: none; } .panel.active { display: block; }
.row { display: flex; gap: 20px; flex-wrap: wrap; }
.col { flex: 1; min-width: 280px; }
.col-3 { flex: 1; min-width: 200px; }
.metrics { display: flex; gap: 16px; flex-wrap: wrap; margin: 16px 0; }
.metric { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 16px 20px; min-width: 140px; flex: 1; }
.metric .label { font-size: 0.8rem; color: var(--text2); text-transform: uppercase; letter-spacing: 0.5px; }
.metric .value { font-size: 1.8rem; font-weight: 700; margin-top: 4px; }
.metric .delta { font-size: 0.85rem; color: var(--red); }
textarea, input[type=text], input[type=number], select {
  width: 100%; padding: 10px 14px; background: var(--surface); border: 1px solid var(--border);
  border-radius: 6px; color: var(--text); font-family: var(--mono); font-size: 0.9rem; resize: vertical; }
textarea:focus, input:focus { outline: none; border-color: var(--primary); }
textarea { min-height: 200px; }
label { display: block; font-size: 0.85rem; color: var(--text2); margin-bottom: 6px; font-weight: 500; }
.btn { padding: 10px 24px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.95rem;
  font-weight: 600; transition: all 0.2s; display: inline-flex; align-items: center; gap: 8px; }
.btn-primary { background: var(--primary); color: white; }
.btn-primary:hover { background: var(--primary-hover); }
.btn-secondary { background: var(--surface2); color: var(--text); border: 1px solid var(--border); }
.btn-secondary:hover { background: var(--border); }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.alert { padding: 12px 16px; border-radius: 6px; margin: 12px 0; font-size: 0.9rem; }
.alert-info { background: #1e3a5f; border: 1px solid #2563eb; color: #93c5fd; }
.alert-success { background: #14532d; border: 1px solid var(--green); color: #86efac; }
.alert-warn { background: #713f12; border: 1px solid var(--amber); color: #fde68a; }
.alert-error { background: #450a0a; border: 1px solid var(--red); color: #fca5a5; }
table { width: 100%; border-collapse: collapse; margin: 12px 0; font-size: 0.85rem; }
th { text-align: left; padding: 8px 12px; background: var(--surface2); color: var(--text2);
  font-weight: 600; text-transform: uppercase; font-size: 0.75rem; letter-spacing: 0.5px;
  border-bottom: 2px solid var(--border); }
td { padding: 8px 12px; border-bottom: 1px solid var(--border); }
tr:hover td { background: var(--surface); }
.expander { border: 1px solid var(--border); border-radius: 8px; margin: 12px 0; overflow: hidden; }
.expander-header { padding: 12px 16px; cursor: pointer; display: flex; justify-content: space-between;
  align-items: center; background: var(--surface); font-weight: 500; }
.expander-header:hover { background: var(--surface2); }
.expander-body { padding: 16px; display: none; border-top: 1px solid var(--border); }
.expander.open .expander-body { display: block; }
.expander-arrow { transition: transform 0.2s; }
.expander.open .expander-arrow { transform: rotate(90deg); }
.badge { display: inline-block; padding: 2px 10px; border-radius: 12px; font-size: 0.8rem; font-weight: 600; }
.badge-green { background: #14532d; color: #86efac; }
.badge-amber { background: #713f12; color: #fde68a; }
.badge-red { background: #450a0a; color: #fca5a5; }
.progress-bar { height: 8px; background: var(--surface2); border-radius: 4px; overflow: hidden; margin: 6px 0; }
.progress-fill { height: 100%; border-radius: 4px; transition: width 0.3s; }
.progress-fill.green { background: var(--green); }
.progress-fill.amber { background: var(--amber); }
.progress-fill.red { background: var(--red); }
code { background: var(--surface2); padding: 2px 6px; border-radius: 4px; font-family: var(--mono); font-size: 0.85rem; }
pre { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 16px;
  overflow-x: auto; font-family: var(--mono); font-size: 0.85rem; margin: 12px 0; }
.score-big { font-size: 3rem; font-weight: 800; text-align: center; padding: 20px; }
.table-scroll { overflow-x: auto; }
.file-upload { border: 2px dashed var(--border); border-radius: 8px; padding: 40px 20px; text-align: center;
  cursor: pointer; transition: border-color 0.2s; }
.file-upload:hover { border-color: var(--primary); }
.file-upload input { display: none; }
.divider { border: none; border-top: 1px solid var(--border); margin: 24px 0; }
.hidden { display: none; }
@media (max-width: 768px) { .row { flex-direction: column; } .col, .col-3 { min-width: 100%; } }
/* Tab status indicators */
.tab { position: relative; }
.tab .check { display: none; margin-left: 6px; color: var(--green); font-size: 0.85rem; }
.tab.done .check { display: inline-block; animation: pop 0.4s ease; }
.tab.locked { opacity: 0.4; pointer-events: none; }
.tab .spinner-sm { display: none; width: 12px; height: 12px; border: 2px solid var(--border);
  border-top: 2px solid var(--primary); border-radius: 50%; animation: spin 0.6s linear infinite;
  margin-left: 6px; vertical-align: middle; }
.tab.processing .spinner-sm { display: inline-block; }
@keyframes pop { 0%{transform:scale(0)} 60%{transform:scale(1.3)} 100%{transform:scale(1)} }
@keyframes spin { to { transform: rotate(360deg); } }
/* Source system grid */
.sources-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; margin: 16px 0; }
.source-badge { background: var(--surface); border: 1px solid var(--border); border-radius: 6px;
  padding: 8px 12px; text-align: center; border-top: 3px solid var(--border); transition: border-color 0.2s; }
.source-badge:hover { border-color: var(--primary); }
.source-badge .src-name { font-weight: 600; font-size: 0.85rem; }
.source-badge .src-type { color: var(--text2); font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.3px; }
.detected-source { display: inline-flex; align-items: center; gap: 8px; padding: 6px 14px;
  background: var(--surface); border: 1px solid var(--green); border-radius: 6px; margin: 8px 0; font-size: 0.9rem; }
.detected-source .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--green); }
/* Tier Diagram */
.tier-diagram { position: relative; overflow: auto; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); min-height: 200px; margin: 16px 0; }
.tier-diagram svg.tier-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
.tier-band { padding: 16px 20px; border-bottom: 1px solid var(--border); position: relative; z-index: 2; }
.tier-band:last-child { border-bottom: none; }
.tier-band-label { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; font-weight: 700; margin-bottom: 10px; opacity: 0.8; }
.tier-nodes { display: flex; flex-wrap: wrap; gap: 12px; justify-content: center; }
.tier-node { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 10px 16px;
  min-width: 120px; max-width: 200px; text-align: center; cursor: pointer; transition: all 0.2s; position: relative; z-index: 3; }
.tier-node:hover { border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
.tier-node.selected { border-color: var(--primary); box-shadow: 0 0 0 2px rgba(255,75,75,0.3); }
.tier-node.highlighted { border-color: var(--green); }
.tier-node.dimmed { opacity: 0.3; }
.tier-node .node-name { font-weight: 600; font-size: 0.85rem; word-break: break-all; }
.tier-node .node-meta { font-size: 0.7rem; color: var(--text2); margin-top: 4px; }
.tier-node .node-badge { position: absolute; top: -6px; right: -6px; background: var(--primary); color: white;
  border-radius: 10px; padding: 1px 6px; font-size: 0.65rem; font-weight: 700; }
.tier-node .node-badge.green { background: var(--green); }
.tier-node .node-badge.amber { background: var(--amber); color: #000; }
.node-detail { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 16px;
  margin-top: 12px; font-size: 0.85rem; }
.node-detail h4 { margin: 0 0 8px; }
.diagram-legend { display: flex; gap: 16px; flex-wrap: wrap; margin: 8px 0; font-size: 0.75rem; color: var(--text2); }
.diagram-legend span { display: flex; align-items: center; gap: 4px; }
.diagram-legend .leg-line { width: 20px; height: 2px; border-radius: 1px; }
</style>
</head>
<body>
<div class="container">
  <h1>SEG — Synthetic Environment Generator</h1>
  <p class="caption">Upload from 20+ source systems — Oracle, Snowflake, Redshift, Informatica, NiFi, dbt, PySpark, and more — generate a full synthetic environment instantly in your browser</p>

  <div class="tabs" id="tabs">
    <div class="tab active" data-tab="parse">1. Load &amp; Parse<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
    <div class="tab locked" data-tab="blueprint">2. Blueprint<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
    <div class="tab locked" data-tab="generate">3. Generate<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
    <div class="tab locked" data-tab="conform">4. Conform<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
    <div class="tab locked" data-tab="validate">5. Validate<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
  </div>

  <!-- STEP 1: PARSE -->
  <div class="panel active" id="panel-parse">
    <h2>Step 1: Load &amp; Parse Input</h2>
    <h3>Supported Sources</h3>
    <div class="sources-grid">
      <div class="source-badge" style="border-top-color:#4285F4"><div class="src-name">Google BigQuery</div><div class="src-type">Cloud Platform</div></div>
      <div class="source-badge" style="border-top-color:#FF9900"><div class="src-name">AWS Redshift</div><div class="src-type">Data Warehouse</div></div>
      <div class="source-badge" style="border-top-color:#FF4A00"><div class="src-name">Informatica</div><div class="src-type">ETL &amp; Integration</div></div>
      <div class="source-badge" style="border-top-color:#29B5E8"><div class="src-name">Snowflake</div><div class="src-type">Data Cloud</div></div>
      <div class="source-badge" style="border-top-color:#F37440"><div class="src-name">Teradata</div><div class="src-type">Enterprise DW</div></div>
      <div class="source-badge" style="border-top-color:#FF3621"><div class="src-name">Databricks</div><div class="src-type">Unity Catalog</div></div>
      <div class="source-badge" style="border-top-color:#0FAAFF"><div class="src-name">SAP HANA</div><div class="src-type">ERP / BW</div></div>
      <div class="source-badge" style="border-top-color:#0078D4"><div class="src-name">Azure Synapse</div><div class="src-type">Analytics</div></div>
      <div class="source-badge" style="border-top-color:#CC2927"><div class="src-name">SQL Server</div><div class="src-type">Microsoft SQL</div></div>
      <div class="source-badge" style="border-top-color:#F80000"><div class="src-name">Oracle</div><div class="src-type">Database</div></div>
      <div class="source-badge" style="border-top-color:#4169E1"><div class="src-name">PostgreSQL</div><div class="src-type">Database</div></div>
      <div class="source-badge" style="border-top-color:#4479A1"><div class="src-name">MySQL</div><div class="src-type">Database</div></div>
      <div class="source-badge" style="border-top-color:#FF694B"><div class="src-name">dbt</div><div class="src-type">Transformation</div></div>
      <div class="source-badge" style="border-top-color:#E25A1C"><div class="src-name">PySpark</div><div class="src-type">Spark Schema</div></div>
      <div class="source-badge" style="border-top-color:#DC382D"><div class="src-name">Scala / Spark</div><div class="src-type">Case Classes</div></div>
      <div class="source-badge" style="border-top-color:#FF6D70"><div class="src-name">Talend</div><div class="src-type">Data Integration</div></div>
      <div class="source-badge" style="border-top-color:#728E9B"><div class="src-name">Apache NiFi</div><div class="src-type">Flow Definition</div></div>
      <div class="source-badge" style="border-top-color:#3ECF8E"><div class="src-name">Avro / Protobuf</div><div class="src-type">Schema Files</div></div>
    </div>
    <div class="row">
      <div class="col">
        <h3>Upload File</h3>
        <div class="file-upload" id="fileDropZone">
          <p>Drop a file here or click to browse</p>
          <p style="color:var(--text2);font-size:0.85rem">SQL, DDL, CSV, JSON, YAML, XML, Avro, Protobuf, PySpark, Scala, NiFi, dbt</p>
          <input type="file" id="fileInput" accept=".sql,.ddl,.hql,.bteq,.psql,.csv,.tsv,.json,.avsc,.yaml,.yml,.xml,.py,.scala,.proto">
        </div>
        <div id="fileName" class="alert alert-info hidden" style="margin-top:12px"></div>
      </div>
      <div class="col">
        <h3>Paste Text</h3>
        <textarea id="pasteInput" placeholder="CREATE TABLE customers (
  id INT PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  email VARCHAR(200),
  status VARCHAR(20) CHECK (status IN ('active','inactive'))
);"></textarea>
      </div>
    </div>
    <div style="margin-top:16px">
      <button class="btn btn-primary" onclick="parseInput()">Parse Input</button>
    </div>
    <div id="parseResults"></div>
  </div>

  <!-- STEP 2: BLUEPRINT -->
  <div class="panel" id="panel-blueprint">
    <h2>Step 2: Blueprint Assembly</h2>
    <div id="blueprintNotReady" class="alert alert-info">Complete Step 1 first — parse a file or paste text.</div>
    <div id="blueprintReady" class="hidden">
      <div class="row">
        <div class="col">
          <label>Rows per table</label>
          <input type="number" id="rowCount" value="1000" min="10" max="10000" step="100">
        </div>
        <div class="col">
          <label>Random seed</label>
          <input type="number" id="seed" value="42" min="0">
        </div>
      </div>
      <div style="margin-top:16px">
        <button class="btn btn-primary" onclick="assembleBlueprint()">Assemble Blueprint</button>
      </div>
      <div id="blueprintResults"></div>
      <div id="tierDiagramContainer" class="hidden">
        <h3>Environment Visualization</h3>
        <div id="tierDiagramLegend" class="diagram-legend"></div>
        <div id="tierDiagram" class="tier-diagram"></div>
        <div id="tierNodeDetail"></div>
      </div>
    </div>
  </div>

  <!-- STEP 3: GENERATE -->
  <div class="panel" id="panel-generate">
    <h2>Step 3: Generate Synthetic Data</h2>
    <div id="generateNotReady" class="alert alert-info">Complete Step 2 first.</div>
    <div id="generateReady" class="hidden">
      <button class="btn btn-primary" onclick="generateData()">Generate Synthetic Data</button>
      <div id="generateResults"></div>
    </div>
  </div>

  <!-- STEP 4: CONFORM -->
  <div class="panel" id="panel-conform">
    <h2>Step 4: Conform — Medallion Architecture</h2>
    <div id="conformNotReady" class="alert alert-info">Complete Step 3 first.</div>
    <div id="conformReady" class="hidden">
      <button class="btn btn-primary" onclick="runConform()">Run Medallion Pipeline</button>
      <div id="conformResults"></div>
    </div>
  </div>

  <!-- STEP 5: VALIDATE -->
  <div class="panel" id="panel-validate">
    <h2>Step 5: Validate &amp; Confidence Score</h2>
    <div id="validateNotReady" class="alert alert-info">Complete Steps 3-4 first.</div>
    <div id="validateReady" class="hidden">
      <button class="btn btn-primary" onclick="runValidation()">Run Validation</button>
      <div id="validateResults"></div>
    </div>
  </div>
</div>

<script>
// ================================================================
// STATE
// ================================================================
let STATE = { parsed: null, blueprint: null, tables: null, medallion: null, validation: null };

// ================================================================
// TAB NAVIGATION
// ================================================================
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    if (tab.classList.contains('locked')) return;
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById('panel-' + tab.dataset.tab).classList.add('active');
  });
});

function switchTab(name) {
  document.querySelectorAll('.tab').forEach(t => { t.classList.toggle('active', t.dataset.tab === name); });
  document.querySelectorAll('.panel').forEach(p => { p.classList.toggle('active', p.id === 'panel-' + name); });
}

function setTabStatus(name, status) {
  const tab = document.querySelector(`.tab[data-tab="${name}"]`);
  if (!tab) return;
  tab.classList.remove('locked','processing','done');
  if (status === 'locked') tab.classList.add('locked');
  else if (status === 'processing') tab.classList.add('processing');
  else if (status === 'done') tab.classList.add('done');
  // 'ready' = no extra class, just clickable
  if (status !== 'locked') {
    tab.style.pointerEvents = '';
    tab.style.opacity = '';
  }
}

function unlockTab(name) { setTabStatus(name, 'ready'); }

// FILE UPLOAD
const fileInput = document.getElementById('fileInput');
const dropZone = document.getElementById('fileDropZone');
dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.style.borderColor = 'var(--primary)'; });
dropZone.addEventListener('dragleave', () => { dropZone.style.borderColor = 'var(--border)'; });
dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.style.borderColor = 'var(--border)';
  if (e.dataTransfer.files.length) { fileInput.files = e.dataTransfer.files; handleFile(); }
});
fileInput.addEventListener('change', handleFile);

let uploadedContent = '', uploadedName = '';
function handleFile() {
  const f = fileInput.files[0]; if (!f) return;
  uploadedName = f.name;
  document.getElementById('fileName').textContent = 'Loaded: ' + f.name;
  document.getElementById('fileName').classList.remove('hidden');
  const reader = new FileReader();
  reader.onload = e => { uploadedContent = e.target.result; };
  reader.readAsText(f);
}

// ================================================================
// SMART PARSE ENGINE — Resilient Cascading Parser
// ================================================================
function cleanInput(content) {
  if (!content) return '';
  let c = content;
  // Strip BOM
  if (c.charCodeAt(0) === 0xFEFF) c = c.substring(1);
  // Normalize line endings
  c = c.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  // Remove NULL bytes
  c = c.replace(/\x00/g, '');
  // Replace non-breaking spaces
  c = c.replace(/\u00A0/g, ' ');
  // Replace smart quotes
  c = c.replace(/[\u201C\u201D]/g, '"').replace(/[\u2018\u2019]/g, "'");
  return c.trim();
}

function rankFormats(content, filename) {
  const candidates = [];
  // Extension-based (high confidence)
  if (filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const extMap = {sql:'ddl',ddl:'ddl',hql:'ddl',bteq:'ddl',psql:'ddl',csv:'csv',tsv:'csv',json:'json',avsc:'avro',yaml:'yaml',yml:'yaml',xml:'xml',py:'pyspark',scala:'scala',proto:'protobuf'};
    if (extMap[ext]) {
      let fmt = extMap[ext];
      if (fmt === 'xml') fmt = detectXMLFormat(content);
      if (fmt === 'json') { try { const d=JSON.parse(content.trim()); if(d.type==='record'&&d.fields) fmt='avro'; } catch(e){} }
      candidates.push({format: fmt, confidence: 0.9});
    }
  }
  const s = content.trim();
  // NiFi template
  if (/<template[\s>][\s\S]{0,1000}<snippet>/i.test(s.substring(0,3000))) candidates.push({format:'nifi_xml',confidence:0.95});
  if (/org\.apache\.nifi\./i.test(s.substring(0,15000))) candidates.push({format:'nifi_xml',confidence:0.90});
  // Informatica
  if (/<(REPOSITORY|FOLDER|POWERMART|INFORMATICA)/i.test(s)) candidates.push({format:'informatica_xml',confidence:0.95});
  // Talend
  if (/<(TalendProperties|talendfile|ProcessType)/i.test(s)) candidates.push({format:'talend_xml',confidence:0.95});
  // Protobuf
  if (/\bmessage\s+\w+\s*\{[\s\S]*?(?:string|int32|int64|bool|double)\s+\w+\s*=\s*\d+/i.test(s.substring(0,5000))) candidates.push({format:'protobuf',confidence:0.88});
  // PySpark
  if (/StructType\s*\(|StructField\s*\(/i.test(s)) candidates.push({format:'pyspark',confidence:0.88});
  // Scala
  if (/case\s+class\s+\w+/i.test(s)) candidates.push({format:'scala',confidence:0.85});
  // Spark printSchema
  if (/root\s*\n\s*\|--/.test(s)) candidates.push({format:'spark_schema',confidence:0.90});
  // dbt
  if (/\{\{\s*(ref|source|config)\s*\(/.test(s)) candidates.push({format:'dbt',confidence:0.88});
  // Avro
  if (s.startsWith('{')) { try { const d=JSON.parse(s); if(d.type==='record'&&d.fields) candidates.push({format:'avro',confidence:0.92}); } catch(e){} }
  // DDL
  if (/CREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMPORARY\s+|GLOBAL\s+TEMPORARY\s+|VOLATILE\s+|TRANSIENT\s+|EXTERNAL\s+|MULTISET\s+|SET\s+|COLUMN\s+|ROW\s+|UNLOGGED\s+|TEMP\s+)*TABLE\b/i.test(s)) candidates.push({format:'ddl',confidence:0.82});
  // JSON
  if (s.startsWith('{') || s.startsWith('[')) { try { JSON.parse(s); candidates.push({format:'json',confidence:0.70}); } catch(e){} }
  // XML
  if (s.startsWith('<')) candidates.push({format:'xml',confidence:0.60});
  // YAML
  if (/^(tables|models|sources)\s*:/m.test(s)) candidates.push({format:'yaml',confidence:0.80});
  // CSV
  const fl = s.split('\n')[0].toLowerCase();
  if (['source_table','target_table','src_table','tgt_table','table_name','column_name'].some(h => fl.includes(h))) candidates.push({format:'csv',confidence:0.80});
  // Fallback DDL from type keywords
  if (/\b(INT|VARCHAR|DECIMAL|TIMESTAMP|BOOLEAN|BIGINT|FLOAT|DOUBLE|NUMBER)\b/i.test(s)) candidates.push({format:'ddl',confidence:0.30});
  // Always include DDL as absolute fallback
  if (!candidates.some(c=>c.format==='ddl')) candidates.push({format:'ddl',confidence:0.10});
  // Dedupe: keep highest confidence per format
  const best = {};
  candidates.forEach(c => { if (!best[c.format] || c.confidence > best[c.format].confidence) best[c.format] = c; });
  return Object.values(best).sort((a,b) => b.confidence - a.confidence);
}

function routeParser(format, content, filename) {
  const sn = filename || 'Parsed Input';
  if (format==='yaml') return parseYAML(content, sn);
  if (format==='pyspark') return parsePySpark(content, sn);
  if (format==='scala') return parseScala(content, sn);
  if (format==='dbt') return parseDBT(content, sn);
  if (format==='avro') return parseAvro(content, sn);
  if (format==='protobuf') return parseProtobuf(content, sn);
  if (format==='spark_schema') return parseSparkSchema(content, sn);
  if (format==='informatica_xml') { const doc=new DOMParser().parseFromString(content,'text/xml'); return parseInformaticaXML(doc, sn); }
  if (format==='talend_xml') { const doc=new DOMParser().parseFromString(content,'text/xml'); return parseTalendXML(doc, sn); }
  if (format==='nifi_xml') { const doc=new DOMParser().parseFromString(content,'text/xml'); return parseNiFiXML(doc, sn); }
  if (format==='json') return parseJSON(content, sn);
  if (format==='xml') return parseXML(content, sn);
  if (format==='csv') return parseCSV(content, sn);
  return parseDDL(content, sn);
}

function validateParseResult(result) {
  let score = 0;
  const warnings = [];
  if (!result || !result.tables) return {score:0, warnings:['No result'], result};
  if (result.tables.length > 0) score += 0.3;
  const withCols = result.tables.filter(t => t.columns && t.columns.length > 0);
  if (withCols.length === result.tables.length) score += 0.3;
  else if (withCols.length > 0) { score += 0.15; warnings.push(`${result.tables.length - withCols.length} tables have no columns`); }
  const allCols = result.tables.flatMap(t => t.columns || []);
  const typedCols = allCols.filter(c => c.data_type && c.data_type !== 'varchar');
  if (typedCols.length > allCols.length * 0.3) score += 0.2;
  else if (allCols.length > 0) score += 0.1;
  const namedTables = result.tables.filter(t => t.name && t.name.length > 0);
  if (namedTables.length === result.tables.length) score += 0.1;
  const names = result.tables.map(t => t.name);
  if (new Set(names).size === names.length) score += 0.1;
  return {score, warnings, result};
}

function bruteForceExtract(content, filename, priorErrors) {
  const tables = [];
  // Strategy 1: column-type patterns
  const colPattern = /\b(\w{2,30})\s+(INT(?:EGER)?|VARCHAR\d*|CHAR|TEXT|DECIMAL|FLOAT|DOUBLE|DATE|TIMESTAMP|BOOLEAN|BIGINT|SMALLINT|TINYINT|NUMBER|STRING|BINARY|BLOB|CLOB)\b/gi;
  const matches = [...content.matchAll(colPattern)];
  if (matches.length >= 2) {
    const seen = new Set();
    const cols = matches.filter(m => { const k=m[1].toLowerCase(); if(seen.has(k))return false; seen.add(k); return true; }).map(m => ({
      name:m[1], data_type:TYPE_NORM[m[2].toLowerCase()]||m[2].toLowerCase(), raw_type:m[2],
      nullable:true, is_primary_key:false, is_unique:false, check_constraints:[], max_length:null, precision:null, scale:null, default_value:null
    }));
    if (cols.length >= 2) tables.push({name:filename?filename.replace(/\.[^.]+$/,''):'extracted_table', schema:'unknown', columns:cols, foreign_keys:[], row_count:1000});
  }
  // Strategy 2: XML name/type attributes
  if (content.trim().startsWith('<')) {
    try {
      const doc = new DOMParser().parseFromString(content, 'text/xml');
      const groups = {};
      doc.querySelectorAll('*').forEach(el => {
        const name = el.getAttribute('name')||el.getAttribute('Name')||el.getAttribute('NAME');
        const type = el.getAttribute('type')||el.getAttribute('Type')||el.getAttribute('TYPE')||el.getAttribute('datatype')||el.getAttribute('DATATYPE');
        if (name && type) {
          const parent = el.parentElement?.getAttribute('name')||el.parentElement?.getAttribute('Name')||'xml_table';
          if (!groups[parent]) groups[parent] = [];
          groups[parent].push({name, data_type:TYPE_NORM[type.toLowerCase()]||type.toLowerCase(), raw_type:type,
            nullable:true, is_primary_key:false, is_unique:false, check_constraints:[], max_length:null, precision:null, scale:null, default_value:null});
        }
      });
      Object.entries(groups).forEach(([tn, cols]) => {
        if (cols.length >= 2 && !tables.find(t=>t.name===tn)) tables.push({name:tn, schema:'unknown', columns:cols, foreign_keys:[], row_count:1000});
      });
    } catch(e) {}
  }
  const warnings = ['Primary parsers failed — used brute-force extraction'];
  if (priorErrors && priorErrors.length) priorErrors.forEach(e => warnings.push(`${e.format}: ${e.error}`));
  return {source_name:filename||'Unknown', source_type:'brute_force', tables, input_format:'unknown', parse_warnings:warnings};
}

function smartParse(content, filename) {
  content = cleanInput(content);
  if (!content) return null;
  const candidates = rankFormats(content, filename);
  const errors = [];
  for (const {format, confidence} of candidates) {
    try {
      const result = routeParser(format, content, filename);
      if (result && result.tables && result.tables.length > 0) {
        const validated = validateParseResult(result);
        if (validated.score > 0.3) {
          result.detected_format = format;
          result.parse_confidence = confidence;
          result.parse_attempts = errors.length + 1;
          if (validated.warnings.length) result.parse_warnings = (result.parse_warnings||[]).concat(validated.warnings);
          return result;
        }
      }
    } catch(e) { errors.push({format, error: e.message}); }
  }
  // Final fallback
  return bruteForceExtract(content, filename, errors);
}

// ================================================================
// PARSERS
// ================================================================
const TYPE_NORM = {
  // Oracle
  number:'decimal',varchar2:'varchar',nvarchar2:'varchar',clob:'text',nclob:'text',blob:'binary',
  raw:'binary','long raw':'binary',long:'text',binary_float:'float',binary_double:'double',
  xmltype:'text',rowid:'varchar',urowid:'varchar',
  // SQL Server / Azure Synapse
  nvarchar:'varchar',nchar:'char',bit:'boolean',money:'decimal',smallmoney:'decimal',
  datetime2:'timestamp',datetimeoffset:'timestamp',smalldatetime:'timestamp',
  image:'binary',ntext:'text',uniqueidentifier:'varchar',sql_variant:'varchar',
  hierarchyid:'varchar',varbinary:'binary',xml:'text',
  // PostgreSQL
  serial:'int',bigserial:'bigint',smallserial:'smallint',real:'float',
  'double precision':'double','character varying':'varchar',character:'char',
  bytea:'binary',inet:'varchar',cidr:'varchar',macaddr:'varchar',uuid:'varchar',
  jsonb:'text',json:'text',tsquery:'text',tsvector:'text',interval:'varchar',
  int2:'smallint',int4:'int',int8:'bigint',float4:'float',float8:'double',
  bool:'boolean',timestamptz:'timestamp',
  // MySQL
  mediumint:'int',mediumtext:'text',longtext:'text',tinytext:'text',
  enum:'varchar',set:'varchar',year:'int',mediumblob:'binary',longblob:'binary',
  tinyblob:'binary',tinyint:'int',
  // Snowflake
  variant:'text',object:'text',array:'text',string:'varchar',
  timestamp_ltz:'timestamp',timestamp_ntz:'timestamp',timestamp_tz:'timestamp',
  // Redshift
  super:'text',hllsketch:'varchar',bpchar:'char',
  // Teradata
  byteint:'int',st_geometry:'varchar',
  // SAP HANA
  cs_string:'varchar',cs_int:'int',cs_double:'double',cs_decimal:'decimal',
  alphanum:'varchar',shorttext:'varchar',seconddate:'timestamp',daydate:'date',
  // BigQuery
  int64:'bigint',float64:'double',bignumeric:'decimal',record:'text',struct:'text',
  geography:'varchar',geometry:'varchar',
  // Databricks / Spark
  short:'smallint',byte:'tinyint',binary:'binary',map:'text',void:'varchar',
  // Informatica / Talend
  nstring:'varchar',
};
const MW_TYPES = ['double precision','character varying','timestamp with time zone',
  'timestamp without time zone','timestamp with local time zone','long raw',
  'long varchar','binary varying','national character varying','national character'];

function detectFormat(content, filename) {
  if (filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const map = {sql:'ddl',ddl:'ddl',hql:'ddl',bteq:'ddl',psql:'ddl',csv:'csv',tsv:'csv',json:'json',avsc:'avro',yaml:'yaml',yml:'yaml',xml:'xml',py:'pyspark',scala:'scala',proto:'protobuf'};
    if (map[ext]) {
      // For XML files, do deeper detection
      if (map[ext]==='xml') return detectXMLFormat(content);
      // For JSON, check if it's Avro
      if (map[ext]==='json') { try { const d=JSON.parse(content.trim()); if(d.type==='record'&&d.fields)return 'avro'; } catch(e){} return 'json'; }
      return map[ext];
    }
  }
  const s = content.trim();
  // Protobuf
  if (/\bmessage\s+\w+\s*\{[\s\S]*?(?:string|int32|int64|bool|double)\s+\w+\s*=\s*\d+/i.test(s)) return 'protobuf';
  // PySpark
  if (/StructType\s*\(|StructField\s*\(/i.test(s)) return 'pyspark';
  // Scala case class
  if (/case\s+class\s+\w+\s*\(/i.test(s)) return 'scala';
  // Spark printSchema
  if (/root\s*\n\s*\|--/.test(s)) return 'spark_schema';
  // dbt
  if (/\{\{\s*(ref|source|config)\s*\(/.test(s)) return 'dbt';
  // XML
  if (s.startsWith('<')) return detectXMLFormat(s);
  // DDL (enhanced regex)
  if (/\bCREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMPORARY\s+|GLOBAL\s+TEMPORARY\s+|VOLATILE\s+|TRANSIENT\s+|EXTERNAL\s+|MULTISET\s+|SET\s+|COLUMN\s+|ROW\s+|UNLOGGED\s+)*TABLE\b/i.test(s)) return 'ddl';
  // JSON / Avro
  if (s.startsWith('{') || s.startsWith('[')) { try { const d=JSON.parse(s); if(d.type==='record'&&d.fields)return 'avro'; if(d.tables||d.models)return 'json'; return 'json'; } catch(e){} }
  // YAML
  if (/^(tables|models|sources)\s*:/m.test(s)) return 'yaml';
  // CSV
  const fl = s.split('\n')[0].toLowerCase();
  if (['source_table','target_table','src_table','tgt_table','table_name','column_name'].some(h => fl.includes(h))) return 'csv';
  // Fallback DDL
  if (/\b(INT|VARCHAR|DECIMAL|TIMESTAMP|BOOLEAN|BIGINT|FLOAT|DOUBLE|NUMBER)\b/i.test(s)) return 'ddl';
  return 'unknown';
}

function detectXMLFormat(content) {
  if (/<(REPOSITORY|FOLDER|POWERMART|INFORMATICA)/i.test(content)) return 'informatica_xml';
  if (/<(SOURCE\s|TARGET\s).*?(DATABASETYPE|SOURCEFIELD|TARGETFIELD)/i.test(content)) return 'informatica_xml';
  if (/<(TalendProperties|talendfile|ProcessType|talend)/i.test(content)) return 'talend_xml';
  // NiFi: template exports have <template><snippet><processGroups>
  if (/<template[\s>][\s\S]{0,500}<snippet>/i.test(content.substring(0,2000))) return 'nifi_xml';
  if (/<snippet>[\s\S]{0,500}<(processGroups|controllerServices|processors)/i.test(content.substring(0,5000))) return 'nifi_xml';
  if (/<(flowController|rootGroup|processGroupFlow)\b/i.test(content)) return 'nifi_xml';
  if (/org\.apache\.nifi\./i.test(content.substring(0,10000))) return 'nifi_xml';
  return 'xml';
}

function prepareDDL(content) {
  // Strip block comments (non-nested)
  let clean = content.replace(/\/\*[\s\S]*?\*\//g, ' ');
  // Strip line comments
  clean = clean.replace(/--[^\n]*/g, '');
  // Replace string literals with safe placeholders to prevent paren confusion
  clean = clean.replace(/'(?:[^'\\]|\\.)*'/g, match => "'" + ' '.repeat(Math.max(0,match.length-2)) + "'");
  return clean;
}

function parseDDL(content, sourceName) {
  const tables = [], warnings = [];
  const prepared = prepareDDL(content);
  const hp = /CREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMPORARY\s+|GLOBAL\s+TEMPORARY\s+|VOLATILE\s+|TRANSIENT\s+|EXTERNAL\s+|MULTISET\s+|SET\s+|COLUMN\s+|ROW\s+|UNLOGGED\s+|TEMP\s+)*TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?([^\s(]+)\s*\(/gi;
  let hm;
  while ((hm = hp.exec(prepared)) !== null) {
    const rawName = hm[1]; let start = hm.index + hm[0].length, depth = 1, i = start;
    let limit = 100000;
    while (i < prepared.length && depth > 0 && limit-- > 0) { if (prepared[i]==='(') depth++; else if (prepared[i]===')') depth--; i++; }
    if (depth === 0) {
      // Use original content for body to preserve actual defaults/strings
      const body = content.substring(start, i-1);
      const clean = rawName.replace(/[\[\]`"]/g,''); const parts = clean.split('.');
      const tName = parts[parts.length-1], schema = parts.length>=2 ? parts[parts.length-2] : 'dbo';
      const {cols, fks} = parseTableBody(body);
      if (cols.length > 0) tables.push({name:tName, schema, columns:cols, foreign_keys:fks, row_count:1000});
      else warnings.push(`Table ${tName}: no columns extracted`);
    } else { warnings.push(`Table ${rawName}: unbalanced parentheses`); }
  }
  // ALTER TABLE FKs
  const ap = /ALTER\s+TABLE\s+(\S+)\s+ADD\s+(?:CONSTRAINT\s+\S+\s+)?FOREIGN\s+KEY\s*\(\s*[\[`"]?(\w+)[\]`"]?\s*\)\s*REFERENCES\s+(\S+)\s*\(\s*[\[`"]?(\w+)[\]`"]?\s*\)/gi;
  let am;
  while ((am = ap.exec(content)) !== null) {
    const tn = am[1].replace(/[\[\]`"]/g,'').split('.').pop();
    const fk = {fk_column:am[2], referenced_table:am[3].replace(/[\[\]`"]/g,'').split('.').pop(), referenced_column:am[4]};
    const t = tables.find(t => t.name.toLowerCase() === tn.toLowerCase());
    if (t) t.foreign_keys.push(fk);
  }
  return {source_name:sourceName||'DDL Import', source_type:'sql', tables, input_format:'ddl', parse_warnings:warnings};
}

function parseTableBody(body) {
  const cols = [], fks = [];
  const elems = splitDefs(body);
  for (let el of elems) {
    el = el.trim(); if (!el) continue;
    const upper = el.toUpperCase().trim();
    if (upper.startsWith('PRIMARY KEY')) {
      const pks = extractParensList(el);
      cols.forEach(c => { if (pks.some(p => p.toLowerCase()===c.name.toLowerCase())) c.is_primary_key = true; });
      continue;
    }
    if (upper.startsWith('FOREIGN KEY')) {
      const m = el.match(/FOREIGN\s+KEY\s*\(\s*(\w+)\s*\)\s*REFERENCES\s+(\S+)\s*\(\s*(\w+)\s*\)/i);
      if (m) fks.push({fk_column:m[1], referenced_table:m[2].replace(/[\[\]`"]/g,'').split('.').pop(), referenced_column:m[3]});
      continue;
    }
    if (/^(UNIQUE|CHECK|CONSTRAINT|INDEX)/i.test(upper)) continue;
    const r = parseColDef(el);
    if (r.col) { cols.push(r.col); if (r.fk) fks.push(r.fk); }
  }
  return {cols, fks};
}

function parseColDef(el) {
  const s = el.trim();
  const nm = s.match(/^([`"\[\]]?\w+[`"\]\]]?)\s+/);
  if (!nm) return {};
  const rawName = nm[1].replace(/[\[\]`"]/g,'');
  let rest = s.substring(nm[0].length);
  let rawType = '', typeArgs = null;
  const rl = rest.toLowerCase();
  for (const mwt of MW_TYPES.sort((a,b)=>b.length-a.length)) {
    if (rl.startsWith(mwt)) { rawType = mwt; rest = rest.substring(mwt.length).trim(); break; }
  }
  if (!rawType) {
    const tm = rest.match(/^([A-Za-z_]\w*)/);
    if (!tm) return {};
    rawType = tm[1].toLowerCase(); rest = rest.substring(tm[0].length).trim();
  }
  if (rest.startsWith('(')) {
    const pe = rest.indexOf(')');
    if (pe > 0) { typeArgs = rest.substring(1, pe); rest = rest.substring(pe+1).trim(); }
  }
  const modsOrig = rest, mods = rest.toUpperCase();
  const ctype = TYPE_NORM[rawType] || rawType;
  let prec=null, scl=null, maxl=null;
  if (typeArgs) {
    const pts = typeArgs.split(',').map(p=>p.trim());
    if (['decimal','numeric'].includes(ctype)) { prec = parseInt(pts[0])||null; scl = pts[1]?parseInt(pts[1]):null; }
    else if (['varchar','char','text'].includes(ctype)) { if (/^\d+$/.test(pts[0])) maxl = parseInt(pts[0]); }
  }
  const nullable = !mods.includes('NOT NULL'), isPK = mods.includes('PRIMARY KEY'), isUnique = mods.includes('UNIQUE');
  let checkVals = [];
  const cm = modsOrig.match(/CHECK\s*\(.*?IN\s*\(([^)]+)\)/i);
  if (cm) checkVals = cm[1].split(',').map(v=>v.trim().replace(/^['"]|['"]$/g,''));
  let defaultVal = null;
  const dm = modsOrig.match(/DEFAULT\s+(\S+)/i);
  if (dm) defaultVal = dm[1].replace(/^['"]|['"]$/g,'');
  let fk = null;
  const rm = modsOrig.match(/REFERENCES\s+([\w`"\[\]]+)(?:\s*\(\s*(\w+)\s*\))?/i);
  if (rm) fk = {fk_column:rawName, referenced_table:rm[1].replace(/[\[\]`"]/g,''), referenced_column:rm[2]||'id'};
  let pk = isPK;
  if (mods.includes('IDENTITY') || mods.includes('AUTO_INCREMENT')) pk = true;
  if (['serial','bigserial','smallserial'].includes(rawType)) pk = true;
  return { col: {name:rawName, data_type:ctype, raw_type:typeArgs?`${rawType}(${typeArgs})`:rawType,
    nullable, is_primary_key:pk, is_unique:isUnique, default_value:defaultVal,
    check_constraints:checkVals, precision:prec, scale:scl, max_length:maxl}, fk };
}

function splitDefs(body) {
  const elems = []; let cur = '', depth = 0;
  for (const c of body) {
    if (c==='(') { depth++; cur+=c; } else if (c===')') { depth--; cur+=c; }
    else if (c===',' && depth===0) { elems.push(cur); cur=''; } else cur+=c;
  }
  if (cur) elems.push(cur);
  return elems;
}

function extractParensList(el) {
  const m = el.match(/\(([^)]+)\)/);
  return m ? m[1].split(',').map(n=>n.trim().replace(/[\[\]`"]/g,'')) : [];
}

function parseJSON(content, sourceName) {
  let data;
  try { data = JSON.parse(content.trim()); } catch(e) { return {source_name:sourceName||'JSON',source_type:'json',tables:[],input_format:'json',parse_warnings:['Invalid JSON: '+e.message]}; }
  const src = data.tables || data.models || (Array.isArray(data) ? data : []);
  const tables = (Array.isArray(src) ? src : Object.values(src)).map(t => {
    const cols = (t.columns||[]).map(c => {
      if (typeof c === 'string') { const p = c.split(':'); return {name:p[0].trim(), data_type:p[1]?p[1].trim():'varchar', raw_type:p[1]||'varchar', nullable:true, is_primary_key:false, is_unique:false, check_constraints:[], max_length:null, precision:null, scale:null, default_value:null}; }
      return {name:c.name||c.column_name||'', data_type:c.type||c.data_type||'varchar', raw_type:c.type||c.data_type||'varchar', nullable:c.nullable!==false, is_primary_key:!!c.pk||!!c.primary_key||!!c.is_primary_key, is_unique:false, check_constraints:c.values||c.allowed_values||[], max_length:c.length||c.max_length||null, precision:null, scale:null, default_value:null};
    });
    const fks = (t.foreign_keys||t.fks||[]).map(fk=>({fk_column:fk.column||'', referenced_table:fk.references||fk.referenced_table||'', referenced_column:fk.references_column||fk.referenced_column||'id'}));
    return {name:t.name||'', schema:t.schema||'dbo', columns:cols, foreign_keys:fks, row_count:1000};
  });
  return {source_name:data.name||sourceName||'JSON Import', source_type:data.type||'json', tables, input_format:'json', parse_warnings:[]};
}

function parseXML(content, sourceName) {
  let doc;
  try { doc = new DOMParser().parseFromString(content, 'text/xml'); } catch(e) { return {source_name:sourceName||'XML',source_type:'xml',tables:[],input_format:'xml',parse_warnings:['Invalid XML: '+e.message]}; }
  // Check for parse errors
  const parseErr = doc.querySelector('parsererror');
  if (parseErr) return {source_name:sourceName||'XML',source_type:'xml',tables:[],input_format:'xml',parse_warnings:['XML parse error: '+parseErr.textContent.substring(0,200)]};
  const tables = [];
  function getAttrCI(el, names) { for (const n of names) { const v = el.getAttribute(n); if (v) return v; } return ''; }
  function isBoolTrue(v) { return ['true','yes','1','y'].includes((v||'').toLowerCase()); }
  // Find table elements (case-insensitive, namespace-aware)
  const allEls = doc.querySelectorAll('*');
  const tableEls = [...allEls].filter(el => el.localName.toLowerCase() === 'table');
  tableEls.forEach(te => {
    const name = getAttrCI(te, ['name','Name','NAME']); if (!name) return;
    const cols = [], fks = [];
    const colEls = [...te.querySelectorAll('*')].filter(el => el.localName.toLowerCase() === 'column');
    colEls.forEach(ce => {
      const cn = getAttrCI(ce, ['name','Name','NAME']); if (!cn) return;
      const rt = getAttrCI(ce, ['type','Type','TYPE','dataType','datatype','DATATYPE'])||'varchar';
      const dtRaw = rt.toLowerCase().split('(')[0];
      const dt = TYPE_NORM[dtRaw] || dtRaw;
      const nullable = !['false','no','0'].includes((getAttrCI(ce, ['nullable','Nullable','NULLABLE'])||'true').toLowerCase());
      const pk = isBoolTrue(getAttrCI(ce, ['primaryKey','pk','PK','primary_key','isPrimaryKey','KEYTYPE']));
      const ml = getAttrCI(ce, ['length','Length','LENGTH','maxLength','PRECISION']);
      const checkStr = getAttrCI(ce, ['check','values','Values','CHECK','accepted_values'])||'';
      const checks = checkStr ? checkStr.split(',').map(v=>v.trim()).filter(Boolean) : [];
      cols.push({name:cn, data_type:dt, raw_type:rt, nullable, is_primary_key:pk, is_unique:false, check_constraints:checks, max_length:ml?parseInt(ml)||null:null, precision:null, scale:null, default_value:null});
      const ref = getAttrCI(ce, ['references','References','REFERENCES']);
      if (ref) { const r = parseRefStr(cn, ref); if (r) fks.push(r); }
    });
    const fkEls = [...te.querySelectorAll('*')].filter(el => ['foreignkey','foreign_key','fk'].includes(el.localName.toLowerCase()));
    fkEls.forEach(fe => {
      const col = getAttrCI(fe, ['column','Column','COLUMN'])||'';
      const ref = getAttrCI(fe, ['references','References','REFERENCES'])||'';
      if (col && ref) { const r = parseRefStr(col, ref); if (r) fks.push(r); }
    });
    tables.push({name, schema:getAttrCI(te, ['schema','Schema','SCHEMA'])||'dbo', columns:cols, foreign_keys:fks, row_count:1000});
  });
  return {source_name:sourceName||'XML Import', source_type:'xml', tables, input_format:'xml', parse_warnings:[]};
}

function parseRefStr(fkCol, refStr) {
  const m = refStr.match(/^(\w+)\((\w+)\)$/);
  if (m) return {fk_column:fkCol, referenced_table:m[1], referenced_column:m[2]};
  if (refStr.includes('.')) { const p = refStr.split('.'); return {fk_column:fkCol, referenced_table:p[0], referenced_column:p[1]}; }
  return {fk_column:fkCol, referenced_table:refStr.trim(), referenced_column:'id'};
}

function splitCSVLine(line) {
  const fields = [];
  let current = '', inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const c = line[i];
    if (c === '"') {
      if (inQuotes && line[i+1] === '"') { current += '"'; i++; }
      else inQuotes = !inQuotes;
    } else if (c === ',' && !inQuotes) { fields.push(current.trim()); current = ''; }
    else if (c === '\r') { /* skip */ }
    else current += c;
  }
  fields.push(current.trim());
  return fields;
}

function parseCSV(content, sourceName) {
  const lines = content.trim().split('\n');
  if (lines.length < 2) return {source_name:sourceName, source_type:'csv', tables:[], input_format:'csv', parse_warnings:['No data rows']};
  const headers = splitCSVLine(lines[0]).map(h=>h.toLowerCase());
  const findH = (syns) => { for (const s of syns) { const i = headers.indexOf(s); if (i>=0) return i; } return -1; };
  const iTT = findH(['target_table','tgt_table','to_table','dest_table','source_table','src_table']);
  const iTC = findH(['target_column','tgt_column','to_column','dest_column','source_column','src_column']);
  const iType = findH(['target_type','tgt_type','source_type','src_type','data_type','type']);
  const iPK = findH(['primary_key','pk','is_pk']);
  const iNull = findH(['nullable','is_nullable','null']);
  const iFKT = findH(['foreign_key_table','fk_table','ref_table','references_table']);
  const iFKC = findH(['foreign_key_column','fk_column','ref_column','references_column']);
  const tablesMap = {};
  for (let r = 1; r < lines.length; r++) {
    const vals = splitCSVLine(lines[r]);
    const tbl = iTT>=0?vals[iTT]:''; const col = iTC>=0?vals[iTC]:'';
    if (!tbl||!col) continue;
    if (!tablesMap[tbl]) tablesMap[tbl] = {columns:[], foreign_keys:[]};
    const dtype = (iType>=0?vals[iType]:'varchar').toLowerCase().split('(')[0];
    const nullable = iNull>=0 ? !['false','no','0'].includes(vals[iNull].toLowerCase()) : true;
    const pk = iPK>=0 ? ['true','yes','1','pk'].includes(vals[iPK].toLowerCase()) : false;
    tablesMap[tbl].columns.push({name:col, data_type:dtype, raw_type:iType>=0?vals[iType]:'varchar', nullable, is_primary_key:pk, is_unique:false, check_constraints:[], max_length:null, precision:null, scale:null, default_value:null});
    const fkTbl = iFKT>=0?vals[iFKT]:''; const fkCol = iFKC>=0?vals[iFKC]:'id';
    if (fkTbl) tablesMap[tbl].foreign_keys.push({fk_column:col, referenced_table:fkTbl, referenced_column:fkCol});
  }
  const tables = Object.entries(tablesMap).map(([n,d])=>({name:n, schema:'dbo', columns:d.columns, foreign_keys:d.foreign_keys, row_count:1000}));
  return {source_name:sourceName||'CSV Import', source_type:'csv', tables, input_format:'csv', parse_warnings:[]};
}

// ================================================================
// PARSERS — YAML (table definitions + dbt schema.yml)
// ================================================================
function parseSimpleYAML(text) {
  // Normalize tabs to 2 spaces and strip inline comments
  let normalized = text.replace(/\t/g, '  ');
  const lines = normalized.split('\n').map((l,i) => {
    // Strip inline comments (outside quotes)
    let tr = l.replace(/\s+#(?![^'"]*['"][^'"]*$).*$/, '').trimEnd();
    const ind = tr.search(/\S/) < 0 ? 999 : tr.search(/\S/);
    return {raw:l, ind, tr:tr.trim(), i};
  }).filter(l=>l.tr&&!l.tr.startsWith('#'));
  let pos = 0;
  function scalar(s) { s=s.trim(); if(s==='true')return true; if(s==='false')return false; if(s==='null'||s==='~'||!s)return null; if(/^-?\d+$/.test(s))return parseInt(s); if(/^-?\d+\.\d+$/.test(s))return parseFloat(s); return s.replace(/^['"]|['"]$/g,''); }
  function parseAt(base) {
    if(pos>=lines.length)return null;
    return lines[pos].tr.startsWith('-')?parseList(base):parseMap(base);
  }
  function parseMap(base) {
    const r={}; while(pos<lines.length&&lines[pos].ind>=base) {
      if(lines[pos].ind>base||lines[pos].tr.startsWith('-'))break;
      const ci=lines[pos].tr.indexOf(':'); if(ci<0){pos++;continue;}
      const k=lines[pos].tr.substring(0,ci).trim(), v=lines[pos].tr.substring(ci+1).trim(); pos++;
      if(v) r[k]=scalar(v); else if(pos<lines.length&&lines[pos].ind>base) r[k]=parseAt(lines[pos].ind); else r[k]=null;
    } return r;
  }
  function parseList(base) {
    const r=[]; while(pos<lines.length&&lines[pos].ind>=base) {
      if(lines[pos].ind>base&&!lines[pos].tr.startsWith('-'))break;
      if(!lines[pos].tr.startsWith('-'))break;
      const item=lines[pos].tr.substring(lines[pos].tr.indexOf('-')+1).trim();
      const itemInd=lines[pos].ind; pos++;
      if(item.includes(':')) {
        const obj={}; const ci=item.indexOf(':'); const k=item.substring(0,ci).trim(); const v=item.substring(ci+1).trim();
        if(v) obj[k]=scalar(v); else if(pos<lines.length&&lines[pos].ind>itemInd) obj[k]=parseAt(lines[pos].ind); else obj[k]=null;
        while(pos<lines.length&&lines[pos].ind>itemInd&&!lines[pos].tr.startsWith('-')) {
          const ci2=lines[pos].tr.indexOf(':'); if(ci2<0)break;
          const k2=lines[pos].tr.substring(0,ci2).trim(), v2=lines[pos].tr.substring(ci2+1).trim();
          const curInd=lines[pos].ind; pos++;
          if(v2) obj[k2]=scalar(v2); else if(pos<lines.length&&lines[pos].ind>curInd) obj[k2]=parseAt(lines[pos].ind); else obj[k2]=null;
        } r.push(obj);
      } else { r.push(item?scalar(item):null); }
    } return r;
  }
  if(!lines.length)return {}; return parseAt(lines[0].ind);
}

function parseYAML(content, sourceName) {
  const data = parseSimpleYAML(content);
  const tables = [];
  const src = data.tables || data.models || data.sources || [];
  if (!Array.isArray(src)) return {source_name:sourceName||'YAML',source_type:'yaml',tables:[],input_format:'yaml',parse_warnings:['No tables/models found']};
  src.forEach(t => {
    if (!t || !t.name) return;
    const cols = (t.columns||[]).map(c => {
      if (typeof c === 'string') { const p=c.split(':'); return {name:p[0].trim(),data_type:p[1]?p[1].trim():'varchar',raw_type:p[1]||'varchar',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}; }
      const dt = (c.type||c.data_type||'varchar').toLowerCase().split('(')[0];
      const pk = !!c.primary_key||!!c.pk||(Array.isArray(c.tests)&&(c.tests.includes('unique')||c.tests.includes('not_null')));
      return {name:c.name||'',data_type:TYPE_NORM[dt]||dt,raw_type:c.type||c.data_type||'varchar',nullable:c.nullable!==false,is_primary_key:pk,is_unique:false,check_constraints:c.accepted_values||[],max_length:c.length||null,precision:null,scale:null,default_value:null};
    });
    const fks = (t.foreign_keys||[]).map(fk=>({fk_column:fk.column||'',referenced_table:fk.references||fk.ref||'',referenced_column:fk.references_column||fk.ref_column||'id'}));
    tables.push({name:t.name,schema:t.schema||'dbo',columns:cols,foreign_keys:fks,row_count:1000});
  });
  return {source_name:sourceName||'YAML Import',source_type:'yaml',tables,input_format:'yaml',parse_warnings:[]};
}

// ================================================================
// PARSERS — PySpark (StructType / StructField)
// ================================================================
function parsePySpark(content, sourceName) {
  const tables = [], warnings = [];
  const sparkTypeMap = {string:'varchar',integer:'int',long:'bigint',short:'smallint',byte:'tinyint',float:'float',double:'double',decimal:'decimal',boolean:'boolean',date:'date',timestamp:'timestamp',binary:'binary',array:'text',map:'text',struct:'text',int:'int'};
  const stPat = /(?:(\w+)\s*=\s*)?StructType\s*\(\s*\[([\s\S]*?)\]\s*\)/g;
  let m;
  while ((m=stPat.exec(content))!==null) {
    const varName = m[1]||'table'; const body = m[2]; const cols = [];
    // Flexible: handles StringType() or StringType or "string" — with or without Type suffix
    const fPat = /StructField\s*\(\s*["']([^"']+)["']\s*,\s*(?:["'])?(\w+?)(?:Type)?(?:["'])?\s*(?:\(\s*(?:(\d+)(?:\s*,\s*(\d+))?)?\s*\))?\s*(?:,\s*(True|False|true|false))?\s*\)/g;
    let fm;
    while ((fm=fPat.exec(body))!==null) {
      const dt = sparkTypeMap[fm[2].toLowerCase()]||'varchar';
      cols.push({name:fm[1],data_type:dt,raw_type:fm[2]+'Type',nullable:fm[5]?fm[5].toLowerCase()!=='false':true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:fm[3]?parseInt(fm[3]):null,scale:fm[4]?parseInt(fm[4]):null,default_value:null});
    }
    if (cols.length) { const tn=varName.replace(/_?schema$/i,'')||'table'; tables.push({name:tn,schema:'default',columns:cols,foreign_keys:[],row_count:1000}); }
  }
  // Also try spark.sql("CREATE TABLE ...")
  const sqlM = content.match(/spark\.sql\s*\(\s*["']{1,3}([\s\S]*?)["']{1,3}\s*\)/);
  if (sqlM && /CREATE\s+TABLE/i.test(sqlM[1])) { const ddl = parseDDL(sqlM[1],'PySpark SQL'); tables.push(...ddl.tables); }
  return {source_name:sourceName||'PySpark Schema',source_type:'pyspark',tables,input_format:'pyspark',parse_warnings:warnings};
}

// ================================================================
// PARSERS — Scala (case class)
// ================================================================
function parseScala(content, sourceName) {
  const tables = [];
  const scalaTypeMap = {String:'varchar',Int:'int',Long:'bigint',Short:'smallint',Double:'double',Float:'float',BigDecimal:'decimal',Boolean:'boolean',Date:'date',Timestamp:'timestamp',Byte:'tinyint',Char:'char',Array:'text',List:'text',Seq:'text',Set:'text',Map:'text',Vector:'text',UUID:'varchar'};
  // Handle generic type params: case class Foo[T](...) — skip the [T] part
  const ccPat = /case\s+class\s+(\w+)(?:\[[\w\s,<>\[\]]+\])?\s*\(([\s\S]*?)\)/g;
  let m;
  while ((m=ccPat.exec(content))!==null) {
    const className = m[1]; const body = m[2]; const cols = [];
    const fPat = /(\w+)\s*:\s*(Option\s*\[\s*)?([\w.\[\],\s]+)\]?\s*/g;
    let fm;
    while ((fm=fPat.exec(body))!==null) {
      const nullable = !!fm[2]; let st = fm[3].trim().replace(/\s/g,'');
      // Extract inner type from generics: List[String] → String, Map[String,Int] → text
      if (/^(List|Seq|Set|Vector|Array)\[/.test(st)) st = 'Array';
      else if (/^Map\[/.test(st)) st = 'Map';
      else if (/^Option\[/.test(st)) { const inner = st.match(/^Option\[(\w+)\]/); if(inner) st = inner[1]; }
      // Smart CamelCase: HTTPServer → http_server, not h_t_t_p_server
      const dt = scalaTypeMap[st] || scalaTypeMap[st.replace(/.*\./, '')] || 'varchar';
      cols.push({name:fm[1],data_type:dt,raw_type:st,nullable,is_primary_key:fm[1].toLowerCase()==='id',is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null});
    }
    if (cols.length) {
      const tn = className.replace(/([A-Z]+)([A-Z][a-z])/g,'$1_$2').replace(/([a-z])([A-Z])/g,'$1_$2').toLowerCase();
      tables.push({name:tn,schema:'default',columns:cols,foreign_keys:[],row_count:1000});
    }
  }
  return {source_name:sourceName||'Scala Case Classes',source_type:'scala',tables,input_format:'scala',parse_warnings:[]};
}

// ================================================================
// PARSERS — dbt (model SQL with Jinja)
// ================================================================
function parseDBT(content, sourceName) {
  const tables = [], warnings = [];
  const refs = [];
  const refPat = /\{\{\s*(?:ref|source)\s*\(\s*['"](\w+)['"](?:\s*,\s*['"](\w+)['"])?\s*\)\s*\}\}/g;
  let rm; while ((rm=refPat.exec(content))!==null) refs.push(rm[2]||rm[1]);
  let cleanSQL = content.replace(/\{\{[\s\S]*?\}\}/g,'__JINJA__').replace(/\{%[\s\S]*?%\}/g,'');
  // Strip window functions OVER(...) before column extraction
  cleanSQL = cleanSQL.replace(/\bOVER\s*\([^)]*\)/gi, '');
  if (/CREATE\s+TABLE/i.test(cleanSQL)) return parseDDL(cleanSQL.replace(/__JINJA__/g,'dual'), sourceName||'dbt Model');
  // Handle CTEs: WITH cte AS (SELECT ...) SELECT ... — use the final SELECT
  let selectSQL = cleanSQL;
  const cteMatch = cleanSQL.match(/\bWITH\b[\s\S]*?\)\s*(SELECT[\s\S]*$)/i);
  if (cteMatch) selectSQL = cteMatch[1];
  const selM = selectSQL.match(/SELECT\s+([\s\S]*?)\s+FROM/i);
  if (selM) {
    const cols = []; const parts = selM[1].split(',').map(c=>c.trim()).filter(Boolean);
    for (const p of parts) {
      if (p==='*' || p==='__JINJA__') continue;
      const asM = p.match(/(?:AS\s+)?["']?(\w+)["']?\s*$/i); if (!asM) continue;
      let dt = 'varchar'; const castM = p.match(/(?:CAST\s*\(.*?AS\s+(\w+)|::(\w+))/i);
      if (castM) dt = (castM[1]||castM[2]).toLowerCase();
      cols.push({name:asM[1],data_type:TYPE_NORM[dt]||dt,raw_type:dt,nullable:true,is_primary_key:cols.length===0&&asM[1].toLowerCase().endsWith('_id'),is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null});
    }
    if (cols.length) { const cfgM=content.match(/alias\s*=\s*['"](\w+)['"]/); tables.push({name:cfgM?cfgM[1]:'dbt_model',schema:'dbt',columns:cols,foreign_keys:[],row_count:1000}); }
  }
  return {source_name:sourceName||'dbt Model',source_type:'dbt',tables,input_format:'dbt',parse_warnings:refs.length?['References: '+refs.join(', ')]:warnings};
}

// ================================================================
// PARSERS — Avro (.avsc)
// ================================================================
function avroTypeMap(t) {
  const m={null:'varchar',boolean:'boolean',int:'int',long:'bigint',float:'float',double:'double',bytes:'binary',string:'varchar',fixed:'binary',enum:'varchar',array:'text',map:'text',record:'text',decimal:'decimal',date:'date','time-millis':'int','timestamp-millis':'timestamp','timestamp-micros':'timestamp',uuid:'varchar'};
  return m[t]||'varchar';
}
function parseAvro(content, sourceName) {
  let data; try { data = JSON.parse(content.trim()); } catch(e) { return {source_name:sourceName||'Avro',source_type:'avro',tables:[],input_format:'avro',parse_warnings:['Invalid JSON in Avro: '+e.message]}; }
  const tables = [];
  function parseRecord(rec) {
    if (!rec||rec.type!=='record'||!rec.fields) return null;
    const cols = rec.fields.map(f => {
      let dt='varchar',nullable=false,raw='';
      if (typeof f.type==='string') { raw=f.type; dt=avroTypeMap(f.type); }
      else if (Array.isArray(f.type)) { nullable=f.type.includes('null'); const nn=f.type.filter(t=>t!=='null')[0]; raw=typeof nn==='string'?nn:JSON.stringify(nn); dt=typeof nn==='string'?avroTypeMap(nn):avroTypeMap((nn&&nn.logicalType)||nn?.type||'string'); }
      else if (typeof f.type==='object') { raw=f.type.logicalType||f.type.type||'string'; dt=avroTypeMap(f.type.logicalType||f.type.type); }
      return {name:f.name,data_type:dt,raw_type:raw,nullable,is_primary_key:/^(id|key)$/i.test(f.name),is_unique:false,check_constraints:[],max_length:null,precision:f.type?.precision||null,scale:f.type?.scale||null,default_value:f.default??null};
    });
    const tn=rec.name.replace(/([A-Z])/g,'_$1').toLowerCase().replace(/^_/,'');
    return {name:tn,schema:rec.namespace||'default',columns:cols,foreign_keys:[],row_count:1000};
  }
  if (data.type==='record') { const t=parseRecord(data); if(t)tables.push(t); }
  else if (Array.isArray(data)) data.forEach(d=>{const t=parseRecord(d);if(t)tables.push(t);});
  return {source_name:sourceName||'Avro Schema',source_type:'avro',tables,input_format:'avro',parse_warnings:[]};
}

// ================================================================
// PARSERS — Protobuf (.proto)
// ================================================================
function parseProtobuf(content, sourceName) {
  const tables = [];
  const protoTypeMap={double:'double',float:'float',int32:'int',int64:'bigint',uint32:'int',uint64:'bigint',sint32:'int',sint64:'bigint',fixed32:'int',fixed64:'bigint',sfixed32:'int',sfixed64:'bigint',bool:'boolean',string:'varchar',bytes:'binary'};
  // Strip comments
  let clean = content.replace(/\/\*[\s\S]*?\*\//g, ' ').replace(/\/\/[^\n]*/g, '');
  // Depth-aware message extraction to handle nested messages
  function extractMessages(src, prefix) {
    const msgPat = /message\s+(\w+)\s*\{/g;
    let mm;
    while ((mm=msgPat.exec(src))!==null) {
      const msgName = mm[1]; let depth=1, i=mm.index+mm[0].length;
      while (i < src.length && depth > 0) { if(src[i]==='{')depth++; else if(src[i]==='}')depth--; i++; }
      const body = src.substring(mm.index+mm[0].length, i-1);
      const cols = [];
      // Parse fields including map<K,V>
      const fPat = /(?:(optional|required|repeated)\s+)?(?:map\s*<\s*\w+\s*,\s*\w+\s*>|(\w+))\s+(\w+)\s*=\s*\d+/g;
      let fm;
      while ((fm=fPat.exec(body))!==null) {
        if (fm[0].includes('map<')) {
          cols.push({name:fm[3],data_type:'text',raw_type:'map',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null});
        } else if (fm[2] && !['message','enum','oneof','option','reserved','extensions'].includes(fm[2])) {
          cols.push({name:fm[3],data_type:protoTypeMap[fm[2]]||'varchar',raw_type:fm[2],nullable:fm[1]!=='required',is_primary_key:fm[3].toLowerCase()==='id',is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null});
        }
      }
      // Extract oneof fields
      const oneofPat = /oneof\s+\w+\s*\{([\s\S]*?)\}/g;
      let om;
      while ((om=oneofPat.exec(body))!==null) {
        const ofPat = /(\w+)\s+(\w+)\s*=\s*\d+/g; let ofm;
        while ((ofm=ofPat.exec(om[1]))!==null) {
          cols.push({name:ofm[2],data_type:protoTypeMap[ofm[1]]||'varchar',raw_type:ofm[1],nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null});
        }
      }
      // Extract enum values as check constraints
      const enumPat = /enum\s+(\w+)\s*\{([\s\S]*?)\}/g;
      let em;
      while ((em=enumPat.exec(body))!==null) {
        const enumVals = []; const evPat = /(\w+)\s*=\s*\d+/g; let evm;
        while ((evm=evPat.exec(em[2]))!==null) enumVals.push(evm[1]);
        const enumCol = cols.find(c=>c.raw_type.toLowerCase()===em[1].toLowerCase());
        if (enumCol) enumCol.check_constraints = enumVals;
      }
      if (cols.length) {
        const fullName = prefix ? prefix+'_'+msgName : msgName;
        const tn = fullName.replace(/([A-Z]+)([A-Z][a-z])/g,'$1_$2').replace(/([a-z])([A-Z])/g,'$1_$2').toLowerCase();
        tables.push({name:tn,schema:'default',columns:cols,foreign_keys:[],row_count:1000});
      }
      // Recurse for nested messages
      extractMessages(body, prefix ? prefix+'_'+msgName : msgName);
    }
  }
  extractMessages(clean, '');
  return {source_name:sourceName||'Protobuf Schema',source_type:'protobuf',tables,input_format:'protobuf',parse_warnings:[]};
}

// ================================================================
// PARSERS — Spark printSchema output
// ================================================================
function parseSparkSchema(content, sourceName) {
  const cols = [];
  const fPat = /\|--\s+(\w+):\s+(\w+)(?:\(([^)]*)\))?\s*\(nullable\s*=\s*(true|false)\)/g;
  let m;
  while ((m=fPat.exec(content))!==null) {
    const sparkMap={string:'varchar',integer:'int',long:'bigint',short:'smallint',byte:'tinyint',float:'float',double:'double',decimal:'decimal',boolean:'boolean',date:'date',timestamp:'timestamp',binary:'binary'};
    cols.push({name:m[1],data_type:sparkMap[m[2]]||'varchar',raw_type:m[2]+(m[3]?`(${m[3]})`:''),nullable:m[4]==='true',is_primary_key:m[1]==='id',is_unique:false,check_constraints:[],max_length:null,precision:m[3]?parseInt(m[3].split(',')[0]):null,scale:m[3]&&m[3].includes(',')?parseInt(m[3].split(',')[1]):null,default_value:null});
  }
  if (!cols.length) return null;
  return {source_name:sourceName||'Spark Schema',source_type:'spark',tables:[{name:'spark_table',schema:'default',columns:cols,foreign_keys:[],row_count:1000}],input_format:'spark_schema',parse_warnings:[]};
}

// ================================================================
// PARSERS — Informatica XML (PowerCenter / IICS)
// ================================================================
function parseInformaticaXML(doc, sourceName) {
  const tables = [];
  const allEls = [...doc.querySelectorAll('*')];
  function findByLocal(name) { return allEls.filter(el => el.localName.toLowerCase() === name.toLowerCase()); }
  function getAttr(el, names) { for (const n of names) { const v = el.getAttribute(n); if (v != null) return v; } return ''; }
  function parseFields(parent, fieldNames) {
    const cols = [];
    const children = [...parent.querySelectorAll('*')].filter(el => fieldNames.some(fn => el.localName.toLowerCase() === fn));
    children.forEach(sf => {
      const cn = getAttr(sf, ['NAME','name','Name']); if(!cn) return;
      const rt = getAttr(sf, ['DATATYPE','datatype','DataType','type'])||'varchar';
      const prec = parseInt(getAttr(sf, ['PRECISION','precision','Precision'])||'0')||0;
      const scale = parseInt(getAttr(sf, ['SCALE','scale','Scale'])||'0')||0;
      const nullVal = getAttr(sf, ['NULLABLE','nullable','Nullable'])||'NULL';
      const nullable = nullVal !== 'NOTNULL' && nullVal.toLowerCase() !== 'false';
      const keyType = getAttr(sf, ['KEYTYPE','keytype','KeyType'])||'';
      const pk = keyType === 'PRIMARY KEY' || keyType.toLowerCase() === 'primary';
      const dt = TYPE_NORM[rt.toLowerCase()]||rt.toLowerCase().split('(')[0];
      cols.push({name:cn,data_type:dt,raw_type:rt,nullable,is_primary_key:pk,is_unique:false,check_constraints:[],max_length:prec||null,precision:['decimal','numeric','number'].includes(dt)?prec:null,scale:scale||null,default_value:null});
    });
    return cols;
  }
  // Find SOURCE elements (any case, any namespace)
  findByLocal('source').forEach(src => {
    const name = getAttr(src, ['NAME','name','Name']); if(!name) return;
    const cols = parseFields(src, ['sourcefield']);
    if (cols.length) tables.push({name,schema:'dbo',columns:cols,foreign_keys:[],row_count:1000});
  });
  findByLocal('target').forEach(tgt => {
    const name = getAttr(tgt, ['NAME','name','Name']); if(!name) return;
    if (tables.find(t=>t.name===name)) return;
    const cols = parseFields(tgt, ['targetfield']);
    if (cols.length) tables.push({name,schema:'dbo',columns:cols,foreign_keys:[],row_count:1000});
  });
  return {source_name:sourceName||'Informatica Import',source_type:'informatica',tables,input_format:'informatica_xml',parse_warnings:[]};
}

// ================================================================
// PARSERS — Talend XML
// ================================================================
function parseTalendXML(doc, sourceName) {
  const tables = [];
  const talendTypeMap = {id_String:'varchar',id_Integer:'int',id_Long:'bigint',id_Short:'smallint',id_Byte:'tinyint',id_Float:'float',id_Double:'double',id_BigDecimal:'decimal',id_Boolean:'boolean',id_Date:'date',id_Character:'char',id_byte_array:'binary',id_Object:'text',id_List:'text',id_Document:'text',id_Dynamic:'text'};
  doc.querySelectorAll('schema, Schema, metadata').forEach(schema => {
    const name = schema.getAttribute('name')||schema.getAttribute('Name')||schema.getAttribute('label')||'talend_table';
    const cols = [];
    schema.querySelectorAll('column, Column').forEach(col => {
      const cn = col.getAttribute('name')||col.getAttribute('label')||''; if(!cn) return;
      const tt = col.getAttribute('type')||col.getAttribute('talendType')||'id_String';
      const length = parseInt(col.getAttribute('length')||'0');
      const nullable = (col.getAttribute('nullable')||'true')!=='false';
      const pk = (col.getAttribute('key')||'false')==='true';
      cols.push({name:cn,data_type:talendTypeMap[tt]||'varchar',raw_type:tt,nullable,is_primary_key:pk,is_unique:false,check_constraints:[],max_length:length||null,precision:null,scale:null,default_value:null});
    });
    if (cols.length) tables.push({name,schema:'dbo',columns:cols,foreign_keys:[],row_count:1000});
  });
  return {source_name:sourceName||'Talend Import',source_type:'talend',tables,input_format:'talend_xml',parse_warnings:[]};
}

// ================================================================
// PARSERS — Apache NiFi XML (template / flow definition)
// ================================================================
function parseNiFiXML(doc, sourceName) {
  const tables = [], processors = [], connections = [], controllerServices = [], processGroups = [];
  const idToName = {};

  // NiFi templates nest everything: template > snippet > processGroups > contents > processors
  // Recursively extract all processors, connections, etc. from nested processGroups
  function extractFromGroup(groupEl, groupName) {
    const contents = groupEl.querySelector(':scope > contents') || groupEl;
    // Processors — direct children of contents
    contents.querySelectorAll(':scope > processors').forEach(proc => {
      const name = getChildText(proc, 'name');
      const type = getChildText(proc, 'type');
      const shortType = type.split('.').pop();
      const state = getChildText(proc, 'state');
      const props = extractProperties(proc);
      const schedPeriod = proc.querySelector('config > schedulingPeriod')?.textContent || '';
      const schedStrategy = proc.querySelector('config > schedulingStrategy')?.textContent || '';
      const id = getChildText(proc, 'id');
      if (id) idToName[id] = name || shortType;
      processors.push({name, type:shortType, fullType:type, state, properties:props, group:groupName, schedulingPeriod:schedPeriod, schedulingStrategy:schedStrategy});
    });
    // Connections — direct children of contents
    contents.querySelectorAll(':scope > connections').forEach(conn => {
      const srcId = conn.querySelector('source > id')?.textContent || getChildText(conn, 'sourceId') || '';
      const dstId = conn.querySelector('destination > id')?.textContent || getChildText(conn, 'destinationId') || '';
      const srcType = conn.querySelector('source > type')?.textContent || '';
      const dstType = conn.querySelector('destination > type')?.textContent || '';
      const rels = [];
      conn.querySelectorAll(':scope > selectedRelationships').forEach(r => { if(r.textContent) rels.push(r.textContent); });
      const bp = getChildText(conn, 'backPressureObjectThreshold');
      connections.push({sourceId:srcId, destinationId:dstId, sourceType:srcType, destinationType:dstType, relationships:rels, backPressure:bp});
    });
    // Input/output ports
    contents.querySelectorAll(':scope > inputPorts').forEach(p => {
      const id = getChildText(p, 'id'), name = getChildText(p, 'name');
      if(id) idToName[id] = name || 'input_port';
    });
    contents.querySelectorAll(':scope > outputPorts').forEach(p => {
      const id = getChildText(p, 'id'), name = getChildText(p, 'name');
      if(id) idToName[id] = name || 'output_port';
    });
    // Nested processGroups
    contents.querySelectorAll(':scope > processGroups').forEach(pg => {
      const pgName = getChildText(pg, 'name');
      const pgId = getChildText(pg, 'id');
      if(pgId) idToName[pgId] = pgName;
      processGroups.push({name:pgName, parentGroup:groupName});
      extractFromGroup(pg, pgName);
    });
  }

  function getChildText(el, tag) {
    const child = el.querySelector(':scope > ' + tag);
    return child ? child.textContent.trim() : '';
  }

  function extractProperties(el) {
    const props = {};
    // NiFi template format: config > properties > entry > key + value
    el.querySelectorAll('config > properties > entry').forEach(entry => {
      const key = entry.querySelector(':scope > key')?.textContent || '';
      const valEl = entry.querySelector(':scope > value');
      if (key && valEl) props[key] = valEl.textContent || '';
    });
    // Also try direct properties > entry (for controllerServices at snippet level)
    if (!Object.keys(props).length) {
      el.querySelectorAll(':scope > properties > entry').forEach(entry => {
        const key = entry.querySelector(':scope > key')?.textContent || '';
        const valEl = entry.querySelector(':scope > value');
        if (key && valEl) props[key] = valEl.textContent || '';
      });
    }
    return props;
  }

  // Start from snippet (template format), flowController (NiFi registry), or root
  const snippet = doc.querySelector('template > snippet') || doc.querySelector('snippet') ||
    doc.querySelector('flowController > rootGroup') || doc.querySelector('rootGroup') ||
    doc.querySelector('processGroupFlow > flow') || doc.documentElement;

  // Top-level controllerServices
  snippet.querySelectorAll(':scope > controllerServices').forEach(cs => {
    const name = getChildText(cs, 'name');
    const type = getChildText(cs, 'type');
    const state = getChildText(cs, 'state');
    const props = {};
    cs.querySelectorAll(':scope > properties > entry').forEach(entry => {
      const key = entry.querySelector(':scope > key')?.textContent || '';
      const valEl = entry.querySelector(':scope > value');
      if (key && valEl) props[key] = valEl.textContent || '';
    });
    controllerServices.push({name, type:type.split('.').pop(), fullType:type, state, properties:props});
  });

  // Top-level processGroups
  snippet.querySelectorAll(':scope > processGroups').forEach(pg => {
    const pgName = getChildText(pg, 'name');
    const pgId = getChildText(pg, 'id');
    if(pgId) idToName[pgId] = pgName;
    processGroups.push({name:pgName, parentGroup:'(root)'});
    extractFromGroup(pg, pgName);
  });

  // Also check for top-level processors directly in snippet
  snippet.querySelectorAll(':scope > processors').forEach(proc => {
    const name = getChildText(proc, 'name');
    const type = getChildText(proc, 'type');
    const id = getChildText(proc, 'id');
    if(id) idToName[id] = name || type.split('.').pop();
    const props = extractProperties(proc);
    processors.push({name, type:type.split('.').pop(), fullType:type, state:getChildText(proc,'state'), properties:props, group:'(root)', schedulingPeriod:'', schedulingStrategy:''});
  });

  // Resolve connection IDs to processor names
  connections.forEach(c => {
    c.sourceName = idToName[c.sourceId] || c.sourceId.substring(0,12)+'...';
    c.destinationName = idToName[c.destinationId] || c.destinationId.substring(0,12)+'...';
  });

  // Extract SQL and table refs from processor properties
  const sqlTables = new Set();
  processors.forEach(p => {
    Object.values(p.properties).forEach(v => {
      if (!v) return;
      // Try to find CREATE TABLE
      if (/CREATE\s+(?:EXTERNAL\s+)?TABLE/i.test(v)) {
        try { const r = parseDDL(v, p.name); tables.push(...r.tables); } catch(e) {}
      }
      // Extract table name refs from SQL
      const tblRefs = v.match(/(?:FROM|JOIN|INTO|TABLE|UPDATE)\s+(?:\$\{[^}]+\}|[\w.]+)/gi);
      if (tblRefs) tblRefs.forEach(m => {
        const tn = m.replace(/^(FROM|JOIN|INTO|TABLE|UPDATE)\s+/i,'').trim();
        if (tn && !tn.startsWith('(') && tn.length > 2 && !/^(select|where|set|and|or|as|on)$/i.test(tn)) sqlTables.add(tn);
      });
    });
    // Extract table names from specific NiFi properties
    ['Table Name','table-name','put-db-record-table-name'].forEach(k => {
      if (p.properties[k]) sqlTables.add(p.properties[k]);
    });
  });

  // Build NiFi flow inventory tables (always — this IS the synthetic env for a NiFi flow)
  const procTypes = processors.map(p=>p.type).filter((v,i,a)=>a.indexOf(v)===i);
  const procGroups = processors.map(p=>p.group).filter((v,i,a)=>a.indexOf(v)===i);
  const procStates = processors.map(p=>p.state).filter(Boolean).filter((v,i,a)=>a.indexOf(v)===i);

  tables.push({name:'nifi_processors', schema:'nifi_flow', row_count:processors.length, columns:[
    {name:'processor_name',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
    {name:'processor_type',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:procTypes.slice(0,50),max_length:200,precision:null,scale:null,default_value:null},
    {name:'process_group',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:procGroups,max_length:200,precision:null,scale:null,default_value:null},
    {name:'state',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:procStates,max_length:20,precision:null,scale:null,default_value:null},
    {name:'scheduling_strategy',data_type:'varchar',raw_type:'string',nullable:true,is_primary_key:false,is_unique:false,check_constraints:['TIMER_DRIVEN','CRON_DRIVEN','EVENT_DRIVEN'],max_length:30,precision:null,scale:null,default_value:null},
    {name:'scheduling_period',data_type:'varchar',raw_type:'string',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:50,precision:null,scale:null,default_value:null},
    {name:'property_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}
  ], foreign_keys:[]});

  if (connections.length) {
    const relTypes = connections.flatMap(c=>c.relationships).filter((v,i,a)=>a.indexOf(v)===i);
    tables.push({name:'nifi_connections', schema:'nifi_flow', row_count:connections.length, columns:[
      {name:'connection_id',data_type:'int',raw_type:'int',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null},
      {name:'source_processor',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'destination_processor',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'relationship',data_type:'varchar',raw_type:'string',nullable:true,is_primary_key:false,is_unique:false,check_constraints:relTypes.slice(0,20),max_length:100,precision:null,scale:null,default_value:null},
      {name:'back_pressure_threshold',data_type:'int',raw_type:'int',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}
    ], foreign_keys:[{fk_column:'source_processor',referenced_table:'nifi_processors',referenced_column:'processor_name'}]});
  }

  if (processGroups.length) {
    tables.push({name:'nifi_process_groups', schema:'nifi_flow', row_count:processGroups.length, columns:[
      {name:'group_name',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'parent_group',data_type:'varchar',raw_type:'string',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'processor_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null},
      {name:'connection_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}
    ], foreign_keys:[]});
  }

  if (controllerServices.length) {
    tables.push({name:'nifi_controller_services', schema:'nifi_flow', row_count:controllerServices.length, columns:[
      {name:'service_name',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'service_type',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:controllerServices.map(s=>s.type).filter((v,i,a)=>a.indexOf(v)===i),max_length:200,precision:null,scale:null,default_value:null},
      {name:'state',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:['ENABLED','DISABLED','ENABLING','DISABLING'],max_length:20,precision:null,scale:null,default_value:null},
      {name:'config_json',data_type:'text',raw_type:'text',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}
    ], foreign_keys:[]});
  }

  // If SQL references found, add a reference table
  if (sqlTables.size) {
    const refs = [...sqlTables];
    tables.push({name:'nifi_sql_table_refs', schema:'nifi_flow', row_count:refs.length, columns:[
      {name:'table_reference',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'reference_type',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:['table','variable','external_table'],max_length:50,precision:null,scale:null,default_value:null},
      {name:'referenced_by_processor',data_type:'varchar',raw_type:'string',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null}
    ], foreign_keys:[]});
  }

  const warnings = [];
  if (sqlTables.size) warnings.push(`Found ${sqlTables.size} SQL table references: ${[...sqlTables].slice(0,10).join(', ')}${sqlTables.size>10?'...':''}`);

  const result = {source_name:sourceName||'Apache NiFi Flow', source_type:'nifi', tables, input_format:'nifi_xml', parse_warnings:warnings};
  result._nifi = {processors, connections, controllerServices, processGroups, sqlTables:[...sqlTables]};
  return result;
}

// ================================================================
// SOURCE SYSTEM DETECTION
// ================================================================
function detectSourceSystem(content, fmt) {
  if (fmt==='informatica_xml') return {name:'Informatica',type:'ETL & Integration',color:'#FF4A00'};
  if (fmt==='talend_xml') return {name:'Talend',type:'Data Integration',color:'#FF6D70'};
  if (fmt==='nifi_xml') return {name:'Apache NiFi',type:'Flow Definition',color:'#728E9B'};
  if (fmt==='pyspark') return {name:'PySpark / Databricks',type:'Spark Schema',color:'#E25A1C'};
  if (fmt==='scala') return {name:'Scala / Spark',type:'Case Classes',color:'#DC382D'};
  if (fmt==='dbt') return {name:'dbt',type:'Data Transformation',color:'#FF694B'};
  if (fmt==='avro') return {name:'Apache Avro',type:'Schema Registry',color:'#3ECF8E'};
  if (fmt==='protobuf') return {name:'Protobuf',type:'Schema Definition',color:'#3ECF8E'};
  if (fmt==='spark_schema') return {name:'Spark',type:'printSchema Output',color:'#E25A1C'};
  if (fmt==='yaml') return {name:'YAML Schema',type:'Universal',color:'#CB171E'};
  if (fmt==='json') return {name:'JSON Schema',type:'Universal',color:'#000000'};
  if (fmt==='csv') return {name:'CSV Mapping',type:'Universal',color:'#217346'};
  if (fmt==='xml') return {name:'XML Schema',type:'Universal',color:'#0060AC'};
  const c = content || '';
  if (/\bVARCHAR2\b|\bNUMBER\s*\(|\bCLOB\b|\bBINARY_FLOAT\b/i.test(c)) return {name:'Oracle',type:'Database',color:'#F80000'};
  if (/\[\w+\]|\bIDENTITY\s*\(|\bDATETIME2\b|\bUNIQUEIDENTIFIER\b|\bNVARCHAR\b/i.test(c)) return {name:'SQL Server',type:'Microsoft SQL',color:'#CC2927'};
  if (/\bDISTKEY\b|\bSORTKEY\b|\bENCODE\s+(lzo|zstd|raw|bytedict)\b/i.test(c)) return {name:'AWS Redshift',type:'Data Warehouse',color:'#FF9900'};
  if (/\bVARIANT\b|\bCLUSTER\s+BY\b|\bTRANSIENT\s+TABLE\b/i.test(c)) return {name:'Snowflake',type:'Data Cloud',color:'#29B5E8'};
  if (/\bMULTISET\b|\bBYTEINT\b|\bTITLE\s+'/i.test(c)) return {name:'Teradata',type:'Enterprise DW',color:'#F37440'};
  if (/\bCOLUMN\s+TABLE\b|\bCS_STRING\b|\bALPHANUM\b/i.test(c)) return {name:'SAP HANA',type:'ERP / BW',color:'#0FAAFF'};
  if (/\bINT64\b|\bFLOAT64\b|\bSTRUCT\s*</i.test(c)) return {name:'Google BigQuery',type:'Cloud Platform',color:'#4285F4'};
  if (/\bUSING\s+DELTA\b|\bTBLPROPERTIES\b|\bLOCATION\s+'/i.test(c)) return {name:'Databricks',type:'Unity Catalog',color:'#FF3621'};
  if (/\bDISTRIBUTION\s*=\s*(HASH|ROUND_ROBIN|REPLICATE)\b/i.test(c)) return {name:'Azure Synapse',type:'Analytics',color:'#0078D4'};
  if (/\bSERIAL\b|\bBYTEA\b|\bJSONB\b|\bINET\b|\bTSVECTOR\b/i.test(c)) return {name:'PostgreSQL',type:'Database',color:'#4169E1'};
  if (/\bAUTO_INCREMENT\b|\bENGINE\s*=\s*(InnoDB|MyISAM)/i.test(c)) return {name:'MySQL',type:'Database',color:'#4479A1'};
  if (/\bSTORED\s+AS\s+(ORC|PARQUET|TEXTFILE)\b|\bROW\s+FORMAT\b/i.test(c)) return {name:'Apache Hive',type:'Data Warehouse',color:'#FDEE21'};
  return {name:'SQL',type:'Standard DDL',color:'#808495'};
}

// ================================================================
// DEFAULT STATS
// ================================================================
function genStats(col, rowCount) {
  const dt = col.data_type.toLowerCase();
  const s = {null_ratio: col.nullable ? 0.05 : 0.0};
  if (col.check_constraints && col.check_constraints.length) {
    const n = col.check_constraints.length;
    s.top_values = col.check_constraints.map(v=>({value:v, frequency:Math.round(1/n*10000)/10000}));
    s.distinct_count = n; return s;
  }
  if (['int','integer','smallint','tinyint'].includes(dt)) {
    if (col.is_primary_key) Object.assign(s, {min:1,max:rowCount,mean:rowCount/2,stddev:rowCount/6,distinct_count:rowCount});
    else Object.assign(s, {min:1,max:1000,mean:500,stddev:300,distinct_count:Math.min(500,rowCount)});
  } else if (['bigint','long'].includes(dt)) Object.assign(s, {min:1,max:100000,mean:50000,stddev:30000,distinct_count:Math.min(10000,rowCount)});
  else if (['float','double'].includes(dt)) Object.assign(s, {min:0,max:10000,mean:100,stddev:50,distinct_count:rowCount});
  else if (['decimal','numeric'].includes(dt)) { const mx = Math.pow(10,(col.precision||10)-(col.scale||2))-1; Object.assign(s, {min:0,max:mx,mean:mx/10,stddev:mx/20,distinct_count:rowCount}); }
  else if (['varchar','char','text','string'].includes(dt)) Object.assign(s, {min_length:3,max_length:Math.min(col.max_length||50,100),distinct_count:rowCount});
  else if (dt==='date') Object.assign(s, {min:'2020-01-01',max:'2025-12-31',distinct_count:Math.min(rowCount,2000)});
  else if (['timestamp','datetime'].includes(dt)) Object.assign(s, {min:'2020-01-01',max:'2025-12-31',distinct_count:rowCount});
  else if (['boolean','bool'].includes(dt)) { s.top_values=[{value:true,frequency:0.5},{value:false,frequency:0.5}]; s.distinct_count=2; }
  else Object.assign(s, {min_length:5,max_length:20,distinct_count:rowCount});
  return s;
}

// ================================================================
// BLUEPRINT ASSEMBLER
// ================================================================
function assembleBlueprint_fn(parsed, rowCount) {
  const bid = crypto.randomUUID ? crypto.randomUUID() : 'bp-'+Math.random().toString(36).substring(2,10);
  const tables = parsed.tables.map(pt => {
    const cols = pt.columns.map(c => ({name:c.name, data_type:c.data_type, nullable:c.nullable, is_primary_key:c.is_primary_key, stats:genStats(c, rowCount)}));
    const fks = pt.foreign_keys.map(fk => ({column:fk.fk_column, references_table:fk.referenced_table, references_column:fk.referenced_column}));
    return {name:pt.name, schema:pt.schema, row_count:rowCount, columns:cols, foreign_keys:fks};
  });
  const rels = [];
  parsed.tables.forEach(pt => pt.foreign_keys.forEach(fk => rels.push({from_table:`${pt.schema}.${pt.name}`,to_table:`${pt.schema}.${fk.referenced_table}`,relationship_type:'one_to_many',join_columns:[{from_column:fk.fk_column,to_column:fk.referenced_column}]})));
  return {blueprint_id:bid, source_system:{name:parsed.source_name,type:parsed.source_type}, tables, relationships:rels};
}

// ================================================================
// TIER DIAGRAM — Adaptive Environment Visualization
// ================================================================
const NIFI_ROLE_MAP = {
  // Sources (Tier 1)
  GetFile:'source',GetHTTP:'source',GetSFTP:'source',GetFTP:'source',ConsumeKafka:'source',
  ConsumeKafka_2_6:'source',ConsumeKafkaRecord_2_6:'source',ListenHTTP:'source',
  QueryDatabaseTable:'source',QueryDatabaseTableRecord:'source',GenerateFlowFile:'source',
  GetHDFS:'source',ListS3:'source',FetchS3Object:'source',GetS3Object:'source',
  ListFile:'source',FetchFile:'source',ConsumeJMS:'source',ListenTCP:'source',
  ListenUDP:'source',GetMongo:'source',GetElasticsearch:'source',TailFile:'source',
  // Routing (Tier 2)
  RouteOnAttribute:'route',RouteOnContent:'route',DistributeLoad:'route',ControlRate:'route',
  RouteText:'route',DetectDuplicate:'route',ValidateRecord:'route',
  // Transform (Tier 2)
  UpdateAttribute:'transform',JoltTransformJSON:'transform',ReplaceText:'transform',
  ConvertRecord:'transform',SplitRecord:'transform',MergeContent:'transform',MergeRecord:'transform',
  ExecuteScript:'transform',ExecuteStreamCommand:'transform',ConvertJSONToSQL:'transform',
  TransformXml:'transform',SplitJson:'transform',SplitXml:'transform',SplitText:'transform',
  EvaluateJsonPath:'transform',ExtractText:'transform',CompressContent:'transform',
  EncryptContent:'transform',HashContent:'transform',Base64EncodeContent:'transform',
  ConvertCharacterSet:'transform',FlattenJson:'transform',ConvertAvroToJSON:'transform',
  ConvertJSONToAvro:'transform',
  // Processing (Tier 3)
  ExecuteSQL:'process',ExecuteSQLRecord:'process',PutDatabaseRecord:'process',
  LookupAttribute:'process',LookupRecord:'process',InvokeHTTP:'process',
  ExecuteProcess:'process',HandleHttpRequest:'process',HandleHttpResponse:'process',
  // Sinks (Tier 4)
  PutFile:'sink',PutHDFS:'sink',PutS3Object:'sink',PutSQL:'sink',PutKafka:'sink',
  PutKafkaRecord:'sink',PutEmail:'sink',PutSFTP:'sink',PutFTP:'sink',PublishKafka:'sink',
  PublishKafka_2_6:'sink',PublishKafkaRecord_2_6:'sink',PutMongo:'sink',PutElasticsearch:'sink',
  PutDatabaseRecord:'sink',PutSyslog:'sink',PutTCP:'sink',
  // Utility
  LogMessage:'utility',LogAttribute:'utility',Wait:'utility',Notify:'utility',
  DebugFlow:'utility',CountText:'utility',AttributesToJSON:'utility',
};

function classifyNiFiProcessor(type) {
  return NIFI_ROLE_MAP[type] || (
    /^(Get|List|Consume|Listen|Fetch|Tail|Query)/i.test(type) ? 'source' :
    /^(Put|Publish|Send|Post)/i.test(type) ? 'sink' :
    /^(Route|Distribute|Control|Validate|Detect)/i.test(type) ? 'route' :
    /^(Convert|Split|Merge|Replace|Transform|Extract|Evaluate|Flatten|Compress|Encrypt|Hash)/i.test(type) ? 'transform' :
    /^(Execute|Invoke|Lookup|Handle)/i.test(type) ? 'process' :
    /^(Log|Debug|Count|Wait|Notify)/i.test(type) ? 'utility' :
    'process'
  );
}

function buildTierData(blueprint, parsed) {
  const fmt = parsed ? parsed.input_format : '';
  if (fmt === 'nifi_xml' && parsed._nifi) return buildNiFiTierData(parsed._nifi, blueprint);
  if (blueprint.relationships && blueprint.relationships.length > 0) return buildSQLTierData(blueprint);
  return buildFlatTierData(blueprint);
}

function buildNiFiTierData(nifi, blueprint) {
  const nodes = [], connections = [];
  const tierLabels = {
    1: {label:'INGESTION — Source Processors', color:'#3B82F6', bg:'rgba(59,130,246,0.06)'},
    2: {label:'ROUTING & TRANSFORMATION', color:'#EAB308', bg:'rgba(234,179,8,0.06)'},
    3: {label:'PROCESSING', color:'#A855F7', bg:'rgba(168,85,247,0.06)'},
    4: {label:'OUTPUT — Sink Processors', color:'#21C354', bg:'rgba(33,195,84,0.06)'},
    5: {label:'UTILITY', color:'#808495', bg:'rgba(128,132,149,0.06)'},
  };
  const roleTier = {source:1, route:2, transform:2, process:3, sink:4, utility:5};
  // Build nodes from processors
  nifi.processors.forEach(p => {
    const role = classifyNiFiProcessor(p.type);
    nodes.push({
      id: p.name + '_' + p.type,
      name: p.name || p.type,
      tier: roleTier[role] || 3,
      type: 'processor',
      subtype: role,
      meta: p.type,
      group: p.group,
      state: p.state,
      propCount: Object.keys(p.properties).length,
      detail: p
    });
  });
  // Build connections
  nifi.connections.forEach((c, i) => {
    const srcNode = nodes.find(n => n.name === c.sourceName || n.id.startsWith(c.sourceName));
    const dstNode = nodes.find(n => n.name === c.destinationName || n.id.startsWith(c.destinationName));
    if (srcNode && dstNode) {
      connections.push({
        from: srcNode.id, to: dstNode.id,
        label: c.relationships.join(', '),
        type: 'flow', color: '#4B5563', width: 1.5
      });
    }
  });
  // Remove utility tier if empty
  if (!nodes.some(n => n.tier === 5)) delete tierLabels[5];
  return {nodes, connections, tierLabels, diagramType: 'nifi_flow'};
}

function buildSQLTierData(blueprint) {
  const nodes = [], connections = [];
  const tierLabels = {};
  // Compute dependency depth via topological sort
  const depthMap = {};
  const tableNames = blueprint.tables.map(t => t.name);
  const fkTargets = {};
  blueprint.tables.forEach(t => {
    t.foreign_keys.forEach(fk => {
      const ref = fk.references_table;
      if (!fkTargets[t.name]) fkTargets[t.name] = [];
      fkTargets[t.name].push(ref);
    });
  });
  function getDepth(tn, visited) {
    if (depthMap[tn] !== undefined) return depthMap[tn];
    if (visited.has(tn)) return 0; // cycle
    visited.add(tn);
    const deps = fkTargets[tn] || [];
    if (!deps.length) { depthMap[tn] = 0; return 0; }
    const maxDep = Math.max(...deps.map(d => getDepth(d, new Set(visited))));
    depthMap[tn] = maxDep + 1;
    return depthMap[tn];
  }
  tableNames.forEach(tn => getDepth(tn, new Set()));
  const maxDepth = Math.max(0, ...Object.values(depthMap));
  // Build tier labels
  for (let d = 0; d <= maxDepth; d++) {
    if (d === 0) tierLabels[1] = {label:'INDEPENDENT TABLES', color:'#3B82F6', bg:'rgba(59,130,246,0.06)'};
    else tierLabels[d+1] = {label:`DEPENDENCY LEVEL ${d}`, color: d===1?'#EAB308':d===2?'#A855F7':'#21C354', bg: d===1?'rgba(234,179,8,0.06)':d===2?'rgba(168,85,247,0.06)':'rgba(33,195,84,0.06)'};
  }
  // Build nodes
  blueprint.tables.forEach(t => {
    const depth = depthMap[t.name] || 0;
    const pkCols = t.columns.filter(c => c.is_primary_key);
    nodes.push({
      id: t.name,
      name: t.name,
      tier: depth + 1,
      type: 'table',
      meta: `${t.columns.length} cols${pkCols.length?' · PK: '+pkCols.map(c=>c.name).join(','):''}`,
      rows: t.row_count,
      fkCount: t.foreign_keys.length,
      detail: t
    });
  });
  // Build connections from relationships
  blueprint.relationships.forEach(r => {
    const fromName = r.from_table.split('.').pop();
    const toName = r.to_table.split('.').pop();
    const colLabel = r.join_columns.map(j => `${j.from_column}→${j.to_column}`).join(', ');
    connections.push({
      from: fromName, to: toName,
      label: colLabel,
      type: 'foreign_key', color: '#3B82F6', width: 2
    });
  });
  return {nodes, connections, tierLabels, diagramType: 'sql_tables'};
}

function buildFlatTierData(blueprint) {
  const nodes = [], connections = [];
  const tierLabels = {1:{label:'SCHEMA OBJECTS',color:'#3B82F6',bg:'rgba(59,130,246,0.06)'}};
  blueprint.tables.forEach(t => {
    nodes.push({
      id: t.name, name: t.name, tier: 1, type: 'table',
      meta: `${t.columns.length} cols`,
      rows: t.row_count, detail: t
    });
  });
  // Look for implicit connections: shared column names between tables
  const colToTables = {};
  blueprint.tables.forEach(t => {
    t.columns.forEach(c => {
      const cn = c.name.toLowerCase();
      if (!colToTables[cn]) colToTables[cn] = [];
      colToTables[cn].push(t.name);
    });
  });
  Object.entries(colToTables).forEach(([cn, tbls]) => {
    if (tbls.length === 2 && (cn.endsWith('_id') || cn === 'id')) {
      connections.push({from:tbls[0], to:tbls[1], label:cn, type:'implicit', color:'#4B5563', width:1, dash:true});
    }
  });
  return {nodes, connections, tierLabels, diagramType: 'flat'};
}

// ================================================================
// TIER DIAGRAM — SVG Rendering Engine
// ================================================================
function renderTierDiagram(tierData, containerId, detailId, legendId) {
  const container = document.getElementById(containerId);
  const detailEl = document.getElementById(detailId);
  const legendEl = document.getElementById(legendId);
  if (!container) return;
  container.innerHTML = '';
  container.style.minHeight = '200px';

  const {nodes, connections, tierLabels, diagramType} = tierData;
  if (!nodes.length) { container.innerHTML = '<p style="text-align:center;padding:20px;color:var(--text2)">No nodes to display</p>'; return; }

  // Group nodes by tier
  const tierGroups = {};
  nodes.forEach(n => {
    if (!tierGroups[n.tier]) tierGroups[n.tier] = [];
    tierGroups[n.tier].push(n);
  });

  // Render tier bands
  const sortedTiers = Object.keys(tierGroups).map(Number).sort((a,b)=>a-b);
  const nodeEls = {};

  sortedTiers.forEach(tier => {
    const config = tierLabels[tier] || {label:`TIER ${tier}`, color:'#808495', bg:'rgba(128,132,149,0.06)'};
    const band = document.createElement('div');
    band.className = 'tier-band';
    band.style.background = config.bg;
    band.style.borderLeft = `3px solid ${config.color}`;

    const label = document.createElement('div');
    label.className = 'tier-band-label';
    label.style.color = config.color;
    label.textContent = config.label;
    band.appendChild(label);

    const nodesDiv = document.createElement('div');
    nodesDiv.className = 'tier-nodes';

    tierGroups[tier].forEach(node => {
      const el = document.createElement('div');
      el.className = 'tier-node';
      el.dataset.nodeId = node.id;
      if (node.state === 'DISABLED' || node.state === 'STOPPED') el.style.opacity = '0.5';
      // Color code by type
      if (node.subtype === 'source') el.style.borderTopColor = '#3B82F6';
      else if (node.subtype === 'sink') el.style.borderTopColor = '#21C354';
      else if (node.subtype === 'route') el.style.borderTopColor = '#EAB308';
      else if (node.subtype === 'transform') el.style.borderTopColor = '#A855F7';
      else if (node.type === 'table') el.style.borderTopColor = '#3B82F6';
      el.style.borderTopWidth = '3px';

      const nameEl = document.createElement('div');
      nameEl.className = 'node-name';
      nameEl.textContent = node.name.length > 25 ? node.name.substring(0,22) + '...' : node.name;
      nameEl.title = node.name;
      el.appendChild(nameEl);

      if (node.meta) {
        const metaEl = document.createElement('div');
        metaEl.className = 'node-meta';
        metaEl.textContent = node.meta;
        el.appendChild(metaEl);
      }
      if (node.rows) {
        const badge = document.createElement('div');
        badge.className = 'node-badge';
        badge.textContent = node.rows >= 1000 ? Math.round(node.rows/1000)+'K' : node.rows;
        el.appendChild(badge);
      }

      // Hover: highlight connected
      el.addEventListener('mouseenter', () => highlightConnected(node.id, nodes, connections, nodeEls, container));
      el.addEventListener('mouseleave', () => clearHighlight(nodeEls, container));
      // Click: show detail
      el.addEventListener('click', () => showNodeDetail(node, detailEl, diagramType));

      nodesDiv.appendChild(el);
      nodeEls[node.id] = el;
    });

    band.appendChild(nodesDiv);
    container.appendChild(band);
  });

  // Render SVG connections after DOM is laid out
  requestAnimationFrame(() => {
    renderConnections(container, connections, nodeEls);
  });

  // Legend
  if (legendEl) {
    legendEl.innerHTML = '';
    if (diagramType === 'nifi_flow') {
      legendEl.innerHTML = [
        '<span><span class="leg-line" style="background:#3B82F6"></span> Source</span>',
        '<span><span class="leg-line" style="background:#EAB308"></span> Route/Transform</span>',
        '<span><span class="leg-line" style="background:#A855F7"></span> Process</span>',
        '<span><span class="leg-line" style="background:#21C354"></span> Sink</span>',
        '<span><span class="leg-line" style="background:#4B5563;border-top:2px solid #4B5563"></span> Flow Connection</span>',
      ].join('');
    } else if (diagramType === 'sql_tables') {
      legendEl.innerHTML = [
        '<span><span class="leg-line" style="background:#3B82F6;border-top:2px solid #3B82F6"></span> Foreign Key</span>',
        `<span>${nodes.length} tables · ${connections.length} relationships</span>`,
      ].join('');
    } else {
      legendEl.innerHTML = [
        `<span>${nodes.length} objects</span>`,
        connections.length ? `<span><span class="leg-line" style="background:#4B5563;border-top:2px dashed #4B5563"></span> Shared columns</span>` : '',
      ].join('');
    }
  }

  document.getElementById('tierDiagramContainer').classList.remove('hidden');
}

function renderConnections(container, connections, nodeEls) {
  // Remove old SVG
  const oldSvg = container.querySelector('svg.tier-svg');
  if (oldSvg) oldSvg.remove();

  if (!connections.length) return;

  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.classList.add('tier-svg');
  svg.style.position = 'absolute';
  svg.style.top = '0';
  svg.style.left = '0';
  svg.style.width = container.scrollWidth + 'px';
  svg.style.height = container.scrollHeight + 'px';
  svg.style.pointerEvents = 'none';
  svg.style.zIndex = '1';
  svg.setAttribute('viewBox', `0 0 ${container.scrollWidth} ${container.scrollHeight}`);

  // Arrow marker
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
  marker.setAttribute('id','arrow');
  marker.setAttribute('viewBox','0 0 10 8');
  marker.setAttribute('refX','10');
  marker.setAttribute('refY','4');
  marker.setAttribute('markerWidth','8');
  marker.setAttribute('markerHeight','6');
  marker.setAttribute('orient','auto');
  const arrowPath = document.createElementNS('http://www.w3.org/2000/svg','path');
  arrowPath.setAttribute('d','M0,0 L10,4 L0,8 Z');
  arrowPath.setAttribute('fill','#4B5563');
  marker.appendChild(arrowPath);
  defs.appendChild(marker);
  svg.appendChild(defs);

  const cRect = container.getBoundingClientRect();

  connections.forEach(conn => {
    const fromEl = nodeEls[conn.from];
    const toEl = nodeEls[conn.to];
    if (!fromEl || !toEl) return;

    const fromRect = fromEl.getBoundingClientRect();
    const toRect = toEl.getBoundingClientRect();

    const fromX = fromRect.left + fromRect.width/2 - cRect.left + container.scrollLeft;
    const fromY = fromRect.top + fromRect.height - cRect.top + container.scrollTop;
    const toX = toRect.left + toRect.width/2 - cRect.left + container.scrollLeft;
    const toY = toRect.top - cRect.top + container.scrollTop;

    const dy = toY - fromY;
    const cp = Math.max(Math.abs(dy) * 0.35, 30);
    const cpx = (toX - fromX) * 0.15;

    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('d', `M${fromX},${fromY} C${fromX+cpx},${fromY+cp} ${toX-cpx},${toY-cp} ${toX},${toY}`);
    path.setAttribute('stroke', conn.color || '#4B5563');
    path.setAttribute('stroke-width', conn.width || 1.5);
    path.setAttribute('fill', 'none');
    path.setAttribute('marker-end', 'url(#arrow)');
    path.setAttribute('opacity', '0.6');
    if (conn.dash) path.setAttribute('stroke-dasharray', '6,4');
    path.dataset.from = conn.from;
    path.dataset.to = conn.to;
    svg.appendChild(path);
  });

  container.style.position = 'relative';
  container.insertBefore(svg, container.firstChild);
}

function highlightConnected(nodeId, nodes, connections, nodeEls, container) {
  const connected = new Set([nodeId]);
  connections.forEach(c => {
    if (c.from === nodeId) connected.add(c.to);
    if (c.to === nodeId) connected.add(c.from);
  });
  Object.entries(nodeEls).forEach(([id, el]) => {
    if (connected.has(id)) { el.classList.add('highlighted'); el.classList.remove('dimmed'); }
    else { el.classList.add('dimmed'); el.classList.remove('highlighted'); }
  });
  // Highlight SVG paths
  const svg = container.querySelector('svg.tier-svg');
  if (svg) {
    svg.querySelectorAll('path[data-from]').forEach(p => {
      if (p.dataset.from === nodeId || p.dataset.to === nodeId) {
        p.setAttribute('opacity','1'); p.setAttribute('stroke-width', String(parseFloat(p.getAttribute('stroke-width'))+1));
      } else { p.setAttribute('opacity','0.15'); }
    });
  }
}

function clearHighlight(nodeEls, container) {
  Object.values(nodeEls).forEach(el => { el.classList.remove('highlighted','dimmed'); });
  const svg = container.querySelector('svg.tier-svg');
  if (svg) {
    svg.querySelectorAll('path[data-from]').forEach(p => {
      p.setAttribute('opacity','0.6');
      // Reset width
      const w = parseFloat(p.getAttribute('stroke-width'));
      if (w > 2) p.setAttribute('stroke-width', String(w-1));
    });
  }
}

function showNodeDetail(node, detailEl, diagramType) {
  if (!detailEl) return;
  let h = '<div class="node-detail">';
  h += `<h4>${node.name}</h4>`;
  if (diagramType === 'nifi_flow' && node.detail) {
    const p = node.detail;
    h += `<p><strong>Type:</strong> ${p.type} <code style="font-size:0.7rem">${p.fullType||''}</code></p>`;
    h += `<p><strong>Group:</strong> ${p.group || '(root)'}</p>`;
    h += `<p><strong>State:</strong> ${p.state || 'N/A'}</p>`;
    if (p.schedulingStrategy) h += `<p><strong>Scheduling:</strong> ${p.schedulingStrategy} / ${p.schedulingPeriod}</p>`;
    const propKeys = Object.keys(p.properties);
    if (propKeys.length) {
      h += `<p><strong>Properties (${propKeys.length}):</strong></p><pre style="max-height:200px;overflow:auto;font-size:0.75rem">`;
      propKeys.slice(0,20).forEach(k => { h += `${k}: ${(p.properties[k]||'').substring(0,100)}\n`; });
      if (propKeys.length > 20) h += `... +${propKeys.length-20} more\n`;
      h += '</pre>';
    }
  } else if (node.detail && node.detail.columns) {
    const t = node.detail;
    h += `<p><strong>Schema:</strong> ${t.schema || 'dbo'} · <strong>Rows:</strong> ${t.row_count}</p>`;
    h += '<table style="font-size:0.75rem"><thead><tr><th>Column</th><th>Type</th><th>PK</th><th>Null</th></tr></thead><tbody>';
    t.columns.slice(0,15).forEach(c => {
      h += `<tr><td>${c.name}</td><td>${c.data_type}</td><td>${c.is_primary_key?'Y':''}</td><td>${c.nullable?'Y':'N'}</td></tr>`;
    });
    if (t.columns.length > 15) h += `<tr><td colspan="4" style="color:var(--text2)">+${t.columns.length-15} more columns</td></tr>`;
    h += '</tbody></table>';
    if (t.foreign_keys.length) {
      h += '<p style="margin-top:8px"><strong>Foreign Keys:</strong></p>';
      t.foreign_keys.forEach(fk => { h += `<p style="font-size:0.8rem"><code>${fk.column||fk.fk_column}</code> → <code>${fk.references_table}(${fk.references_column})</code></p>`; });
    }
  }
  h += '</div>';
  detailEl.innerHTML = h;
}

// ================================================================
// DATA GENERATOR (Box-Muller + seeded RNG)
// ================================================================
class SeededRNG {
  constructor(seed) { this.s = seed; }
  next() { this.s = (this.s * 16807 + 0) % 2147483647; return (this.s - 1) / 2147483646; }
  nextInt(min, max) { return Math.floor(this.next() * (max - min + 1)) + min; }
  normal(mean, std) {
    const u1 = this.next(), u2 = this.next();
    const z = Math.sqrt(-2*Math.log(u1||0.0001)) * Math.cos(2*Math.PI*u2);
    return mean + z * std;
  }
  choice(arr) { return arr[Math.floor(this.next()*arr.length)]; }
  shuffle(arr) { for (let i=arr.length-1;i>0;i--) { const j=Math.floor(this.next()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
  string(len) { const ch='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; return Array.from({length:len},()=>ch[Math.floor(this.next()*ch.length)]).join(''); }
}

function sampleColumn(rng, colSpec, rowCount) {
  const stats = colSpec.stats || {};
  const dt = (colSpec.data_type||'string').toLowerCase();
  const nr = stats.null_ratio || 0;
  const nn = Math.round(rowCount * (1-nr)), nc = rowCount - nn;
  let vals;
  if (['int','bigint','smallint','tinyint','integer','long'].includes(dt)) vals = sampleInt(rng, stats, nn);
  else if (['float','double','decimal','numeric'].includes(dt)) vals = sampleFloat(rng, stats, nn);
  else if (['string','varchar','char','text'].includes(dt)) vals = sampleStr(rng, stats, nn);
  else if (dt==='date') vals = sampleDate(rng, stats, nn);
  else if (['timestamp','datetime'].includes(dt)) vals = sampleTS(rng, stats, nn);
  else if (['boolean','bool'].includes(dt)) vals = sampleBool(rng, stats, nn);
  else vals = sampleStr(rng, stats, nn);
  const result = [...vals, ...Array(nc).fill(null)];
  return rng.shuffle(result);
}

function sampleInt(rng, s, n) {
  if (s.top_values && s.distinct_count <= 100) return sampleFreq(rng, s.top_values, n);
  const mn=s.min||0, mx=s.max||1000, mean=s.mean, std=s.stddev;
  if (mean!=null && std!=null && std>0) return Array.from({length:n},()=>Math.max(mn,Math.min(mx,Math.round(rng.normal(mean,std)))));
  return Array.from({length:n},()=>rng.nextInt(mn, mx));
}
function sampleFloat(rng, s, n) {
  const mean=s.mean||0, std=s.stddev||1, mn=s.min||-1e9, mx=s.max||1e9;
  return Array.from({length:n},()=>Math.round(Math.max(mn,Math.min(mx,rng.normal(mean,std)))*100)/100);
}
function sampleStr(rng, s, n) {
  if (s.top_values) return sampleFreq(rng, s.top_values, n);
  const mnl=s.min_length||5, mxl=s.max_length||20;
  return Array.from({length:n},()=>rng.string(rng.nextInt(mnl,mxl)));
}
function sampleDate(rng, s, n) {
  const mn=new Date(s.min||'2020-01-01').getTime(), mx=new Date(s.max||'2025-12-31').getTime();
  const range = mx-mn || 86400000*365;
  return Array.from({length:n},()=>new Date(mn+rng.next()*range).toISOString().split('T')[0]);
}
function sampleTS(rng, s, n) {
  return sampleDate(rng,s,n).map(d=>`${d}T${String(rng.nextInt(0,23)).padStart(2,'0')}:${String(rng.nextInt(0,59)).padStart(2,'0')}:${String(rng.nextInt(0,59)).padStart(2,'0')}`);
}
function sampleBool(rng, s, n) {
  let tr=0.5;
  (s.top_values||[]).forEach(t=>{if(String(t.value).toLowerCase()==='true')tr=t.frequency;});
  return Array.from({length:n},()=>rng.next()<tr);
}
function sampleFreq(rng, tv, n) {
  const vals=tv.map(t=>t.value), freqs=tv.map(t=>t.frequency||1/tv.length);
  const sum=freqs.reduce((a,b)=>a+b,0);
  const cum=freqs.reduce((a,f)=>{a.push((a.length?a[a.length-1]:0)+f/sum);return a;},[]);
  return Array.from({length:n},()=>{const r=rng.next();const i=cum.findIndex(c=>r<=c);return vals[Math.max(0,i)];});
}

function generateTables(bp, seed) {
  const rng = new SeededRNG(seed);
  const tMap = {}; bp.tables.forEach(t=>tMap[t.name]=t);
  // Topological sort
  const order = [], visited = new Set();
  function visit(tn) {
    if (visited.has(tn)) return; visited.add(tn);
    const ts = tMap[tn]; if (!ts) return;
    ts.foreign_keys.forEach(fk => visit(fk.references_table));
    order.push(tn);
  }
  Object.keys(tMap).forEach(visit);
  const pkPools = {}, results = {};
  for (const tn of order) {
    const ts = tMap[tn]; if (!ts) continue;
    const data = {}; const rc = ts.row_count;
    ts.columns.forEach(c => { data[c.name] = sampleColumn(rng, c, rc); });
    // Apply FK values
    ts.foreign_keys.forEach(fk => {
      const pool = (pkPools[fk.references_table]||{})[fk.references_column] || [];
      if (pool.length && data[fk.column]) { data[fk.column] = data[fk.column].map(()=>rng.choice(pool)); }
    });
    // Build PK pool
    pkPools[tn] = {};
    ts.columns.filter(c=>c.is_primary_key).forEach(c => {
      pkPools[tn][c.name] = data[c.name].filter(v=>v!=null);
    });
    results[tn] = data;
  }
  return results;
}

// ================================================================
// MEDALLION
// ================================================================
function runMedallion(tables, bp) {
  const tMap = {}; bp.tables.forEach(t=>tMap[t.name]=t);
  const bronze={}, silver={}, gold={}, rules=[], results_q=[];
  let totalDropped=0, totalNulls=0;
  for (const [tn, data] of Object.entries(tables)) {
    const ts = tMap[tn]; const cols = Object.keys(data); const rc = data[cols[0]]?data[cols[0]].length:0;
    // Bronze
    bronze[tn] = {data, rowCount:rc, columns:cols};
    // Silver: remove all-null rows, dedup PKs
    const keep = Array(rc).fill(true);
    for (let i=0;i<rc;i++) { if (cols.every(c=>data[c][i]==null)) { keep[i]=false; totalDropped++; } }
    const silverData = {}; cols.forEach(c => silverData[c] = data[c].filter((_,i)=>keep[i]));
    const src = silverData[cols[0]]?silverData[cols[0]].length:0;
    silver[tn] = {data:silverData, rowCount:src, columns:cols};
    // Gold: agg
    const agg = cols.map(c => {
      const vals = silverData[c].filter(v=>v!=null);
      const nums = vals.map(Number).filter(v=>!isNaN(v));
      const row = {column:c, non_null:vals.length, nulls:src-vals.length};
      if (nums.length > src*0.5) {
        row.min = Math.round(Math.min(...nums)*100)/100;
        row.max = Math.round(Math.max(...nums)*100)/100;
        row.mean = Math.round(nums.reduce((a,b)=>a+b,0)/nums.length*100)/100;
      } else {
        const freq = {}; vals.forEach(v=>{freq[v]=(freq[v]||0)+1;});
        row.distinct = Object.keys(freq).length;
        row.top = Object.entries(freq).sort((a,b)=>b[1]-a[1]).slice(0,3).map(([v,c])=>`${v}(${c})`).join(', ');
      }
      return row;
    });
    gold[tn] = agg;
    // Quality rules
    if (ts) ts.columns.forEach(cs => {
      const cn = cs.name;
      if (!cs.nullable) {
        rules.push({name:`${tn}_${cn}_not_null`, table:tn, expression:`${cn} IS NOT NULL`});
        const nc = silverData[cn]?silverData[cn].filter(v=>v==null).length:0;
        results_q.push({rule:`${tn}_${cn}_not_null`,table:tn,column:cn,passed:nc===0,violations:nc,total:src});
      }
      if (cs.is_primary_key) {
        rules.push({name:`${tn}_${cn}_unique`, table:tn, expression:`${cn} is unique`});
        const seen=new Set(); let dups=0; (silverData[cn]||[]).forEach(v=>{if(seen.has(v))dups++;seen.add(v);});
        results_q.push({rule:`${tn}_${cn}_unique`,table:tn,column:cn,passed:dups===0,violations:dups,total:src});
      }
    });
  }
  return {bronze,silver,gold,rules,results:results_q,stats:{rows_dropped:totalDropped,nulls_cleaned:totalNulls,tables_processed:Object.keys(tables).length}};
}

// ================================================================
// VALIDATION
// ================================================================
function runValidation_fn(bp, tables, qualResults) {
  const results = [];
  for (const ts of bp.tables) {
    const tn = ts.name, data = tables[tn];
    if (!data) { results.push({table:tn,schema_score:0,fidelity_score:0,quality_score:0,pipeline_score:0,overall_score:0,recs:['Table not generated']}); continue; }
    const cols = Object.keys(data); const rc = data[cols[0]]?data[cols[0]].length:0;
    // Schema
    const expected = ts.columns.map(c=>c.name);
    const missing = expected.filter(c=>!cols.includes(c));
    const matched = expected.filter(c=>cols.includes(c)).length;
    const ss = matched / Math.max(expected.length, 1);
    // Fidelity
    const rcMatch = Math.abs(rc - ts.row_count) / Math.max(ts.row_count, 1) <= 0.05;
    const fs = (rcMatch?1:0.5)*0.2 + 0.8*1.0;
    // Quality
    let qs = 1.0;
    if (qualResults) { const v = qualResults.filter(r=>r.table===tn&&!r.passed); if (v.length) qs = Math.max(0, 1-v.length*0.1); }
    const overall = ss*0.25 + fs*0.35 + qs*0.20 + 1.0*0.20;
    const recs = []; if (missing.length) recs.push('Missing columns: '+missing.join(', '));
    results.push({table:tn, schema_score:Math.round(ss*1000)/1000, fidelity_score:Math.round(fs*1000)/1000,
      quality_score:Math.round(qs*1000)/1000, pipeline_score:1.0, overall_score:Math.round(overall*1000)/1000, recs, missing});
  }
  return results;
}

// ================================================================
// UI HELPERS
// ================================================================
function html(tag, attrs, ...children) {
  const el = document.createElement(tag);
  if (attrs) Object.entries(attrs).forEach(([k,v]) => { if (k==='className') el.className=v; else if (k==='onclick') el.onclick=v; else el.setAttribute(k,v); });
  children.forEach(c => { if (typeof c === 'string') el.innerHTML += c; else if (c) el.appendChild(c); });
  return el;
}

function metricsHTML(items) {
  return '<div class="metrics">'+items.map(([l,v,d])=>`<div class="metric"><div class="label">${l}</div><div class="value">${v}</div>${d?`<div class="delta">${d}</div>`:''}</div>`).join('')+'</div>';
}

function tableHTML(headers, rows) {
  return `<div class="table-scroll"><table><thead><tr>${headers.map(h=>`<th>${h}</th>`).join('')}</tr></thead><tbody>${rows.map(r=>`<tr>${r.map(c=>`<td>${c??''}</td>`).join('')}</tr>`).join('')}</tbody></table></div>`;
}

function expanderHTML(title, content, open=false) {
  return `<div class="expander ${open?'open':''}"><div class="expander-header" onclick="this.parentElement.classList.toggle('open')"><span>${title}</span><span class="expander-arrow">▶</span></div><div class="expander-body">${content}</div></div>`;
}

function scoreBadge(score) {
  if (score >= 0.9) return `<span class="badge badge-green">🟢 GREEN ${Math.round(score*100)}%</span>`;
  if (score >= 0.7) return `<span class="badge badge-amber">🟡 AMBER ${Math.round(score*100)}%</span>`;
  return `<span class="badge badge-red">🔴 RED ${Math.round(score*100)}%</span>`;
}

function progressHTML(score, label) {
  const cls = score>=0.9?'green':score>=0.7?'amber':'red';
  return `<div style="margin:4px 0"><div style="display:flex;justify-content:space-between;font-size:0.85rem"><span>${label}</span><span>${Math.round(score*100)}%</span></div><div class="progress-bar"><div class="progress-fill ${cls}" style="width:${Math.round(score*100)}%"></div></div></div>`;
}

function dataPreviewHTML(data, maxRows=15) {
  const cols = Object.keys(data); if (!cols.length) return '';
  const rc = data[cols[0]]?data[cols[0]].length:0;
  const rows = []; for (let i=0;i<Math.min(rc,maxRows);i++) rows.push(cols.map(c=>{ const v=data[c][i]; return v==null?'<span style="color:var(--text2)">null</span>':String(v).substring(0,40); }));
  return tableHTML(cols, rows);
}

// ================================================================
// STEP HANDLERS
// ================================================================
function parseInput() {
  const content = uploadedContent || document.getElementById('pasteInput').value.trim();
  if (!content) { alert('Upload a file or paste text first.'); return; }
  setTabStatus('parse', 'processing');
  // Use smart parse cascade
  let parsed;
  try {
    parsed = smartParse(content, uploadedName || null);
  } catch(e) { setTabStatus('parse', 'ready'); alert('Parse error: '+e.message); return; }
  if (!parsed || !parsed.tables || !parsed.tables.length) {
    setTabStatus('parse', 'ready');
    const warnings = parsed && parsed.parse_warnings ? parsed.parse_warnings.join('\n') : '';
    alert('No tables found. Check your input format.' + (warnings ? '\n\n' + warnings : ''));
    return;
  }
  STATE.parsed = parsed; STATE.blueprint = STATE.tables = STATE.medallion = STATE.validation = null;
  // Detect source system
  const fmt = parsed.detected_format || parsed.input_format || 'unknown';
  const src = detectSourceSystem(content, fmt);
  const tc = parsed.tables.reduce((a,t)=>a+t.columns.length,0);
  const tf = parsed.tables.reduce((a,t)=>a+t.foreign_keys.length,0);
  let h = '<hr class="divider">';
  h += `<div class="detected-source"><span class="dot"></span><strong>${src.name}</strong>&nbsp;—&nbsp;${src.type}<span style="margin-left:12px;color:var(--text2);font-size:0.85rem">(${fmt.replace(/_/g,' ')})</span></div>`;
  // Show parse quality info
  if (parsed.parse_attempts && parsed.parse_attempts > 1) h += `<div class="alert alert-info">Smart parser tried ${parsed.parse_attempts} format(s) before finding a match (confidence: ${Math.round((parsed.parse_confidence||0)*100)}%)</div>`;
  h += metricsHTML([['Tables',parsed.tables.length],['Columns',tc],['Foreign Keys',tf],['Source',src.name]]);
  // NiFi-specific details
  if (parsed._nifi) {
    const nf = parsed._nifi;
    h += metricsHTML([['Processors',nf.processors.length],['Connections',nf.connections.length],['Process Groups',nf.processGroups.length],['Controller Services',nf.controllerServices.length]]);
    if (nf.processGroups.length) {
      const pgRows = nf.processGroups.map(pg => {
        const pc = nf.processors.filter(p=>p.group===pg.name).length;
        return [pg.name, pg.parentGroup, pc];
      });
      h += expanderHTML(`<strong>Process Groups</strong> (${nf.processGroups.length})`, tableHTML(['Group Name','Parent','Processors'], pgRows));
    }
    if (nf.processors.length) {
      // Group by type for summary
      const byType = {}; nf.processors.forEach(p=>{ byType[p.type]=(byType[p.type]||0)+1; });
      const typeRows = Object.entries(byType).sort((a,b)=>b[1]-a[1]).map(([t,c])=>[t,c]);
      let procBody = '<h3 style="margin-top:0">By Type</h3>' + tableHTML(['Processor Type','Count'], typeRows);
      // Show first 30 processors
      const pRows = nf.processors.slice(0,30).map(p => [p.name, p.type, p.group, p.state||'', Object.keys(p.properties).length]);
      procBody += `<h3>Processors (first 30 of ${nf.processors.length})</h3>` + tableHTML(['Name','Type','Group','State','Props'], pRows);
      h += expanderHTML(`<strong>Processors</strong> (${nf.processors.length})`, procBody);
    }
    if (nf.connections.length) {
      const cRows = nf.connections.slice(0,30).map(c => [c.sourceName, c.destinationName, c.relationships.join(', ')]);
      h += expanderHTML(`<strong>Connections</strong> (${nf.connections.length})`, tableHTML(['Source','Destination','Relationships'], cRows) + (nf.connections.length>30?`<p style="color:var(--text2)">...and ${nf.connections.length-30} more</p>`:''));
    }
    if (nf.controllerServices.length) {
      const csRows = nf.controllerServices.map(s => [s.name, s.type, s.state||'', Object.keys(s.properties).length+' props']);
      h += expanderHTML(`<strong>Controller Services</strong> (${nf.controllerServices.length})`, tableHTML(['Service','Type','State','Properties'], csRows));
    }
    if (nf.sqlTables && nf.sqlTables.length) {
      const stRows = nf.sqlTables.map(t => [t, t.startsWith('$')?'variable':'table']);
      h += expanderHTML(`<strong>SQL Table References</strong> (${nf.sqlTables.length})`, tableHTML(['Table Reference','Type'], stRows));
    }
  }
  if (parsed.parse_warnings && parsed.parse_warnings.length) {
    h += '<div class="alert alert-warn">'+parsed.parse_warnings.join('<br>')+'</div>';
  }
  parsed.tables.forEach(t => {
    const rows = t.columns.map(c=>[c.name, c.data_type, c.raw_type||c.data_type, c.nullable?'Yes':'No', c.is_primary_key?'Y':'', (c.check_constraints||[]).join(', ')]);
    let body = tableHTML(['Column','Type','Raw Type','Nullable','PK','Check'], rows);
    if (t.foreign_keys.length) { body += '<p style="margin-top:8px"><strong>Foreign Keys:</strong></p>'+t.foreign_keys.map(fk=>`<p style="font-size:0.9rem">  <code>${fk.fk_column}</code> → <code>${fk.referenced_table}(${fk.referenced_column})</code></p>`).join(''); }
    h += expanderHTML(`Table: <strong>${t.name}</strong> (${t.columns.length} columns)`, body, true);
  });
  h += `<div class="alert alert-success">Parsed <strong>${parsed.tables.length} tables</strong> with <strong>${tc} columns</strong> from <strong>${src.name}</strong> — proceed to Step 2</div>`;
  document.getElementById('parseResults').innerHTML = h;
  document.getElementById('blueprintNotReady').classList.add('hidden');
  document.getElementById('blueprintReady').classList.remove('hidden');
  setTabStatus('parse', 'done');
  unlockTab('blueprint');
}

function assembleBlueprint() {
  if (!STATE.parsed) return;
  setTabStatus('blueprint', 'processing');
  const rc = parseInt(document.getElementById('rowCount').value)||1000;
  STATE.blueprint = assembleBlueprint_fn(STATE.parsed, rc);
  STATE.tables = STATE.medallion = STATE.validation = null;
  const bp = STATE.blueprint;
  let h = '<hr class="divider">';
  h += metricsHTML([['Blueprint ID',bp.blueprint_id.substring(0,8)+'...'],['Tables',bp.tables.length],['Relationships',bp.relationships.length],['Source',bp.source_system.type]]);
  if (bp.relationships.length) {
    h += '<h3>Relationships</h3>';
    bp.relationships.forEach(r => { const ft=r.from_table.split('.').pop(), tt=r.to_table.split('.').pop(), j=r.join_columns[0]; h += `<p><code>${ft}</code>.${j.from_column} → <code>${tt}</code>.${j.to_column}</p>`; });
  }
  h += '<h3>Table Specifications</h3>';
  bp.tables.forEach(t => {
    const rows = t.columns.map(c=>[c.name, c.data_type, c.is_primary_key?'Y':'', Math.round((c.stats.null_ratio||0)*100)+'%', c.stats.min??'', c.stats.max??'', c.stats.distinct_count??'']);
    h += expanderHTML(`<strong>${t.name}</strong> — ${t.row_count} rows`, tableHTML(['Column','Type','PK','Null%','Min','Max','Distinct'], rows));
  });
  h += `<div style="margin-top:16px"><button class="btn btn-secondary" onclick="downloadJSON()">Download Blueprint JSON</button></div>`;
  h += `<div class="alert alert-success">Blueprint assembled — proceed to Step 3</div>`;
  document.getElementById('blueprintResults').innerHTML = h;
  document.getElementById('generateNotReady').classList.add('hidden');
  document.getElementById('generateReady').classList.remove('hidden');
  // Render adaptive tier diagram
  try {
    const tierData = buildTierData(bp, STATE.parsed);
    if (tierData && tierData.nodes.length) {
      renderTierDiagram(tierData, 'tierDiagram', 'tierNodeDetail', 'tierDiagramLegend');
    }
  } catch(e) { console.warn('Tier diagram error:', e); }
  setTabStatus('blueprint', 'done');
  unlockTab('generate');
}

function downloadJSON() {
  if (!STATE.blueprint) return;
  const blob = new Blob([JSON.stringify(STATE.blueprint,null,2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = `blueprint_${STATE.blueprint.blueprint_id.substring(0,8)}.json`; a.click();
}

function generateData() {
  if (!STATE.blueprint) return;
  setTabStatus('generate', 'processing');
  const seed = parseInt(document.getElementById('seed').value)||42;
  STATE.tables = generateTables(STATE.blueprint, seed);
  STATE.medallion = STATE.validation = null;
  const tables = STATE.tables;
  const totalRows = Object.values(tables).reduce((a,d)=>a+(d[Object.keys(d)[0]]||[]).length,0);
  const totalCols = Object.values(tables).reduce((a,d)=>a+Object.keys(d).length,0);
  let h = '<hr class="divider">';
  h += metricsHTML([['Tables Generated',Object.keys(tables).length],['Total Rows',totalRows.toLocaleString()],['Total Columns',totalCols]]);
  for (const [name, data] of Object.entries(tables)) {
    const cols = Object.keys(data); const rc = data[cols[0]]?data[cols[0]].length:0;
    let body = '<strong>Preview</strong> (first 15 rows)' + dataPreviewHTML(data);
    // Stats
    body += '<h3 style="margin-top:16px">Column Statistics</h3>';
    const statRows = cols.map(c => {
      const vals = data[c].filter(v=>v!=null); const nums = vals.map(Number).filter(v=>!isNaN(v));
      if (nums.length > vals.length*0.5) {
        const mn = Math.min(...nums), mx = Math.max(...nums), mean = nums.reduce((a,b)=>a+b,0)/nums.length;
        return [c, vals.length, data[c].length-vals.length, Math.round(mn*100)/100, Math.round(mx*100)/100, Math.round(mean*100)/100];
      }
      const uniq = new Set(vals).size;
      return [c, vals.length, data[c].length-vals.length, '—','—', `${uniq} unique`];
    });
    body += tableHTML(['Column','Non-Null','Null','Min','Max','Mean/Distinct'], statRows);
    h += expanderHTML(`<strong>${name}</strong> — ${rc.toLocaleString()} rows, ${cols.length} columns`, body, true);
  }
  h += `<div style="margin-top:16px"><button class="btn btn-secondary" onclick="downloadCSV()">Download All (CSV ZIP)</button></div>`;
  h += `<div class="alert alert-success">Generated <strong>${totalRows.toLocaleString()} rows</strong> across <strong>${Object.keys(tables).length} tables</strong> — proceed to Step 4</div>`;
  document.getElementById('generateResults').innerHTML = h;
  document.getElementById('conformNotReady').classList.add('hidden');
  document.getElementById('conformReady').classList.remove('hidden');
  setTabStatus('generate', 'done');
  unlockTab('conform');
}

function downloadCSV() {
  if (!STATE.tables) return;
  // Simple CSV generation (no zip library needed — download individual files)
  for (const [name, data] of Object.entries(STATE.tables)) {
    const cols = Object.keys(data); const rc = data[cols[0]]?data[cols[0]].length:0;
    let csv = cols.join(',')+'\n';
    for (let i=0;i<rc;i++) csv += cols.map(c=>data[c][i]??'').join(',')+'\n';
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`${name}.csv`; a.click();
  }
}

function runConform() {
  if (!STATE.tables || !STATE.blueprint) return;
  setTabStatus('conform', 'processing');
  STATE.medallion = runMedallion(STATE.tables, STATE.blueprint);
  STATE.validation = null;
  const med = STATE.medallion;
  let h = '<hr class="divider">';
  h += metricsHTML([['Tables Processed',med.stats.tables_processed],['Rows Dropped',med.stats.rows_dropped],['Nulls Cleaned',med.stats.nulls_cleaned]]);
  h += '<h3>Medallion Layers</h3>';
  for (const tn of Object.keys(med.bronze)) {
    h += `<h3 style="margin-top:20px">Table: <code>${tn}</code></h3><div class="row">`;
    // Bronze
    h += `<div class="col-3"><h3>Bronze (Raw)</h3>`;
    h += metricsHTML([['Rows',med.bronze[tn].rowCount]]);
    h += dataPreviewHTML(med.bronze[tn].data, 8) + '</div>';
    // Silver
    const dropped = med.bronze[tn].rowCount - med.silver[tn].rowCount;
    h += `<div class="col-3"><h3>Silver (Cleaned)</h3>`;
    h += metricsHTML([['Rows', med.silver[tn].rowCount, dropped?`-${dropped}`:'']]);
    h += dataPreviewHTML(med.silver[tn].data, 8) + '</div>';
    // Gold
    h += `<div class="col-3"><h3>Gold (Aggregated)</h3>`;
    h += metricsHTML([['Columns Profiled', med.gold[tn].length]]);
    const goldRows = med.gold[tn].map(r=>[r.column, r.non_null, r.nulls, r.min??'—', r.max??'—', r.mean??r.top??'—', r.distinct??'—']);
    h += tableHTML(['Column','Non-Null','Nulls','Min','Max','Mean/Top','Distinct'], goldRows) + '</div></div>';
  }
  h += '<hr class="divider"><h3>Quality Rules</h3>';
  if (med.rules.length) {
    h += '<p><strong>DLT Expectations:</strong></p><pre>';
    med.rules.forEach(r => h += `  CONSTRAINT ${r.name} EXPECT (${r.expression})\n`);
    h += '</pre>';
    h += '<p><strong>Quality Check Results:</strong></p>';
    const qRows = med.results.map(r=>[r.passed?'<span class="badge badge-green">PASS</span>':'<span class="badge badge-red">FAIL</span>', r.rule, r.table, r.violations, r.total]);
    h += tableHTML(['Status','Rule','Table','Violations','Total'], qRows);
    const pc = med.results.filter(r=>r.passed).length;
    h += metricsHTML([['Pass Rate',`${pc}/${med.results.length} (${Math.round(pc/Math.max(med.results.length,1)*100)}%)`]]);
  } else h += '<div class="alert alert-info">No quality rules for this schema.</div>';
  h += '<div class="alert alert-success">Medallion pipeline complete — proceed to Step 5</div>';
  document.getElementById('conformResults').innerHTML = h;
  document.getElementById('validateNotReady').classList.add('hidden');
  document.getElementById('validateReady').classList.remove('hidden');
  setTabStatus('conform', 'done');
  unlockTab('validate');
}

function runValidation() {
  if (!STATE.tables || !STATE.blueprint) return;
  setTabStatus('validate', 'processing');
  const qr = STATE.medallion ? STATE.medallion.results : null;
  STATE.validation = runValidation_fn(STATE.blueprint, STATE.tables, qr);
  const val = STATE.validation;
  const avg = val.reduce((a,v)=>a+v.overall_score,0)/val.length;
  const gc = val.filter(v=>v.overall_score>=0.9).length;
  const ac = val.filter(v=>v.overall_score>=0.7&&v.overall_score<0.9).length;
  const rc = val.filter(v=>v.overall_score<0.7).length;
  const icon = avg>=0.9?'🟢':avg>=0.7?'🟡':'🔴';
  const lvl = avg>=0.9?'GREEN':avg>=0.7?'AMBER':'RED';
  let h = '<hr class="divider">';
  h += `<div class="score-big">${icon} ${lvl} — ${Math.round(avg*100)}%</div>`;
  h += `<p style="text-align:center;font-size:1.1rem"><strong>${val.length} tables:</strong> ${gc} green, ${ac} amber, ${rc} red</p>`;
  // Dimension averages
  const avgS = val.reduce((a,v)=>a+v.schema_score,0)/val.length;
  const avgF = val.reduce((a,v)=>a+v.fidelity_score,0)/val.length;
  const avgQ = val.reduce((a,v)=>a+v.quality_score,0)/val.length;
  const avgP = val.reduce((a,v)=>a+v.pipeline_score,0)/val.length;
  h += metricsHTML([['Schema (25%)',Math.round(avgS*100)+'%'],['Fidelity (35%)',Math.round(avgF*100)+'%'],['Quality (20%)',Math.round(avgQ*100)+'%'],['Pipeline (20%)',Math.round(avgP*100)+'%']]);
  h += '<hr class="divider"><h3>Per-Table Results</h3>';
  val.forEach(v => {
    const ic = v.overall_score>=0.9?'🟢':v.overall_score>=0.7?'🟡':'🔴';
    let body = metricsHTML([['Schema',Math.round(v.schema_score*100)+'%'],['Fidelity',Math.round(v.fidelity_score*100)+'%'],['Quality',Math.round(v.quality_score*100)+'%'],['Pipeline',Math.round(v.pipeline_score*100)+'%']]);
    body += progressHTML(v.schema_score, 'Schema Parity');
    body += progressHTML(v.fidelity_score, 'Data Fidelity');
    body += progressHTML(v.quality_score, 'Quality Compliance');
    body += progressHTML(v.pipeline_score, 'Pipeline Integrity');
    if (v.recs&&v.recs.length) body += '<p style="margin-top:12px"><strong>Recommendations:</strong></p><ul>'+v.recs.map(r=>`<li>${r}</li>`).join('')+'</ul>';
    h += expanderHTML(`${ic} <strong>${v.table}</strong> — ${Math.round(v.overall_score*100)}%`, body, v.overall_score<0.9);
  });
  h += '<hr class="divider"><h3>Scoring Methodology</h3>';
  h += tableHTML(['Dimension','Weight','Description'],[['Schema Parity','25%','Columns and types match blueprint'],['Data Fidelity','35%','Distributions, null ratios match'],['Quality Compliance','20%','DLT expectations pass rate'],['Pipeline Integrity','20%','Medallion pipeline success']]);
  h += tableHTML(['Level','Threshold','Meaning'],[['🟢 Green','≥ 90%','Ready for production cutover'],['🟡 Amber','≥ 70%','Needs attention'],['🔴 Red','< 70%','Not ready']]);
  h += '<div class="alert alert-success">Validation complete! Your synthetic environment is ready.</div>';
  document.getElementById('validateResults').innerHTML = h;
  setTabStatus('validate', 'done');
}
</script>
</body>
</html>
