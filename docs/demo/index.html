<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>SEG — Synthetic Environment Generator Demo</title>
<style>
:root {
  --bg: #0e1117; --surface: #1a1d27; --surface2: #262730;
  --border: #363842; --text: #fafafa; --text2: #808495;
  --primary: #ff4b4b; --primary-hover: #ff6b6b;
  --green: #21c354; --amber: #faca15; --red: #ff4b4b;
  --blue: #1d4ed8; --font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --mono: 'SF Mono', 'Fira Code', monospace;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { background: var(--bg); color: var(--text); font-family: var(--font); line-height: 1.6; }
.container { max-width: 1200px; margin: 0 auto; padding: 20px; }
h1 { font-size: 2rem; margin-bottom: 4px; }
h2 { font-size: 1.4rem; margin: 24px 0 12px; border-bottom: 1px solid var(--border); padding-bottom: 8px; }
h3 { font-size: 1.1rem; margin: 16px 0 8px; }
.caption { color: var(--text2); font-size: 0.9rem; margin-bottom: 20px; }
.tabs { display: flex; gap: 0; border-bottom: 2px solid var(--border); margin-bottom: 24px; overflow-x: auto; }
.tab { padding: 10px 20px; cursor: pointer; color: var(--text2); border-bottom: 2px solid transparent;
  margin-bottom: -2px; white-space: nowrap; font-size: 0.95rem; transition: all 0.2s; }
.tab:hover { color: var(--text); }
.tab.active { color: var(--primary); border-bottom-color: var(--primary); font-weight: 600; }
.panel { display: none; } .panel.active { display: block; }
.row { display: flex; gap: 20px; flex-wrap: wrap; }
.col { flex: 1; min-width: 280px; }
.col-3 { flex: 1; min-width: 200px; }
.metrics { display: flex; gap: 16px; flex-wrap: wrap; margin: 16px 0; }
.metric { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 16px 20px; min-width: 140px; flex: 1; }
.metric .label { font-size: 0.8rem; color: var(--text2); text-transform: uppercase; letter-spacing: 0.5px; }
.metric .value { font-size: 1.8rem; font-weight: 700; margin-top: 4px; }
.metric .delta { font-size: 0.85rem; color: var(--red); }
textarea, input[type=text], input[type=number], select {
  width: 100%; padding: 10px 14px; background: var(--surface); border: 1px solid var(--border);
  border-radius: 6px; color: var(--text); font-family: var(--mono); font-size: 0.9rem; resize: vertical; }
textarea:focus, input:focus { outline: none; border-color: var(--primary); }
textarea { min-height: 200px; }
label { display: block; font-size: 0.85rem; color: var(--text2); margin-bottom: 6px; font-weight: 500; }
.btn { padding: 10px 24px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.95rem;
  font-weight: 600; transition: all 0.2s; display: inline-flex; align-items: center; gap: 8px; }
.btn-primary { background: var(--primary); color: white; }
.btn-primary:hover { background: var(--primary-hover); }
.btn-secondary { background: var(--surface2); color: var(--text); border: 1px solid var(--border); }
.btn-secondary:hover { background: var(--border); }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.alert { padding: 12px 16px; border-radius: 6px; margin: 12px 0; font-size: 0.9rem; }
.alert-info { background: #1e3a5f; border: 1px solid #2563eb; color: #93c5fd; }
.alert-success { background: #14532d; border: 1px solid var(--green); color: #86efac; }
.alert-warn { background: #713f12; border: 1px solid var(--amber); color: #fde68a; }
.alert-error { background: #450a0a; border: 1px solid var(--red); color: #fca5a5; }
table { width: 100%; border-collapse: collapse; margin: 12px 0; font-size: 0.85rem; }
th { text-align: left; padding: 8px 12px; background: var(--surface2); color: var(--text2);
  font-weight: 600; text-transform: uppercase; font-size: 0.75rem; letter-spacing: 0.5px;
  border-bottom: 2px solid var(--border); }
td { padding: 8px 12px; border-bottom: 1px solid var(--border); }
tr:hover td { background: var(--surface); }
.expander { border: 1px solid var(--border); border-radius: 8px; margin: 12px 0; overflow: hidden; }
.expander-header { padding: 12px 16px; cursor: pointer; display: flex; justify-content: space-between;
  align-items: center; background: var(--surface); font-weight: 500; }
.expander-header:hover { background: var(--surface2); }
.expander-body { padding: 16px; display: none; border-top: 1px solid var(--border); }
.expander.open .expander-body { display: block; }
.expander-arrow { transition: transform 0.2s; }
.expander.open .expander-arrow { transform: rotate(90deg); }
.badge { display: inline-block; padding: 2px 10px; border-radius: 12px; font-size: 0.8rem; font-weight: 600; }
.badge-green { background: #14532d; color: #86efac; }
.badge-amber { background: #713f12; color: #fde68a; }
.badge-red { background: #450a0a; color: #fca5a5; }
.progress-bar { height: 8px; background: var(--surface2); border-radius: 4px; overflow: hidden; margin: 6px 0; }
.progress-fill { height: 100%; border-radius: 4px; transition: width 0.3s; }
.progress-fill.green { background: var(--green); }
.progress-fill.amber { background: var(--amber); }
.progress-fill.red { background: var(--red); }
code { background: var(--surface2); padding: 2px 6px; border-radius: 4px; font-family: var(--mono); font-size: 0.85rem; }
pre { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 16px;
  overflow-x: auto; font-family: var(--mono); font-size: 0.85rem; margin: 12px 0; }
.score-big { font-size: 3rem; font-weight: 800; text-align: center; padding: 20px; }
.table-scroll { overflow-x: auto; }
.file-upload { border: 2px dashed var(--border); border-radius: 8px; padding: 40px 20px; text-align: center;
  cursor: pointer; transition: border-color 0.2s; }
.file-upload:hover { border-color: var(--primary); }
.file-upload input { display: none; }
.divider { border: none; border-top: 1px solid var(--border); margin: 24px 0; }
.hidden { display: none; }
@media (max-width: 768px) { .row { flex-direction: column; } .col, .col-3 { min-width: 100%; } }
/* Tab status indicators */
.tab { position: relative; }
.tab .check { display: none; margin-left: 6px; color: var(--green); font-size: 0.85rem; }
.tab.done .check { display: inline-block; animation: pop 0.4s ease; }
.tab.locked { opacity: 0.4; pointer-events: none; }
.tab .spinner-sm { display: none; width: 12px; height: 12px; border: 2px solid var(--border);
  border-top: 2px solid var(--primary); border-radius: 50%; animation: spin 0.6s linear infinite;
  margin-left: 6px; vertical-align: middle; }
.tab.processing .spinner-sm { display: inline-block; }
@keyframes pop { 0%{transform:scale(0)} 60%{transform:scale(1.3)} 100%{transform:scale(1)} }
@keyframes spin { to { transform: rotate(360deg); } }
/* Source system grid */
.sources-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; margin: 16px 0; }
.source-badge { background: var(--surface); border: 1px solid var(--border); border-radius: 6px;
  padding: 8px 12px; text-align: center; border-top: 3px solid var(--border); transition: border-color 0.2s; }
.source-badge:hover { border-color: var(--primary); }
.source-badge .src-name { font-weight: 600; font-size: 0.85rem; }
.source-badge .src-type { color: var(--text2); font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.3px; }
.detected-source { display: inline-flex; align-items: center; gap: 8px; padding: 6px 14px;
  background: var(--surface); border: 1px solid var(--green); border-radius: 6px; margin: 8px 0; font-size: 0.9rem; }
.detected-source .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--green); }
/* Tier Diagram */
.tier-diagram { position: relative; overflow: auto; border: 1px solid var(--border); border-radius: 8px; background: var(--bg); min-height: 200px; margin: 16px 0; }
.tier-diagram svg.tier-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; }
.tier-band { padding: 16px 20px; border-bottom: 1px solid var(--border); position: relative; z-index: 2; }
.tier-band:last-child { border-bottom: none; }
.tier-band-label { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; font-weight: 700; margin-bottom: 10px; opacity: 0.8; }
.tier-nodes { display: flex; flex-wrap: wrap; gap: 12px; justify-content: center; }
.tier-node { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 10px 16px;
  min-width: 120px; max-width: 200px; text-align: center; cursor: pointer; transition: all 0.2s; position: relative; z-index: 3; }
.tier-node:hover { border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
.tier-node.selected { border-color: var(--primary); box-shadow: 0 0 0 2px rgba(255,75,75,0.3); }
.tier-node.highlighted { border-color: var(--green); }
.tier-node.dimmed { opacity: 0.3; }
.tier-node .node-name { font-weight: 600; font-size: 0.85rem; word-break: break-all; }
.tier-node .node-meta { font-size: 0.7rem; color: var(--text2); margin-top: 4px; }
.tier-node .node-badge { position: absolute; top: -6px; right: -6px; background: var(--primary); color: white;
  border-radius: 10px; padding: 1px 6px; font-size: 0.65rem; font-weight: 700; }
.tier-node .node-badge.green { background: var(--green); }
.tier-node .node-badge.amber { background: var(--amber); color: #000; }
.tier-node .node-badge.red { background: var(--red); }
/* Session nodes — numbered circle + colored stat badges */
.tier-node .node-seq { display: inline-flex; align-items: center; justify-content: center; width: 22px; height: 22px;
  border-radius: 50%; background: var(--primary); color: white; font-size: 0.7rem; font-weight: 700; margin-bottom: 4px; }
.tier-node .node-stats { display: flex; gap: 4px; justify-content: center; margin-top: 6px; flex-wrap: wrap; }
.tier-node .node-stats .ns { padding: 1px 5px; border-radius: 3px; font-size: 0.6rem; font-weight: 700; }
.ns-tx { background: #3B82F6; color: white; }
.ns-ext { background: #21C354; color: white; }
.ns-lkp { background: #EAB308; color: #000; }
/* Table output nodes — smaller, distinct style */
.tier-node.table-output { background: var(--surface2); border-style: dashed; min-width: 100px; max-width: 180px; padding: 8px 12px; }
.tier-node.table-output .node-name { font-size: 0.75rem; }
.tier-node.table-output .node-class { font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.5px; margin-top: 2px; }
/* Conflict gate nodes — red border, warning icon */
.tier-node.conflict-gate { border-color: var(--red); background: #1a0a0a; min-width: 140px; }
.tier-node.conflict-gate .node-name { color: var(--red); }
/* Connection density sidebar */
.tier-diagram-wrapper { display: flex; gap: 0; }
.tier-diagram-main { flex: 1; min-width: 0; }
.tier-density-sidebar { width: 220px; flex-shrink: 0; border-left: 1px solid var(--border); background: var(--surface);
  padding: 12px; overflow-y: auto; max-height: 800px; font-size: 0.7rem; }
.tier-density-sidebar h4 { font-size: 0.75rem; margin: 0 0 8px; color: var(--text2); text-transform: uppercase; letter-spacing: 0.5px; }
.density-row { display: flex; align-items: center; gap: 6px; margin: 3px 0; }
.density-bar { height: 6px; border-radius: 3px; flex-shrink: 0; min-width: 2px; }
.density-label { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text2); max-width: 120px; }
@media (max-width: 900px) { .tier-density-sidebar { display: none; } .tier-diagram-wrapper { flex-direction: column; } }
.node-detail { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 16px;
  margin-top: 12px; font-size: 0.85rem; }
.node-detail h4 { margin: 0 0 8px; }
.diagram-legend { display: flex; gap: 16px; flex-wrap: wrap; margin: 8px 0; font-size: 0.75rem; color: var(--text2); }
.diagram-legend span { display: flex; align-items: center; gap: 4px; }
.diagram-legend .leg-line { width: 20px; height: 2px; border-radius: 1px; }
/* Cycle indicators */
.tier-node.in-cycle { border-color: #EF4444; animation: cyclePulse 2s ease-in-out infinite; }
@keyframes cyclePulse { 0%,100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.4); } 50% { box-shadow: 0 0 0 6px rgba(239,68,68,0); } }
.cycle-badge { position: absolute; top: -6px; left: -6px; background: #EF4444; color: white;
  border-radius: 50%; width: 18px; height: 18px; font-size: 0.6rem; display: flex;
  align-items: center; justify-content: center; z-index: 4; }
/* Expandable process groups */
.tier-node .expand-indicator { font-size: 0.6rem; color: var(--text2); margin-top: 4px; }
.tier-node.expanded { border-color: var(--primary); box-shadow: 0 0 0 2px rgba(255,75,75,0.2); }
.tier-sub-band { padding: 8px 20px 12px 40px; border-bottom: 1px solid var(--border);
  background: rgba(255,255,255,0.02); position: relative; z-index: 2; }
.tier-sub-band .tier-band-label { font-size: 0.6rem; opacity: 0.6; margin-bottom: 6px; }
.tier-sub-band .tier-nodes { gap: 8px; }
.tier-sub-band .tier-node { min-width: 100px; max-width: 160px; padding: 6px 10px; }
.tier-sub-band .tier-node .node-name { font-size: 0.75rem; }
/* Progressive route tracing */
.tier-node.path-selected { border-color: #FACA15; box-shadow: 0 0 0 3px rgba(250,202,21,0.4); z-index: 10; }
.tier-node.path-selected::before { content: '\2713'; position: absolute; top: -8px; left: -8px;
  width: 18px; height: 18px; border-radius: 50%; background: #FACA15; color: #000;
  font-size: 0.65rem; font-weight: 700; display: flex; align-items: center; justify-content: center; z-index: 5; }
.tier-node.path-member { border-color: #FACA15; background: rgba(250,202,21,0.08); }
.tier-node.path-dimmed { opacity: 0.12; }
.path-trace-toast { position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%);
  background: var(--surface2); border: 1px solid var(--border); border-radius: 8px;
  padding: 10px 20px; font-size: 0.85rem; color: var(--text); z-index: 1000;
  display: none; align-items: center; gap: 12px; box-shadow: 0 4px 24px rgba(0,0,0,0.5); }
.path-trace-toast .toast-hint { color: var(--text2); font-size: 0.75rem; }
.path-trace-toast .toast-clear { cursor: pointer; color: var(--primary); font-weight: 600; font-size: 0.8rem; }
/* Sidebar active filter */
.density-row { cursor: pointer; padding: 2px 4px; border-radius: 4px; transition: background 0.15s; }
.density-row:hover { background: rgba(255,255,255,0.06); }
.density-row.filter-active { background: rgba(250,202,21,0.15); border: 1px solid rgba(250,202,21,0.4); }
.density-row.filter-dimmed { opacity: 0.3; }
.sidebar-filter-hint { font-size: 0.6rem; color: var(--text2); margin-bottom: 6px; font-style: italic; }
.sidebar-clear-btn { font-size: 0.65rem; color: var(--primary); cursor: pointer; margin-top: 6px;
  display: none; text-align: center; padding: 4px; border-radius: 4px; }
.sidebar-clear-btn:hover { background: rgba(255,75,75,0.1); }
/* Notebook preview */
.notebook-preview { background: var(--surface); border: 1px solid var(--border); border-radius: 8px;
  max-height: 600px; overflow-y: auto; margin: 12px 0; }
.notebook-cell { padding: 10px 16px; border-bottom: 1px solid var(--border); font-family: 'SF Mono',Monaco,Consolas,monospace;
  font-size: 0.78rem; line-height: 1.5; white-space: pre-wrap; word-break: break-word; }
.notebook-cell:last-child { border-bottom: none; }
.notebook-cell.cell-md { background: rgba(59,130,246,0.06); color: #93c5fd; }
.notebook-cell.cell-sql { background: rgba(168,85,247,0.06); }
.notebook-cell.cell-code { background: var(--surface); }
.notebook-cell .cell-label { display: inline-block; padding: 1px 8px; border-radius: 3px;
  font-size: 0.65rem; font-weight: 700; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
.cell-label.lb-source { background: #1d3557; color: #93c5fd; }
.cell-label.lb-transform { background: #2d1b4e; color: #c4b5fd; }
.cell-label.lb-sink { background: #14532d; color: #86efac; }
.cell-label.lb-route { background: #422006; color: #fde68a; }
.cell-label.lb-process { background: #1e1b4b; color: #a5b4fc; }
.cell-label.lb-utility { background: #1f2937; color: #9ca3af; }
.cell-label.lb-config { background: #0c4a6e; color: #7dd3fc; }
.cell-label.lb-manual { background: #450a0a; color: #fca5a5; }
/* Gap cards */
.gap-card { background: var(--surface); border: 1px solid var(--border); border-radius: 8px;
  padding: 10px 14px; margin: 6px 0; border-left: 3px solid var(--red); }
.gap-card .gap-title { font-weight: 600; font-size: 0.85rem; margin-bottom: 2px; }
.gap-card .gap-meta { color: var(--text2); font-size: 0.75rem; }
.gap-card .gap-rec { color: var(--amber); font-size: 0.8rem; margin-top: 4px; }
/* Coverage ring */
.coverage-ring { width: 120px; height: 120px; border-radius: 50%; position: relative;
  display: inline-flex; align-items: center; justify-content: center; }
.coverage-ring .ring-text { font-size: 1.6rem; font-weight: 800; z-index: 1; }
/* Mapping table */
.mapping-table { width: 100%; border-collapse: collapse; font-size: 0.78rem; margin: 12px 0; }
.mapping-table th { text-align: left; padding: 6px 10px; border-bottom: 2px solid var(--border);
  font-size: 0.7rem; text-transform: uppercase; color: var(--text2); }
.mapping-table td { padding: 5px 10px; border-bottom: 1px solid var(--border); }
.mapping-table tr.unmapped { opacity: 0.5; }
.conf-badge { padding: 1px 6px; border-radius: 3px; font-size: 0.65rem; font-weight: 700; }
.conf-high { background: rgba(33,195,84,0.2); color: #86efac; }
.conf-med { background: rgba(234,179,8,0.2); color: #fde68a; }
.conf-low { background: rgba(239,68,68,0.2); color: #fca5a5; }
.conf-none { background: rgba(128,132,149,0.15); color: #9ca3af; }
</style>
</head>
<body>
<div class="container">
  <h1>SEG — Synthetic Environment Generator</h1>
  <p class="caption">Upload from 20+ source systems — Oracle, Snowflake, Redshift, Informatica, NiFi, dbt, PySpark, and more — generate a full synthetic environment instantly in your browser</p>

  <div class="tabs" id="tabs">
    <div class="tab active" data-tab="parse">1. Load &amp; Parse<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
    <div class="tab locked" data-tab="blueprint">2. Blueprint<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
    <div class="tab locked" data-tab="generate">3. Generate<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
    <div class="tab locked" data-tab="conform">4. Conform<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
    <div class="tab locked" data-tab="validate">5. Validate<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
    <div class="tab locked" data-tab="notebook">6. Notebook<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
    <div class="tab locked" data-tab="report">7. Report<span class="check">&#10003;</span><span class="spinner-sm"></span></div>
  </div>

  <!-- STEP 1: PARSE -->
  <div class="panel active" id="panel-parse">
    <h2>Step 1: Load &amp; Parse Input</h2>
    <h3>Supported Sources</h3>
    <div class="sources-grid">
      <div class="source-badge" style="border-top-color:#4285F4"><div class="src-name">Google BigQuery</div><div class="src-type">Cloud Platform</div></div>
      <div class="source-badge" style="border-top-color:#FF9900"><div class="src-name">AWS Redshift</div><div class="src-type">Data Warehouse</div></div>
      <div class="source-badge" style="border-top-color:#FF4A00"><div class="src-name">Informatica</div><div class="src-type">ETL &amp; Integration</div></div>
      <div class="source-badge" style="border-top-color:#29B5E8"><div class="src-name">Snowflake</div><div class="src-type">Data Cloud</div></div>
      <div class="source-badge" style="border-top-color:#F37440"><div class="src-name">Teradata</div><div class="src-type">Enterprise DW</div></div>
      <div class="source-badge" style="border-top-color:#FF3621"><div class="src-name">Databricks</div><div class="src-type">Unity Catalog</div></div>
      <div class="source-badge" style="border-top-color:#0FAAFF"><div class="src-name">SAP HANA</div><div class="src-type">ERP / BW</div></div>
      <div class="source-badge" style="border-top-color:#0078D4"><div class="src-name">Azure Synapse</div><div class="src-type">Analytics</div></div>
      <div class="source-badge" style="border-top-color:#CC2927"><div class="src-name">SQL Server</div><div class="src-type">Microsoft SQL</div></div>
      <div class="source-badge" style="border-top-color:#F80000"><div class="src-name">Oracle</div><div class="src-type">Database</div></div>
      <div class="source-badge" style="border-top-color:#4169E1"><div class="src-name">PostgreSQL</div><div class="src-type">Database</div></div>
      <div class="source-badge" style="border-top-color:#4479A1"><div class="src-name">MySQL</div><div class="src-type">Database</div></div>
      <div class="source-badge" style="border-top-color:#FF694B"><div class="src-name">dbt</div><div class="src-type">Transformation</div></div>
      <div class="source-badge" style="border-top-color:#E25A1C"><div class="src-name">PySpark</div><div class="src-type">Spark Schema</div></div>
      <div class="source-badge" style="border-top-color:#DC382D"><div class="src-name">Scala / Spark</div><div class="src-type">Case Classes</div></div>
      <div class="source-badge" style="border-top-color:#FF6D70"><div class="src-name">Talend</div><div class="src-type">Data Integration</div></div>
      <div class="source-badge" style="border-top-color:#728E9B"><div class="src-name">Apache NiFi</div><div class="src-type">Flow Definition</div></div>
      <div class="source-badge" style="border-top-color:#3ECF8E"><div class="src-name">Avro / Protobuf</div><div class="src-type">Schema Files</div></div>
      <div class="source-badge" style="border-top-color:#8B5CF6"><div class="src-name">Dependency Graph</div><div class="src-type">Session Lineage</div></div>
    </div>
    <div class="row">
      <div class="col">
        <h3>Upload File</h3>
        <div class="file-upload" id="fileDropZone">
          <p>Drop a file here or click to browse</p>
          <p style="color:var(--text2);font-size:0.85rem">SQL, DDL, CSV, JSON, YAML, XML, Avro, Protobuf, PySpark, Scala, NiFi, dbt</p>
          <input type="file" id="fileInput" accept=".sql,.ddl,.hql,.bteq,.psql,.csv,.tsv,.json,.avsc,.yaml,.yml,.xml,.py,.scala,.proto">
        </div>
        <div id="fileName" class="alert alert-info hidden" style="margin-top:12px"></div>
      </div>
      <div class="col">
        <h3>Paste Text</h3>
        <textarea id="pasteInput" placeholder="CREATE TABLE customers (
  id INT PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  email VARCHAR(200),
  status VARCHAR(20) CHECK (status IN ('active','inactive'))
);"></textarea>
      </div>
    </div>
    <div style="margin-top:16px">
      <button class="btn btn-primary" onclick="parseInput()">Parse Input</button>
    </div>
    <div id="parseResults"></div>
  </div>

  <!-- STEP 2: BLUEPRINT -->
  <div class="panel" id="panel-blueprint">
    <h2>Step 2: Blueprint Assembly</h2>
    <div id="blueprintNotReady" class="alert alert-info">Complete Step 1 first — parse a file or paste text.</div>
    <div id="blueprintReady" class="hidden">
      <div style="margin-top:8px">
        <button class="btn btn-primary" onclick="assembleBlueprint()">Assemble Blueprint</button>
      </div>
      <div id="blueprintResults"></div>
      <div id="tierDiagramContainer" class="hidden">
        <h3>Environment Visualization</h3>
        <div id="tierDiagramLegend" class="diagram-legend"></div>
        <div class="tier-diagram-wrapper">
          <div id="tierDiagram" class="tier-diagram tier-diagram-main"></div>
          <div id="tierDensitySidebar" class="tier-density-sidebar hidden">
            <h4>Connection Density</h4>
            <div id="densityBars"></div>
          </div>
        </div>
        <div id="tierNodeDetail"></div>
      </div>
    </div>
  </div>

  <!-- STEP 3: GENERATE -->
  <div class="panel" id="panel-generate">
    <h2>Step 3: Generate Synthetic Data</h2>
    <div id="generateNotReady" class="alert alert-info">Complete Step 2 first.</div>
    <div id="generateReady" class="hidden">
      <p style="color:var(--text2);font-size:0.9rem;margin-bottom:12px">Configure synthetic data generation — row counts default to actuals from the source when available.</p>
      <div class="row">
        <div class="col">
          <label>Override rows per table <span style="color:var(--text2);font-weight:400">(0 = use source actuals)</span></label>
          <input type="number" id="rowCount" value="0" min="0" max="100000" step="100">
        </div>
        <div class="col">
          <label>Random seed <span style="color:var(--text2);font-weight:400">(for reproducibility)</span></label>
          <input type="number" id="seed" value="42" min="0">
        </div>
      </div>
      <div style="margin-top:12px">
        <button class="btn btn-primary" onclick="generateData()">Generate Synthetic Data</button>
      </div>
      <div id="generateResults"></div>
    </div>
  </div>

  <!-- STEP 4: CONFORM -->
  <div class="panel" id="panel-conform">
    <h2>Step 4: Conform — Medallion Architecture</h2>
    <div id="conformNotReady" class="alert alert-info">Complete Step 3 first.</div>
    <div id="conformReady" class="hidden">
      <button class="btn btn-primary" onclick="runConform()">Run Medallion Pipeline</button>
      <div id="conformResults"></div>
    </div>
  </div>

  <!-- STEP 5: VALIDATE -->
  <div class="panel" id="panel-validate">
    <h2>Step 5: Validate &amp; Confidence Score</h2>
    <div id="validateNotReady" class="alert alert-info">Complete Steps 3-4 first.</div>
    <div id="validateReady" class="hidden">
      <button class="btn btn-primary" onclick="runValidation()">Run Validation</button>
      <div id="validateResults"></div>
    </div>
  </div>
  <!-- STEP 6: NOTEBOOK -->
  <div class="panel" id="panel-notebook">
    <h2>Step 6: NiFi &rarr; Databricks Notebook</h2>
    <div id="notebookNotReady" class="alert alert-info">Complete validation first with a NiFi flow.</div>
    <div id="notebookNotNifi" class="alert alert-info hidden">This step is only available for NiFi flow inputs.</div>
    <div id="notebookReady" class="hidden">
      <p style="color:var(--text2);font-size:0.9rem;margin-bottom:12px">
        Reverse-engineer your NiFi flow into a Databricks Python notebook with PySpark equivalents,
        Unity Catalog definitions, and a Databricks workflow.
      </p>
      <button class="btn btn-primary" onclick="generateNotebook()">Generate Notebook</button>
      <div id="notebookResults"></div>
    </div>
  </div>
  <!-- STEP 7: MIGRATION REPORT -->
  <div class="panel" id="panel-report">
    <h2>Step 7: Migration Report</h2>
    <div id="reportNotReady" class="alert alert-info">Generate the notebook first (Step 6).</div>
    <div id="reportReady" class="hidden">
      <button class="btn btn-primary" onclick="generateReport()">Generate Report</button>
      <div id="reportResults"></div>
    </div>
  </div>
</div>

<script>
// ================================================================
// STATE
// ================================================================
let STATE = { parsed: null, blueprint: null, tables: null, medallion: null, validation: null, notebook: null, migrationReport: null };

// ================================================================
// TAB NAVIGATION
// ================================================================
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    if (tab.classList.contains('locked')) return;
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById('panel-' + tab.dataset.tab).classList.add('active');
  });
});

function switchTab(name) {
  document.querySelectorAll('.tab').forEach(t => { t.classList.toggle('active', t.dataset.tab === name); });
  document.querySelectorAll('.panel').forEach(p => { p.classList.toggle('active', p.id === 'panel-' + name); });
}

function setTabStatus(name, status) {
  const tab = document.querySelector(`.tab[data-tab="${name}"]`);
  if (!tab) return;
  tab.classList.remove('locked','processing','done');
  if (status === 'locked') tab.classList.add('locked');
  else if (status === 'processing') tab.classList.add('processing');
  else if (status === 'done') tab.classList.add('done');
  // 'ready' = no extra class, just clickable
  if (status !== 'locked') {
    tab.style.pointerEvents = '';
    tab.style.opacity = '';
  }
}

function unlockTab(name) { setTabStatus(name, 'ready'); }

// FILE UPLOAD
const fileInput = document.getElementById('fileInput');
const dropZone = document.getElementById('fileDropZone');
dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.style.borderColor = 'var(--primary)'; });
dropZone.addEventListener('dragleave', () => { dropZone.style.borderColor = 'var(--border)'; });
dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.style.borderColor = 'var(--border)';
  if (e.dataTransfer.files.length) { fileInput.files = e.dataTransfer.files; handleFile(); }
});
fileInput.addEventListener('change', handleFile);

let uploadedContent = '', uploadedName = '';
function handleFile() {
  const f = fileInput.files[0]; if (!f) return;
  uploadedName = f.name;
  document.getElementById('fileName').textContent = 'Loaded: ' + f.name;
  document.getElementById('fileName').classList.remove('hidden');
  const reader = new FileReader();
  reader.onload = e => { uploadedContent = e.target.result; };
  reader.readAsText(f);
}

// ================================================================
// SMART PARSE ENGINE — Resilient Cascading Parser
// ================================================================
function cleanInput(content) {
  if (!content) return '';
  let c = content;
  // Strip BOM
  if (c.charCodeAt(0) === 0xFEFF) c = c.substring(1);
  // Normalize line endings
  c = c.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  // Remove NULL bytes
  c = c.replace(/\x00/g, '');
  // Replace non-breaking spaces
  c = c.replace(/\u00A0/g, ' ');
  // Replace smart quotes
  c = c.replace(/[\u201C\u201D]/g, '"').replace(/[\u2018\u2019]/g, "'");
  return c.trim();
}

function rankFormats(content, filename) {
  const candidates = [];
  // Extension-based (high confidence)
  if (filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const extMap = {sql:'ddl',ddl:'ddl',hql:'ddl',bteq:'ddl',psql:'ddl',csv:'csv',tsv:'csv',json:'json',avsc:'avro',yaml:'yaml',yml:'yaml',xml:'xml',py:'pyspark',scala:'scala',proto:'protobuf'};
    if (extMap[ext]) {
      let fmt = extMap[ext];
      if (fmt === 'xml') fmt = detectXMLFormat(content);
      if (fmt === 'json') { try { const d=JSON.parse(content.trim()); if(d.type==='record'&&d.fields) fmt='avro'; } catch(e){} }
      candidates.push({format: fmt, confidence: 0.9});
    }
  }
  const s = content.trim();
  // NiFi template
  if (/<template[\s>][\s\S]{0,1000}<snippet>/i.test(s.substring(0,3000))) candidates.push({format:'nifi_xml',confidence:0.95});
  if (/org\.apache\.nifi\./i.test(s.substring(0,15000))) candidates.push({format:'nifi_xml',confidence:0.90});
  // Informatica
  if (/<(REPOSITORY|FOLDER|POWERMART|INFORMATICA)/i.test(s)) candidates.push({format:'informatica_xml',confidence:0.95});
  // Talend
  if (/<(TalendProperties|talendfile|ProcessType)/i.test(s)) candidates.push({format:'talend_xml',confidence:0.95});
  // Protobuf
  if (/\bmessage\s+\w+\s*\{[\s\S]*?(?:string|int32|int64|bool|double)\s+\w+\s*=\s*\d+/i.test(s.substring(0,5000))) candidates.push({format:'protobuf',confidence:0.88});
  // PySpark
  if (/StructType\s*\(|StructField\s*\(/i.test(s)) candidates.push({format:'pyspark',confidence:0.88});
  // Scala
  if (/case\s+class\s+\w+/i.test(s)) candidates.push({format:'scala',confidence:0.85});
  // Spark printSchema
  if (/root\s*\n\s*\|--/.test(s)) candidates.push({format:'spark_schema',confidence:0.90});
  // dbt
  if (/\{\{\s*(ref|source|config)\s*\(/.test(s)) candidates.push({format:'dbt',confidence:0.88});
  // Avro
  if (s.startsWith('{')) { try { const d=JSON.parse(s); if(d.type==='record'&&d.fields) candidates.push({format:'avro',confidence:0.92}); if(d.sessions&&(d.dependency_edges||d.table_index)) candidates.push({format:'dependency_json',confidence:0.95}); } catch(e){} }
  // DDL
  if (/CREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMPORARY\s+|GLOBAL\s+TEMPORARY\s+|VOLATILE\s+|TRANSIENT\s+|EXTERNAL\s+|MULTISET\s+|SET\s+|COLUMN\s+|ROW\s+|UNLOGGED\s+|TEMP\s+)*TABLE\b/i.test(s)) candidates.push({format:'ddl',confidence:0.82});
  // JSON
  if (s.startsWith('{') || s.startsWith('[')) { try { JSON.parse(s); candidates.push({format:'json',confidence:0.70}); } catch(e){} }
  // XML
  if (s.startsWith('<')) candidates.push({format:'xml',confidence:0.60});
  // YAML
  if (/^(tables|models|sources)\s*:/m.test(s)) candidates.push({format:'yaml',confidence:0.80});
  // CSV
  const fl = s.split('\n')[0].toLowerCase();
  if (['source_table','target_table','src_table','tgt_table','table_name','column_name'].some(h => fl.includes(h))) candidates.push({format:'csv',confidence:0.80});
  // Fallback DDL from type keywords
  if (/\b(INT|VARCHAR|DECIMAL|TIMESTAMP|BOOLEAN|BIGINT|FLOAT|DOUBLE|NUMBER)\b/i.test(s)) candidates.push({format:'ddl',confidence:0.30});
  // Always include DDL as absolute fallback
  if (!candidates.some(c=>c.format==='ddl')) candidates.push({format:'ddl',confidence:0.10});
  // Dedupe: keep highest confidence per format
  const best = {};
  candidates.forEach(c => { if (!best[c.format] || c.confidence > best[c.format].confidence) best[c.format] = c; });
  return Object.values(best).sort((a,b) => b.confidence - a.confidence);
}

function routeParser(format, content, filename) {
  const sn = filename || 'Parsed Input';
  if (format==='yaml') return parseYAML(content, sn);
  if (format==='pyspark') return parsePySpark(content, sn);
  if (format==='scala') return parseScala(content, sn);
  if (format==='dbt') return parseDBT(content, sn);
  if (format==='avro') return parseAvro(content, sn);
  if (format==='protobuf') return parseProtobuf(content, sn);
  if (format==='spark_schema') return parseSparkSchema(content, sn);
  if (format==='informatica_xml') { const doc=new DOMParser().parseFromString(content,'text/xml'); return parseInformaticaXML(doc, sn); }
  if (format==='talend_xml') { const doc=new DOMParser().parseFromString(content,'text/xml'); return parseTalendXML(doc, sn); }
  if (format==='nifi_xml') { const doc=new DOMParser().parseFromString(content,'text/xml'); return parseNiFiXML(doc, sn); }
  if (format==='dependency_json') return parseJSON(content, sn);
  if (format==='json') return parseJSON(content, sn);
  if (format==='xml') return parseXML(content, sn);
  if (format==='csv') return parseCSV(content, sn);
  return parseDDL(content, sn);
}

function validateParseResult(result) {
  let score = 0;
  const warnings = [];
  if (!result || !result.tables) return {score:0, warnings:['No result'], result};
  if (result.tables.length > 0) score += 0.3;
  const withCols = result.tables.filter(t => t.columns && t.columns.length > 0);
  if (withCols.length === result.tables.length) score += 0.3;
  else if (withCols.length > 0) { score += 0.15; warnings.push(`${result.tables.length - withCols.length} tables have no columns`); }
  const allCols = result.tables.flatMap(t => t.columns || []);
  const typedCols = allCols.filter(c => c.data_type && c.data_type !== 'varchar');
  if (typedCols.length > allCols.length * 0.3) score += 0.2;
  else if (allCols.length > 0) score += 0.1;
  const namedTables = result.tables.filter(t => t.name && t.name.length > 0);
  if (namedTables.length === result.tables.length) score += 0.1;
  const names = result.tables.map(t => t.name);
  if (new Set(names).size === names.length) score += 0.1;
  return {score, warnings, result};
}

function bruteForceExtract(content, filename, priorErrors) {
  const tables = [];
  // Strategy 1: column-type patterns
  const colPattern = /\b(\w{2,30})\s+(INT(?:EGER)?|VARCHAR\d*|CHAR|TEXT|DECIMAL|FLOAT|DOUBLE|DATE|TIMESTAMP|BOOLEAN|BIGINT|SMALLINT|TINYINT|NUMBER|STRING|BINARY|BLOB|CLOB)\b/gi;
  const matches = [...content.matchAll(colPattern)];
  if (matches.length >= 2) {
    const seen = new Set();
    const cols = matches.filter(m => { const k=m[1].toLowerCase(); if(seen.has(k))return false; seen.add(k); return true; }).map(m => ({
      name:m[1], data_type:TYPE_NORM[m[2].toLowerCase()]||m[2].toLowerCase(), raw_type:m[2],
      nullable:true, is_primary_key:false, is_unique:false, check_constraints:[], max_length:null, precision:null, scale:null, default_value:null
    }));
    if (cols.length >= 2) tables.push({name:filename?filename.replace(/\.[^.]+$/,''):'extracted_table', schema:'unknown', columns:cols, foreign_keys:[], row_count:1000});
  }
  // Strategy 2: XML name/type attributes
  if (content.trim().startsWith('<')) {
    try {
      const doc = new DOMParser().parseFromString(content, 'text/xml');
      const groups = {};
      doc.querySelectorAll('*').forEach(el => {
        const name = el.getAttribute('name')||el.getAttribute('Name')||el.getAttribute('NAME');
        const type = el.getAttribute('type')||el.getAttribute('Type')||el.getAttribute('TYPE')||el.getAttribute('datatype')||el.getAttribute('DATATYPE');
        if (name && type) {
          const parent = el.parentElement?.getAttribute('name')||el.parentElement?.getAttribute('Name')||'xml_table';
          if (!groups[parent]) groups[parent] = [];
          groups[parent].push({name, data_type:TYPE_NORM[type.toLowerCase()]||type.toLowerCase(), raw_type:type,
            nullable:true, is_primary_key:false, is_unique:false, check_constraints:[], max_length:null, precision:null, scale:null, default_value:null});
        }
      });
      Object.entries(groups).forEach(([tn, cols]) => {
        if (cols.length >= 2 && !tables.find(t=>t.name===tn)) tables.push({name:tn, schema:'unknown', columns:cols, foreign_keys:[], row_count:1000});
      });
    } catch(e) {}
  }
  const warnings = ['Primary parsers failed — used brute-force extraction'];
  if (priorErrors && priorErrors.length) priorErrors.forEach(e => warnings.push(`${e.format}: ${e.error}`));
  return {source_name:filename||'Unknown', source_type:'brute_force', tables, input_format:'unknown', parse_warnings:warnings};
}

function smartParse(content, filename) {
  content = cleanInput(content);
  if (!content) return null;
  const candidates = rankFormats(content, filename);
  const errors = [];
  for (const {format, confidence} of candidates) {
    try {
      const result = routeParser(format, content, filename);
      if (result && result.tables && result.tables.length > 0) {
        const validated = validateParseResult(result);
        if (validated.score > 0.3) {
          result.detected_format = format;
          result.parse_confidence = confidence;
          result.parse_attempts = errors.length + 1;
          if (validated.warnings.length) result.parse_warnings = (result.parse_warnings||[]).concat(validated.warnings);
          return result;
        }
      }
    } catch(e) { errors.push({format, error: e.message}); }
  }
  // Final fallback
  return bruteForceExtract(content, filename, errors);
}

// ================================================================
// PARSERS
// ================================================================
const TYPE_NORM = {
  // Oracle
  number:'decimal',varchar2:'varchar',nvarchar2:'varchar',clob:'text',nclob:'text',blob:'binary',
  raw:'binary','long raw':'binary',long:'text',binary_float:'float',binary_double:'double',
  xmltype:'text',rowid:'varchar',urowid:'varchar',
  // SQL Server / Azure Synapse
  nvarchar:'varchar',nchar:'char',bit:'boolean',money:'decimal',smallmoney:'decimal',
  datetime2:'timestamp',datetimeoffset:'timestamp',smalldatetime:'timestamp',
  image:'binary',ntext:'text',uniqueidentifier:'varchar',sql_variant:'varchar',
  hierarchyid:'varchar',varbinary:'binary',xml:'text',
  // PostgreSQL
  serial:'int',bigserial:'bigint',smallserial:'smallint',real:'float',
  'double precision':'double','character varying':'varchar',character:'char',
  bytea:'binary',inet:'varchar',cidr:'varchar',macaddr:'varchar',uuid:'varchar',
  jsonb:'text',json:'text',tsquery:'text',tsvector:'text',interval:'varchar',
  int2:'smallint',int4:'int',int8:'bigint',float4:'float',float8:'double',
  bool:'boolean',timestamptz:'timestamp',
  // MySQL
  mediumint:'int',mediumtext:'text',longtext:'text',tinytext:'text',
  enum:'varchar',set:'varchar',year:'int',mediumblob:'binary',longblob:'binary',
  tinyblob:'binary',tinyint:'int',
  // Snowflake
  variant:'text',object:'text',array:'text',string:'varchar',
  timestamp_ltz:'timestamp',timestamp_ntz:'timestamp',timestamp_tz:'timestamp',
  // Redshift
  super:'text',hllsketch:'varchar',bpchar:'char',
  // Teradata
  byteint:'int',st_geometry:'varchar',
  // SAP HANA
  cs_string:'varchar',cs_int:'int',cs_double:'double',cs_decimal:'decimal',
  alphanum:'varchar',shorttext:'varchar',seconddate:'timestamp',daydate:'date',
  // BigQuery
  int64:'bigint',float64:'double',bignumeric:'decimal',record:'text',struct:'text',
  geography:'varchar',geometry:'varchar',
  // Databricks / Spark
  short:'smallint',byte:'tinyint',binary:'binary',map:'text',void:'varchar',
  // Informatica / Talend
  nstring:'varchar',
};
const MW_TYPES = ['double precision','character varying','timestamp with time zone',
  'timestamp without time zone','timestamp with local time zone','long raw',
  'long varchar','binary varying','national character varying','national character'];

function detectFormat(content, filename) {
  if (filename) {
    const ext = filename.split('.').pop().toLowerCase();
    const map = {sql:'ddl',ddl:'ddl',hql:'ddl',bteq:'ddl',psql:'ddl',csv:'csv',tsv:'csv',json:'json',avsc:'avro',yaml:'yaml',yml:'yaml',xml:'xml',py:'pyspark',scala:'scala',proto:'protobuf'};
    if (map[ext]) {
      // For XML files, do deeper detection
      if (map[ext]==='xml') return detectXMLFormat(content);
      // For JSON, check if it's Avro
      if (map[ext]==='json') { try { const d=JSON.parse(content.trim()); if(d.type==='record'&&d.fields)return 'avro'; } catch(e){} return 'json'; }
      return map[ext];
    }
  }
  const s = content.trim();
  // Protobuf
  if (/\bmessage\s+\w+\s*\{[\s\S]*?(?:string|int32|int64|bool|double)\s+\w+\s*=\s*\d+/i.test(s)) return 'protobuf';
  // PySpark
  if (/StructType\s*\(|StructField\s*\(/i.test(s)) return 'pyspark';
  // Scala case class
  if (/case\s+class\s+\w+\s*\(/i.test(s)) return 'scala';
  // Spark printSchema
  if (/root\s*\n\s*\|--/.test(s)) return 'spark_schema';
  // dbt
  if (/\{\{\s*(ref|source|config)\s*\(/.test(s)) return 'dbt';
  // XML
  if (s.startsWith('<')) return detectXMLFormat(s);
  // DDL (enhanced regex)
  if (/\bCREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMPORARY\s+|GLOBAL\s+TEMPORARY\s+|VOLATILE\s+|TRANSIENT\s+|EXTERNAL\s+|MULTISET\s+|SET\s+|COLUMN\s+|ROW\s+|UNLOGGED\s+)*TABLE\b/i.test(s)) return 'ddl';
  // JSON / Avro
  if (s.startsWith('{') || s.startsWith('[')) { try { const d=JSON.parse(s); if(d.type==='record'&&d.fields)return 'avro'; if(d.tables||d.models)return 'json'; return 'json'; } catch(e){} }
  // YAML
  if (/^(tables|models|sources)\s*:/m.test(s)) return 'yaml';
  // CSV
  const fl = s.split('\n')[0].toLowerCase();
  if (['source_table','target_table','src_table','tgt_table','table_name','column_name'].some(h => fl.includes(h))) return 'csv';
  // Fallback DDL
  if (/\b(INT|VARCHAR|DECIMAL|TIMESTAMP|BOOLEAN|BIGINT|FLOAT|DOUBLE|NUMBER)\b/i.test(s)) return 'ddl';
  return 'unknown';
}

function detectXMLFormat(content) {
  if (/<(REPOSITORY|FOLDER|POWERMART|INFORMATICA)/i.test(content)) return 'informatica_xml';
  if (/<(SOURCE\s|TARGET\s).*?(DATABASETYPE|SOURCEFIELD|TARGETFIELD)/i.test(content)) return 'informatica_xml';
  if (/<(TalendProperties|talendfile|ProcessType|talend)/i.test(content)) return 'talend_xml';
  // NiFi: template exports have <template><snippet><processGroups>
  if (/<template[\s>][\s\S]{0,500}<snippet>/i.test(content.substring(0,2000))) return 'nifi_xml';
  if (/<snippet>[\s\S]{0,500}<(processGroups|controllerServices|processors)/i.test(content.substring(0,5000))) return 'nifi_xml';
  if (/<(flowController|rootGroup|processGroupFlow)\b/i.test(content)) return 'nifi_xml';
  if (/org\.apache\.nifi\./i.test(content.substring(0,10000))) return 'nifi_xml';
  return 'xml';
}

function prepareDDL(content) {
  // Strip block comments (non-nested)
  let clean = content.replace(/\/\*[\s\S]*?\*\//g, ' ');
  // Strip line comments
  clean = clean.replace(/--[^\n]*/g, '');
  // Replace string literals with safe placeholders to prevent paren confusion
  clean = clean.replace(/'(?:[^'\\]|\\.)*'/g, match => "'" + ' '.repeat(Math.max(0,match.length-2)) + "'");
  return clean;
}

function parseDDL(content, sourceName) {
  const tables = [], warnings = [];
  const prepared = prepareDDL(content);
  const hp = /CREATE\s+(?:OR\s+REPLACE\s+)?(?:TEMPORARY\s+|GLOBAL\s+TEMPORARY\s+|VOLATILE\s+|TRANSIENT\s+|EXTERNAL\s+|MULTISET\s+|SET\s+|COLUMN\s+|ROW\s+|UNLOGGED\s+|TEMP\s+)*TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?([^\s(]+)\s*\(/gi;
  let hm;
  while ((hm = hp.exec(prepared)) !== null) {
    const rawName = hm[1]; let start = hm.index + hm[0].length, depth = 1, i = start;
    let limit = 100000;
    while (i < prepared.length && depth > 0 && limit-- > 0) { if (prepared[i]==='(') depth++; else if (prepared[i]===')') depth--; i++; }
    if (depth === 0) {
      // Use original content for body to preserve actual defaults/strings
      const body = content.substring(start, i-1);
      const clean = rawName.replace(/[\[\]`"]/g,''); const parts = clean.split('.');
      const tName = parts[parts.length-1], schema = parts.length>=2 ? parts[parts.length-2] : 'dbo';
      const {cols, fks} = parseTableBody(body);
      if (cols.length > 0) tables.push({name:tName, schema, columns:cols, foreign_keys:fks, row_count:1000});
      else warnings.push(`Table ${tName}: no columns extracted`);
    } else { warnings.push(`Table ${rawName}: unbalanced parentheses`); }
  }
  // ALTER TABLE FKs
  const ap = /ALTER\s+TABLE\s+(\S+)\s+ADD\s+(?:CONSTRAINT\s+\S+\s+)?FOREIGN\s+KEY\s*\(\s*[\[`"]?(\w+)[\]`"]?\s*\)\s*REFERENCES\s+(\S+)\s*\(\s*[\[`"]?(\w+)[\]`"]?\s*\)/gi;
  let am;
  while ((am = ap.exec(content)) !== null) {
    const tn = am[1].replace(/[\[\]`"]/g,'').split('.').pop();
    const fk = {fk_column:am[2], referenced_table:am[3].replace(/[\[\]`"]/g,'').split('.').pop(), referenced_column:am[4]};
    const t = tables.find(t => t.name.toLowerCase() === tn.toLowerCase());
    if (t) t.foreign_keys.push(fk);
  }
  return {source_name:sourceName||'DDL Import', source_type:'sql', tables, input_format:'ddl', parse_warnings:warnings};
}

function parseTableBody(body) {
  const cols = [], fks = [];
  const elems = splitDefs(body);
  for (let el of elems) {
    el = el.trim(); if (!el) continue;
    const upper = el.toUpperCase().trim();
    if (upper.startsWith('PRIMARY KEY')) {
      const pks = extractParensList(el);
      cols.forEach(c => { if (pks.some(p => p.toLowerCase()===c.name.toLowerCase())) c.is_primary_key = true; });
      continue;
    }
    if (upper.startsWith('FOREIGN KEY')) {
      const m = el.match(/FOREIGN\s+KEY\s*\(\s*(\w+)\s*\)\s*REFERENCES\s+(\S+)\s*\(\s*(\w+)\s*\)/i);
      if (m) fks.push({fk_column:m[1], referenced_table:m[2].replace(/[\[\]`"]/g,'').split('.').pop(), referenced_column:m[3]});
      continue;
    }
    if (/^(UNIQUE|CHECK|CONSTRAINT|INDEX)/i.test(upper)) continue;
    const r = parseColDef(el);
    if (r.col) { cols.push(r.col); if (r.fk) fks.push(r.fk); }
  }
  return {cols, fks};
}

function parseColDef(el) {
  const s = el.trim();
  const nm = s.match(/^([`"\[\]]?\w+[`"\]\]]?)\s+/);
  if (!nm) return {};
  const rawName = nm[1].replace(/[\[\]`"]/g,'');
  let rest = s.substring(nm[0].length);
  let rawType = '', typeArgs = null;
  const rl = rest.toLowerCase();
  for (const mwt of MW_TYPES.sort((a,b)=>b.length-a.length)) {
    if (rl.startsWith(mwt)) { rawType = mwt; rest = rest.substring(mwt.length).trim(); break; }
  }
  if (!rawType) {
    const tm = rest.match(/^([A-Za-z_]\w*)/);
    if (!tm) return {};
    rawType = tm[1].toLowerCase(); rest = rest.substring(tm[0].length).trim();
  }
  if (rest.startsWith('(')) {
    const pe = rest.indexOf(')');
    if (pe > 0) { typeArgs = rest.substring(1, pe); rest = rest.substring(pe+1).trim(); }
  }
  const modsOrig = rest, mods = rest.toUpperCase();
  const ctype = TYPE_NORM[rawType] || rawType;
  let prec=null, scl=null, maxl=null;
  if (typeArgs) {
    const pts = typeArgs.split(',').map(p=>p.trim());
    if (['decimal','numeric'].includes(ctype)) { prec = parseInt(pts[0])||null; scl = pts[1]?parseInt(pts[1]):null; }
    else if (['varchar','char','text'].includes(ctype)) { if (/^\d+$/.test(pts[0])) maxl = parseInt(pts[0]); }
  }
  const nullable = !mods.includes('NOT NULL'), isPK = mods.includes('PRIMARY KEY'), isUnique = mods.includes('UNIQUE');
  let checkVals = [];
  const cm = modsOrig.match(/CHECK\s*\(.*?IN\s*\(([^)]+)\)/i);
  if (cm) checkVals = cm[1].split(',').map(v=>v.trim().replace(/^['"]|['"]$/g,''));
  let defaultVal = null;
  const dm = modsOrig.match(/DEFAULT\s+(\S+)/i);
  if (dm) defaultVal = dm[1].replace(/^['"]|['"]$/g,'');
  let fk = null;
  const rm = modsOrig.match(/REFERENCES\s+([\w`"\[\]]+)(?:\s*\(\s*(\w+)\s*\))?/i);
  if (rm) fk = {fk_column:rawName, referenced_table:rm[1].replace(/[\[\]`"]/g,''), referenced_column:rm[2]||'id'};
  let pk = isPK;
  if (mods.includes('IDENTITY') || mods.includes('AUTO_INCREMENT')) pk = true;
  if (['serial','bigserial','smallserial'].includes(rawType)) pk = true;
  return { col: {name:rawName, data_type:ctype, raw_type:typeArgs?`${rawType}(${typeArgs})`:rawType,
    nullable, is_primary_key:pk, is_unique:isUnique, default_value:defaultVal,
    check_constraints:checkVals, precision:prec, scale:scl, max_length:maxl}, fk };
}

function splitDefs(body) {
  const elems = []; let cur = '', depth = 0;
  for (const c of body) {
    if (c==='(') { depth++; cur+=c; } else if (c===')') { depth--; cur+=c; }
    else if (c===',' && depth===0) { elems.push(cur); cur=''; } else cur+=c;
  }
  if (cur) elems.push(cur);
  return elems;
}

function extractParensList(el) {
  const m = el.match(/\(([^)]+)\)/);
  return m ? m[1].split(',').map(n=>n.trim().replace(/[\[\]`"]/g,'')) : [];
}

function parseJSON(content, sourceName) {
  let data;
  try { data = JSON.parse(content.trim()); } catch(e) { return {source_name:sourceName||'JSON',source_type:'json',tables:[],input_format:'json',parse_warnings:['Invalid JSON: '+e.message]}; }
  // Detect dependency graph format (sessions + dependency_edges + table_index)
  if (data.sessions && (data.dependency_edges || data.table_index)) return parseDependencyGraph(data, sourceName);
  const src = data.tables || data.models || (Array.isArray(data) ? data : []);
  const tables = (Array.isArray(src) ? src : Object.values(src)).map(t => {
    if (!t || typeof t !== 'object') return null;
    const cols = (t.columns||[]).map(c => {
      if (typeof c === 'string') { const p = c.split(':'); return {name:p[0].trim(), data_type:p[1]?p[1].trim():'varchar', raw_type:p[1]||'varchar', nullable:true, is_primary_key:false, is_unique:false, check_constraints:[], max_length:null, precision:null, scale:null, default_value:null}; }
      return {name:c.name||c.column_name||'', data_type:c.type||c.data_type||'varchar', raw_type:c.type||c.data_type||'varchar', nullable:c.nullable!==false, is_primary_key:!!c.pk||!!c.primary_key||!!c.is_primary_key, is_unique:false, check_constraints:c.values||c.allowed_values||[], max_length:c.length||c.max_length||null, precision:null, scale:null, default_value:null};
    });
    const fks = (t.foreign_keys||t.fks||[]).map(fk=>({fk_column:fk.column||'', referenced_table:fk.references||fk.referenced_table||'', referenced_column:fk.references_column||fk.referenced_column||'id'}));
    return {name:t.name||'', schema:t.schema||'dbo', columns:cols, foreign_keys:fks, row_count:1000};
  }).filter(Boolean);
  return {source_name:data.name||sourceName||'JSON Import', source_type:data.type||'json', tables, input_format:'json', parse_warnings:[]};
}

// ================================================================
// PARSERS — Dependency Graph JSON (session lineage + table dependencies)
// ================================================================
function parseDependencyGraph(data, sourceName) {
  const tables = [], warnings = [];
  const sessions = data.sessions || {};
  const edges = data.dependency_edges || [];
  const order = data.recommended_order || [];
  const conflicts = data.conflicts || [];
  const sessionNames = Object.keys(sessions);

  // Collect all unique tables across all sessions
  const allTables = {};
  for (const [sName, sess] of Object.entries(sessions)) {
    (sess.source_tables||[]).forEach(t => {
      const key = t.name;
      if (!allTables[key]) allTables[key] = {name:t.name, schema:t.schema||'', roles:new Set(), sessions:new Set()};
      allTables[key].roles.add('source');
      allTables[key].sessions.add(sName);
    });
    (sess.target_tables||[]).forEach(t => {
      const key = t.name;
      if (!allTables[key]) allTables[key] = {name:t.name, schema:t.schema||t.load_type||'', roles:new Set(), sessions:new Set()};
      allTables[key].roles.add('target');
      allTables[key].sessions.add(sName);
    });
    (sess.lookup_tables||[]).forEach(t => {
      const key = t.name;
      if (!allTables[key]) allTables[key] = {name:t.name, schema:t.schema||'', roles:new Set(), sessions:new Set()};
      allTables[key].roles.add('lookup');
      allTables[key].sessions.add(sName);
    });
  }

  // Build sessions inventory table
  const sessionStates = sessionNames.map(s => {
    const sess = sessions[s];
    return {name:s, sources:(sess.source_tables||[]).length, targets:(sess.target_tables||[]).length, lookups:(sess.lookup_tables||[]).length};
  });
  const allSessionNames = sessionNames.slice(0,50);
  tables.push({name:'etl_sessions', schema:'dependency_graph', row_count:sessionNames.length, columns:[
    {name:'session_name',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:true,is_unique:true,check_constraints:allSessionNames,max_length:200,precision:null,scale:null,default_value:null},
    {name:'source_table_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null},
    {name:'target_table_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null},
    {name:'lookup_table_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null},
    {name:'execution_order',data_type:'int',raw_type:'int',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}
  ], foreign_keys:[]});

  // Build tables inventory
  const tableNames = Object.keys(allTables);
  const roleValues = ['source','target','lookup'];
  tables.push({name:'etl_tables', schema:'dependency_graph', row_count:tableNames.length, columns:[
    {name:'table_name',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
    {name:'schema_name',data_type:'varchar',raw_type:'string',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:100,precision:null,scale:null,default_value:null},
    {name:'role',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:roleValues,max_length:20,precision:null,scale:null,default_value:null},
    {name:'session_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}
  ], foreign_keys:[]});

  // Build dependency edges table
  if (edges.length) {
    tables.push({name:'dependency_edges', schema:'dependency_graph', row_count:edges.length, columns:[
      {name:'edge_id',data_type:'int',raw_type:'int',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null},
      {name:'upstream_session',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'downstream_session',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'via_table',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null}
    ], foreign_keys:[
      {fk_column:'upstream_session',referenced_table:'etl_sessions',referenced_column:'session_name'},
      {fk_column:'downstream_session',referenced_table:'etl_sessions',referenced_column:'session_name'}
    ]});
  }

  // Build conflicts table
  if (conflicts.length) {
    const conflictTypes = [...new Set(conflicts.map(c=>c.conflict_type))];
    tables.push({name:'etl_conflicts', schema:'dependency_graph', row_count:conflicts.length, columns:[
      {name:'conflict_id',data_type:'int',raw_type:'int',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null},
      {name:'table_name',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'conflict_type',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:conflictTypes,max_length:50,precision:null,scale:null,default_value:null},
      {name:'writer_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null},
      {name:'reader_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}
    ], foreign_keys:[]});
  }

  if (conflicts.length) warnings.push(`${conflicts.length} conflicts detected: ${conflicts.map(c=>c.table_name+' ('+c.conflict_type+')').join(', ')}`);

  const result = {
    source_name: sourceName || 'Dependency Graph',
    source_type: 'dependency_graph',
    tables, input_format: 'dependency_json',
    parse_warnings: warnings
  };
  // Store dependency metadata for tier diagram
  result._dependency = {sessions: sessionStates, edges, order, conflicts, allTables, rawSessions: sessions};
  return result;
}

function parseXML(content, sourceName) {
  let doc;
  try { doc = new DOMParser().parseFromString(content, 'text/xml'); } catch(e) { return {source_name:sourceName||'XML',source_type:'xml',tables:[],input_format:'xml',parse_warnings:['Invalid XML: '+e.message]}; }
  // Check for parse errors
  const parseErr = doc.querySelector('parsererror');
  if (parseErr) return {source_name:sourceName||'XML',source_type:'xml',tables:[],input_format:'xml',parse_warnings:['XML parse error: '+parseErr.textContent.substring(0,200)]};
  const tables = [];
  function getAttrCI(el, names) { for (const n of names) { const v = el.getAttribute(n); if (v) return v; } return ''; }
  function isBoolTrue(v) { return ['true','yes','1','y'].includes((v||'').toLowerCase()); }
  // Find table elements (case-insensitive, namespace-aware)
  const allEls = doc.querySelectorAll('*');
  const tableEls = [...allEls].filter(el => el.localName.toLowerCase() === 'table');
  tableEls.forEach(te => {
    const name = getAttrCI(te, ['name','Name','NAME']); if (!name) return;
    const cols = [], fks = [];
    const colEls = [...te.querySelectorAll('*')].filter(el => el.localName.toLowerCase() === 'column');
    colEls.forEach(ce => {
      const cn = getAttrCI(ce, ['name','Name','NAME']); if (!cn) return;
      const rt = getAttrCI(ce, ['type','Type','TYPE','dataType','datatype','DATATYPE'])||'varchar';
      const dtRaw = rt.toLowerCase().split('(')[0];
      const dt = TYPE_NORM[dtRaw] || dtRaw;
      const nullable = !['false','no','0'].includes((getAttrCI(ce, ['nullable','Nullable','NULLABLE'])||'true').toLowerCase());
      const pk = isBoolTrue(getAttrCI(ce, ['primaryKey','pk','PK','primary_key','isPrimaryKey','KEYTYPE']));
      const ml = getAttrCI(ce, ['length','Length','LENGTH','maxLength','PRECISION']);
      const checkStr = getAttrCI(ce, ['check','values','Values','CHECK','accepted_values'])||'';
      const checks = checkStr ? checkStr.split(',').map(v=>v.trim()).filter(Boolean) : [];
      cols.push({name:cn, data_type:dt, raw_type:rt, nullable, is_primary_key:pk, is_unique:false, check_constraints:checks, max_length:ml?parseInt(ml)||null:null, precision:null, scale:null, default_value:null});
      const ref = getAttrCI(ce, ['references','References','REFERENCES']);
      if (ref) { const r = parseRefStr(cn, ref); if (r) fks.push(r); }
    });
    const fkEls = [...te.querySelectorAll('*')].filter(el => ['foreignkey','foreign_key','fk'].includes(el.localName.toLowerCase()));
    fkEls.forEach(fe => {
      const col = getAttrCI(fe, ['column','Column','COLUMN'])||'';
      const ref = getAttrCI(fe, ['references','References','REFERENCES'])||'';
      if (col && ref) { const r = parseRefStr(col, ref); if (r) fks.push(r); }
    });
    tables.push({name, schema:getAttrCI(te, ['schema','Schema','SCHEMA'])||'dbo', columns:cols, foreign_keys:fks, row_count:1000});
  });
  return {source_name:sourceName||'XML Import', source_type:'xml', tables, input_format:'xml', parse_warnings:[]};
}

function parseRefStr(fkCol, refStr) {
  const m = refStr.match(/^(\w+)\((\w+)\)$/);
  if (m) return {fk_column:fkCol, referenced_table:m[1], referenced_column:m[2]};
  if (refStr.includes('.')) { const p = refStr.split('.'); return {fk_column:fkCol, referenced_table:p[0], referenced_column:p[1]}; }
  return {fk_column:fkCol, referenced_table:refStr.trim(), referenced_column:'id'};
}

function splitCSVLine(line) {
  const fields = [];
  let current = '', inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const c = line[i];
    if (c === '"') {
      if (inQuotes && line[i+1] === '"') { current += '"'; i++; }
      else inQuotes = !inQuotes;
    } else if (c === ',' && !inQuotes) { fields.push(current.trim()); current = ''; }
    else if (c === '\r') { /* skip */ }
    else current += c;
  }
  fields.push(current.trim());
  return fields;
}

function parseCSV(content, sourceName) {
  const lines = content.trim().split('\n');
  if (lines.length < 2) return {source_name:sourceName, source_type:'csv', tables:[], input_format:'csv', parse_warnings:['No data rows']};
  const headers = splitCSVLine(lines[0]).map(h=>h.toLowerCase());
  const findH = (syns) => { for (const s of syns) { const i = headers.indexOf(s); if (i>=0) return i; } return -1; };
  const iTT = findH(['target_table','tgt_table','to_table','dest_table','source_table','src_table']);
  const iTC = findH(['target_column','tgt_column','to_column','dest_column','source_column','src_column']);
  const iType = findH(['target_type','tgt_type','source_type','src_type','data_type','type']);
  const iPK = findH(['primary_key','pk','is_pk']);
  const iNull = findH(['nullable','is_nullable','null']);
  const iFKT = findH(['foreign_key_table','fk_table','ref_table','references_table']);
  const iFKC = findH(['foreign_key_column','fk_column','ref_column','references_column']);
  const tablesMap = {};
  for (let r = 1; r < lines.length; r++) {
    const vals = splitCSVLine(lines[r]);
    const tbl = iTT>=0?vals[iTT]:''; const col = iTC>=0?vals[iTC]:'';
    if (!tbl||!col) continue;
    if (!tablesMap[tbl]) tablesMap[tbl] = {columns:[], foreign_keys:[]};
    const dtype = (iType>=0?vals[iType]:'varchar').toLowerCase().split('(')[0];
    const nullable = iNull>=0 ? !['false','no','0'].includes(vals[iNull].toLowerCase()) : true;
    const pk = iPK>=0 ? ['true','yes','1','pk'].includes(vals[iPK].toLowerCase()) : false;
    tablesMap[tbl].columns.push({name:col, data_type:dtype, raw_type:iType>=0?vals[iType]:'varchar', nullable, is_primary_key:pk, is_unique:false, check_constraints:[], max_length:null, precision:null, scale:null, default_value:null});
    const fkTbl = iFKT>=0?vals[iFKT]:''; const fkCol = iFKC>=0?vals[iFKC]:'id';
    if (fkTbl) tablesMap[tbl].foreign_keys.push({fk_column:col, referenced_table:fkTbl, referenced_column:fkCol});
  }
  const tables = Object.entries(tablesMap).map(([n,d])=>({name:n, schema:'dbo', columns:d.columns, foreign_keys:d.foreign_keys, row_count:1000}));
  return {source_name:sourceName||'CSV Import', source_type:'csv', tables, input_format:'csv', parse_warnings:[]};
}

// ================================================================
// PARSERS — YAML (table definitions + dbt schema.yml)
// ================================================================
function parseSimpleYAML(text) {
  // Normalize tabs to 2 spaces and strip inline comments
  let normalized = text.replace(/\t/g, '  ');
  const lines = normalized.split('\n').map((l,i) => {
    // Strip inline comments (outside quotes)
    let tr = l.replace(/\s+#(?![^'"]*['"][^'"]*$).*$/, '').trimEnd();
    const ind = tr.search(/\S/) < 0 ? 999 : tr.search(/\S/);
    return {raw:l, ind, tr:tr.trim(), i};
  }).filter(l=>l.tr&&!l.tr.startsWith('#'));
  let pos = 0;
  function scalar(s) { s=s.trim(); if(s==='true')return true; if(s==='false')return false; if(s==='null'||s==='~'||!s)return null; if(/^-?\d+$/.test(s))return parseInt(s); if(/^-?\d+\.\d+$/.test(s))return parseFloat(s); return s.replace(/^['"]|['"]$/g,''); }
  function parseAt(base) {
    if(pos>=lines.length)return null;
    return lines[pos].tr.startsWith('-')?parseList(base):parseMap(base);
  }
  function parseMap(base) {
    const r={}; while(pos<lines.length&&lines[pos].ind>=base) {
      if(lines[pos].ind>base||lines[pos].tr.startsWith('-'))break;
      const ci=lines[pos].tr.indexOf(':'); if(ci<0){pos++;continue;}
      const k=lines[pos].tr.substring(0,ci).trim(), v=lines[pos].tr.substring(ci+1).trim(); pos++;
      if(v) r[k]=scalar(v); else if(pos<lines.length&&lines[pos].ind>base) r[k]=parseAt(lines[pos].ind); else r[k]=null;
    } return r;
  }
  function parseList(base) {
    const r=[]; while(pos<lines.length&&lines[pos].ind>=base) {
      if(lines[pos].ind>base&&!lines[pos].tr.startsWith('-'))break;
      if(!lines[pos].tr.startsWith('-'))break;
      const item=lines[pos].tr.substring(lines[pos].tr.indexOf('-')+1).trim();
      const itemInd=lines[pos].ind; pos++;
      if(item.includes(':')) {
        const obj={}; const ci=item.indexOf(':'); const k=item.substring(0,ci).trim(); const v=item.substring(ci+1).trim();
        if(v) obj[k]=scalar(v); else if(pos<lines.length&&lines[pos].ind>itemInd) obj[k]=parseAt(lines[pos].ind); else obj[k]=null;
        while(pos<lines.length&&lines[pos].ind>itemInd&&!lines[pos].tr.startsWith('-')) {
          const ci2=lines[pos].tr.indexOf(':'); if(ci2<0)break;
          const k2=lines[pos].tr.substring(0,ci2).trim(), v2=lines[pos].tr.substring(ci2+1).trim();
          const curInd=lines[pos].ind; pos++;
          if(v2) obj[k2]=scalar(v2); else if(pos<lines.length&&lines[pos].ind>curInd) obj[k2]=parseAt(lines[pos].ind); else obj[k2]=null;
        } r.push(obj);
      } else { r.push(item?scalar(item):null); }
    } return r;
  }
  if(!lines.length)return {}; return parseAt(lines[0].ind);
}

function parseYAML(content, sourceName) {
  const data = parseSimpleYAML(content);
  const tables = [];
  const src = data.tables || data.models || data.sources || [];
  if (!Array.isArray(src)) return {source_name:sourceName||'YAML',source_type:'yaml',tables:[],input_format:'yaml',parse_warnings:['No tables/models found']};
  src.forEach(t => {
    if (!t || !t.name) return;
    const cols = (t.columns||[]).map(c => {
      if (typeof c === 'string') { const p=c.split(':'); return {name:p[0].trim(),data_type:p[1]?p[1].trim():'varchar',raw_type:p[1]||'varchar',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}; }
      const dt = (c.type||c.data_type||'varchar').toLowerCase().split('(')[0];
      const pk = !!c.primary_key||!!c.pk||(Array.isArray(c.tests)&&(c.tests.includes('unique')||c.tests.includes('not_null')));
      return {name:c.name||'',data_type:TYPE_NORM[dt]||dt,raw_type:c.type||c.data_type||'varchar',nullable:c.nullable!==false,is_primary_key:pk,is_unique:false,check_constraints:c.accepted_values||[],max_length:c.length||null,precision:null,scale:null,default_value:null};
    });
    const fks = (t.foreign_keys||[]).map(fk=>({fk_column:fk.column||'',referenced_table:fk.references||fk.ref||'',referenced_column:fk.references_column||fk.ref_column||'id'}));
    tables.push({name:t.name,schema:t.schema||'dbo',columns:cols,foreign_keys:fks,row_count:1000});
  });
  return {source_name:sourceName||'YAML Import',source_type:'yaml',tables,input_format:'yaml',parse_warnings:[]};
}

// ================================================================
// PARSERS — PySpark (StructType / StructField)
// ================================================================
function parsePySpark(content, sourceName) {
  const tables = [], warnings = [];
  const sparkTypeMap = {string:'varchar',integer:'int',long:'bigint',short:'smallint',byte:'tinyint',float:'float',double:'double',decimal:'decimal',boolean:'boolean',date:'date',timestamp:'timestamp',binary:'binary',array:'text',map:'text',struct:'text',int:'int'};
  const stPat = /(?:(\w+)\s*=\s*)?StructType\s*\(\s*\[([\s\S]*?)\]\s*\)/g;
  let m;
  while ((m=stPat.exec(content))!==null) {
    const varName = m[1]||'table'; const body = m[2]; const cols = [];
    // Flexible: handles StringType() or StringType or "string" — with or without Type suffix
    const fPat = /StructField\s*\(\s*["']([^"']+)["']\s*,\s*(?:["'])?(\w+?)(?:Type)?(?:["'])?\s*(?:\(\s*(?:(\d+)(?:\s*,\s*(\d+))?)?\s*\))?\s*(?:,\s*(True|False|true|false))?\s*\)/g;
    let fm;
    while ((fm=fPat.exec(body))!==null) {
      const dt = sparkTypeMap[fm[2].toLowerCase()]||'varchar';
      cols.push({name:fm[1],data_type:dt,raw_type:fm[2]+'Type',nullable:fm[5]?fm[5].toLowerCase()!=='false':true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:fm[3]?parseInt(fm[3]):null,scale:fm[4]?parseInt(fm[4]):null,default_value:null});
    }
    if (cols.length) { const tn=varName.replace(/_?schema$/i,'')||'table'; tables.push({name:tn,schema:'default',columns:cols,foreign_keys:[],row_count:1000}); }
  }
  // Also try spark.sql("CREATE TABLE ...")
  const sqlM = content.match(/spark\.sql\s*\(\s*["']{1,3}([\s\S]*?)["']{1,3}\s*\)/);
  if (sqlM && /CREATE\s+TABLE/i.test(sqlM[1])) { const ddl = parseDDL(sqlM[1],'PySpark SQL'); tables.push(...ddl.tables); }
  return {source_name:sourceName||'PySpark Schema',source_type:'pyspark',tables,input_format:'pyspark',parse_warnings:warnings};
}

// ================================================================
// PARSERS — Scala (case class)
// ================================================================
function parseScala(content, sourceName) {
  const tables = [];
  const scalaTypeMap = {String:'varchar',Int:'int',Long:'bigint',Short:'smallint',Double:'double',Float:'float',BigDecimal:'decimal',Boolean:'boolean',Date:'date',Timestamp:'timestamp',Byte:'tinyint',Char:'char',Array:'text',List:'text',Seq:'text',Set:'text',Map:'text',Vector:'text',UUID:'varchar'};
  // Handle generic type params: case class Foo[T](...) — skip the [T] part
  const ccPat = /case\s+class\s+(\w+)(?:\[[\w\s,<>\[\]]+\])?\s*\(([\s\S]*?)\)/g;
  let m;
  while ((m=ccPat.exec(content))!==null) {
    const className = m[1]; const body = m[2]; const cols = [];
    const fPat = /(\w+)\s*:\s*(Option\s*\[\s*)?([\w.\[\],\s]+)\]?\s*/g;
    let fm;
    while ((fm=fPat.exec(body))!==null) {
      const nullable = !!fm[2]; let st = fm[3].trim().replace(/\s/g,'');
      // Extract inner type from generics: List[String] → String, Map[String,Int] → text
      if (/^(List|Seq|Set|Vector|Array)\[/.test(st)) st = 'Array';
      else if (/^Map\[/.test(st)) st = 'Map';
      else if (/^Option\[/.test(st)) { const inner = st.match(/^Option\[(\w+)\]/); if(inner) st = inner[1]; }
      // Smart CamelCase: HTTPServer → http_server, not h_t_t_p_server
      const dt = scalaTypeMap[st] || scalaTypeMap[st.replace(/.*\./, '')] || 'varchar';
      cols.push({name:fm[1],data_type:dt,raw_type:st,nullable,is_primary_key:fm[1].toLowerCase()==='id',is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null});
    }
    if (cols.length) {
      const tn = className.replace(/([A-Z]+)([A-Z][a-z])/g,'$1_$2').replace(/([a-z])([A-Z])/g,'$1_$2').toLowerCase();
      tables.push({name:tn,schema:'default',columns:cols,foreign_keys:[],row_count:1000});
    }
  }
  return {source_name:sourceName||'Scala Case Classes',source_type:'scala',tables,input_format:'scala',parse_warnings:[]};
}

// ================================================================
// PARSERS — dbt (model SQL with Jinja)
// ================================================================
function parseDBT(content, sourceName) {
  const tables = [], warnings = [];
  const refs = [];
  const refPat = /\{\{\s*(?:ref|source)\s*\(\s*['"](\w+)['"](?:\s*,\s*['"](\w+)['"])?\s*\)\s*\}\}/g;
  let rm; while ((rm=refPat.exec(content))!==null) refs.push(rm[2]||rm[1]);
  let cleanSQL = content.replace(/\{\{[\s\S]*?\}\}/g,'__JINJA__').replace(/\{%[\s\S]*?%\}/g,'');
  // Strip window functions OVER(...) before column extraction
  cleanSQL = cleanSQL.replace(/\bOVER\s*\([^)]*\)/gi, '');
  if (/CREATE\s+TABLE/i.test(cleanSQL)) return parseDDL(cleanSQL.replace(/__JINJA__/g,'dual'), sourceName||'dbt Model');
  // Handle CTEs: WITH cte AS (SELECT ...) SELECT ... — use the final SELECT
  let selectSQL = cleanSQL;
  const cteMatch = cleanSQL.match(/\bWITH\b[\s\S]*?\)\s*(SELECT[\s\S]*$)/i);
  if (cteMatch) selectSQL = cteMatch[1];
  const selM = selectSQL.match(/SELECT\s+([\s\S]*?)\s+FROM/i);
  if (selM) {
    const cols = []; const parts = selM[1].split(',').map(c=>c.trim()).filter(Boolean);
    for (const p of parts) {
      if (p==='*' || p==='__JINJA__') continue;
      const asM = p.match(/(?:AS\s+)?["']?(\w+)["']?\s*$/i); if (!asM) continue;
      let dt = 'varchar'; const castM = p.match(/(?:CAST\s*\(.*?AS\s+(\w+)|::(\w+))/i);
      if (castM) dt = (castM[1]||castM[2]).toLowerCase();
      cols.push({name:asM[1],data_type:TYPE_NORM[dt]||dt,raw_type:dt,nullable:true,is_primary_key:cols.length===0&&asM[1].toLowerCase().endsWith('_id'),is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null});
    }
    if (cols.length) { const cfgM=content.match(/alias\s*=\s*['"](\w+)['"]/); tables.push({name:cfgM?cfgM[1]:'dbt_model',schema:'dbt',columns:cols,foreign_keys:[],row_count:1000}); }
  }
  return {source_name:sourceName||'dbt Model',source_type:'dbt',tables,input_format:'dbt',parse_warnings:refs.length?['References: '+refs.join(', ')]:warnings};
}

// ================================================================
// PARSERS — Avro (.avsc)
// ================================================================
function avroTypeMap(t) {
  const m={null:'varchar',boolean:'boolean',int:'int',long:'bigint',float:'float',double:'double',bytes:'binary',string:'varchar',fixed:'binary',enum:'varchar',array:'text',map:'text',record:'text',decimal:'decimal',date:'date','time-millis':'int','timestamp-millis':'timestamp','timestamp-micros':'timestamp',uuid:'varchar'};
  return m[t]||'varchar';
}
function parseAvro(content, sourceName) {
  let data; try { data = JSON.parse(content.trim()); } catch(e) { return {source_name:sourceName||'Avro',source_type:'avro',tables:[],input_format:'avro',parse_warnings:['Invalid JSON in Avro: '+e.message]}; }
  const tables = [];
  function parseRecord(rec) {
    if (!rec||rec.type!=='record'||!rec.fields) return null;
    const cols = rec.fields.map(f => {
      let dt='varchar',nullable=false,raw='';
      if (typeof f.type==='string') { raw=f.type; dt=avroTypeMap(f.type); }
      else if (Array.isArray(f.type)) { nullable=f.type.includes('null'); const nn=f.type.filter(t=>t!=='null')[0]; raw=typeof nn==='string'?nn:JSON.stringify(nn); dt=typeof nn==='string'?avroTypeMap(nn):avroTypeMap((nn&&nn.logicalType)||nn?.type||'string'); }
      else if (typeof f.type==='object') { raw=f.type.logicalType||f.type.type||'string'; dt=avroTypeMap(f.type.logicalType||f.type.type); }
      return {name:f.name,data_type:dt,raw_type:raw,nullable,is_primary_key:/^(id|key)$/i.test(f.name),is_unique:false,check_constraints:[],max_length:null,precision:f.type?.precision||null,scale:f.type?.scale||null,default_value:f.default??null};
    });
    const tn=rec.name.replace(/([A-Z])/g,'_$1').toLowerCase().replace(/^_/,'');
    return {name:tn,schema:rec.namespace||'default',columns:cols,foreign_keys:[],row_count:1000};
  }
  if (data.type==='record') { const t=parseRecord(data); if(t)tables.push(t); }
  else if (Array.isArray(data)) data.forEach(d=>{const t=parseRecord(d);if(t)tables.push(t);});
  return {source_name:sourceName||'Avro Schema',source_type:'avro',tables,input_format:'avro',parse_warnings:[]};
}

// ================================================================
// PARSERS — Protobuf (.proto)
// ================================================================
function parseProtobuf(content, sourceName) {
  const tables = [];
  const protoTypeMap={double:'double',float:'float',int32:'int',int64:'bigint',uint32:'int',uint64:'bigint',sint32:'int',sint64:'bigint',fixed32:'int',fixed64:'bigint',sfixed32:'int',sfixed64:'bigint',bool:'boolean',string:'varchar',bytes:'binary'};
  // Strip comments
  let clean = content.replace(/\/\*[\s\S]*?\*\//g, ' ').replace(/\/\/[^\n]*/g, '');
  // Depth-aware message extraction to handle nested messages
  function extractMessages(src, prefix) {
    const msgPat = /message\s+(\w+)\s*\{/g;
    let mm;
    while ((mm=msgPat.exec(src))!==null) {
      const msgName = mm[1]; let depth=1, i=mm.index+mm[0].length;
      while (i < src.length && depth > 0) { if(src[i]==='{')depth++; else if(src[i]==='}')depth--; i++; }
      const body = src.substring(mm.index+mm[0].length, i-1);
      const cols = [];
      // Parse fields including map<K,V>
      const fPat = /(?:(optional|required|repeated)\s+)?(?:map\s*<\s*\w+\s*,\s*\w+\s*>|(\w+))\s+(\w+)\s*=\s*\d+/g;
      let fm;
      while ((fm=fPat.exec(body))!==null) {
        if (fm[0].includes('map<')) {
          cols.push({name:fm[3],data_type:'text',raw_type:'map',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null});
        } else if (fm[2] && !['message','enum','oneof','option','reserved','extensions'].includes(fm[2])) {
          cols.push({name:fm[3],data_type:protoTypeMap[fm[2]]||'varchar',raw_type:fm[2],nullable:fm[1]!=='required',is_primary_key:fm[3].toLowerCase()==='id',is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null});
        }
      }
      // Extract oneof fields
      const oneofPat = /oneof\s+\w+\s*\{([\s\S]*?)\}/g;
      let om;
      while ((om=oneofPat.exec(body))!==null) {
        const ofPat = /(\w+)\s+(\w+)\s*=\s*\d+/g; let ofm;
        while ((ofm=ofPat.exec(om[1]))!==null) {
          cols.push({name:ofm[2],data_type:protoTypeMap[ofm[1]]||'varchar',raw_type:ofm[1],nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null});
        }
      }
      // Extract enum values as check constraints
      const enumPat = /enum\s+(\w+)\s*\{([\s\S]*?)\}/g;
      let em;
      while ((em=enumPat.exec(body))!==null) {
        const enumVals = []; const evPat = /(\w+)\s*=\s*\d+/g; let evm;
        while ((evm=evPat.exec(em[2]))!==null) enumVals.push(evm[1]);
        const enumCol = cols.find(c=>c.raw_type.toLowerCase()===em[1].toLowerCase());
        if (enumCol) enumCol.check_constraints = enumVals;
      }
      if (cols.length) {
        const fullName = prefix ? prefix+'_'+msgName : msgName;
        const tn = fullName.replace(/([A-Z]+)([A-Z][a-z])/g,'$1_$2').replace(/([a-z])([A-Z])/g,'$1_$2').toLowerCase();
        tables.push({name:tn,schema:'default',columns:cols,foreign_keys:[],row_count:1000});
      }
      // Recurse for nested messages
      extractMessages(body, prefix ? prefix+'_'+msgName : msgName);
    }
  }
  extractMessages(clean, '');
  return {source_name:sourceName||'Protobuf Schema',source_type:'protobuf',tables,input_format:'protobuf',parse_warnings:[]};
}

// ================================================================
// PARSERS — Spark printSchema output
// ================================================================
function parseSparkSchema(content, sourceName) {
  const cols = [];
  const fPat = /\|--\s+(\w+):\s+(\w+)(?:\(([^)]*)\))?\s*\(nullable\s*=\s*(true|false)\)/g;
  let m;
  while ((m=fPat.exec(content))!==null) {
    const sparkMap={string:'varchar',integer:'int',long:'bigint',short:'smallint',byte:'tinyint',float:'float',double:'double',decimal:'decimal',boolean:'boolean',date:'date',timestamp:'timestamp',binary:'binary'};
    cols.push({name:m[1],data_type:sparkMap[m[2]]||'varchar',raw_type:m[2]+(m[3]?`(${m[3]})`:''),nullable:m[4]==='true',is_primary_key:m[1]==='id',is_unique:false,check_constraints:[],max_length:null,precision:m[3]?parseInt(m[3].split(',')[0]):null,scale:m[3]&&m[3].includes(',')?parseInt(m[3].split(',')[1]):null,default_value:null});
  }
  if (!cols.length) return null;
  return {source_name:sourceName||'Spark Schema',source_type:'spark',tables:[{name:'spark_table',schema:'default',columns:cols,foreign_keys:[],row_count:1000}],input_format:'spark_schema',parse_warnings:[]};
}

// ================================================================
// PARSERS — Informatica XML (PowerCenter / IICS)
// ================================================================
function parseInformaticaXML(doc, sourceName) {
  const tables = [];
  const allEls = [...doc.querySelectorAll('*')];
  function findByLocal(name) { return allEls.filter(el => el.localName.toLowerCase() === name.toLowerCase()); }
  function getAttr(el, names) { for (const n of names) { const v = el.getAttribute(n); if (v != null) return v; } return ''; }
  function parseFields(parent, fieldNames) {
    const cols = [];
    const children = [...parent.querySelectorAll('*')].filter(el => fieldNames.some(fn => el.localName.toLowerCase() === fn));
    children.forEach(sf => {
      const cn = getAttr(sf, ['NAME','name','Name']); if(!cn) return;
      const rt = getAttr(sf, ['DATATYPE','datatype','DataType','type'])||'varchar';
      const prec = parseInt(getAttr(sf, ['PRECISION','precision','Precision'])||'0')||0;
      const scale = parseInt(getAttr(sf, ['SCALE','scale','Scale'])||'0')||0;
      const nullVal = getAttr(sf, ['NULLABLE','nullable','Nullable'])||'NULL';
      const nullable = nullVal !== 'NOTNULL' && nullVal.toLowerCase() !== 'false';
      const keyType = getAttr(sf, ['KEYTYPE','keytype','KeyType'])||'';
      const pk = keyType === 'PRIMARY KEY' || keyType.toLowerCase() === 'primary';
      const dt = TYPE_NORM[rt.toLowerCase()]||rt.toLowerCase().split('(')[0];
      cols.push({name:cn,data_type:dt,raw_type:rt,nullable,is_primary_key:pk,is_unique:false,check_constraints:[],max_length:prec||null,precision:['decimal','numeric','number'].includes(dt)?prec:null,scale:scale||null,default_value:null});
    });
    return cols;
  }
  // Find SOURCE elements (any case, any namespace)
  findByLocal('source').forEach(src => {
    const name = getAttr(src, ['NAME','name','Name']); if(!name) return;
    const cols = parseFields(src, ['sourcefield']);
    if (cols.length) tables.push({name,schema:'dbo',columns:cols,foreign_keys:[],row_count:1000});
  });
  findByLocal('target').forEach(tgt => {
    const name = getAttr(tgt, ['NAME','name','Name']); if(!name) return;
    if (tables.find(t=>t.name===name)) return;
    const cols = parseFields(tgt, ['targetfield']);
    if (cols.length) tables.push({name,schema:'dbo',columns:cols,foreign_keys:[],row_count:1000});
  });
  return {source_name:sourceName||'Informatica Import',source_type:'informatica',tables,input_format:'informatica_xml',parse_warnings:[]};
}

// ================================================================
// PARSERS — Talend XML
// ================================================================
function parseTalendXML(doc, sourceName) {
  const tables = [];
  const talendTypeMap = {id_String:'varchar',id_Integer:'int',id_Long:'bigint',id_Short:'smallint',id_Byte:'tinyint',id_Float:'float',id_Double:'double',id_BigDecimal:'decimal',id_Boolean:'boolean',id_Date:'date',id_Character:'char',id_byte_array:'binary',id_Object:'text',id_List:'text',id_Document:'text',id_Dynamic:'text'};
  doc.querySelectorAll('schema, Schema, metadata').forEach(schema => {
    const name = schema.getAttribute('name')||schema.getAttribute('Name')||schema.getAttribute('label')||'talend_table';
    const cols = [];
    schema.querySelectorAll('column, Column').forEach(col => {
      const cn = col.getAttribute('name')||col.getAttribute('label')||''; if(!cn) return;
      const tt = col.getAttribute('type')||col.getAttribute('talendType')||'id_String';
      const length = parseInt(col.getAttribute('length')||'0');
      const nullable = (col.getAttribute('nullable')||'true')!=='false';
      const pk = (col.getAttribute('key')||'false')==='true';
      cols.push({name:cn,data_type:talendTypeMap[tt]||'varchar',raw_type:tt,nullable,is_primary_key:pk,is_unique:false,check_constraints:[],max_length:length||null,precision:null,scale:null,default_value:null});
    });
    if (cols.length) tables.push({name,schema:'dbo',columns:cols,foreign_keys:[],row_count:1000});
  });
  return {source_name:sourceName||'Talend Import',source_type:'talend',tables,input_format:'talend_xml',parse_warnings:[]};
}

// ================================================================
// PARSERS — Apache NiFi XML (template / flow definition)
// ================================================================
function parseNiFiXML(doc, sourceName) {
  const tables = [], processors = [], connections = [], controllerServices = [], processGroups = [];
  const idToName = {};

  // NiFi templates nest everything: template > snippet > processGroups > contents > processors
  // Recursively extract all processors, connections, etc. from nested processGroups
  function extractFromGroup(groupEl, groupName) {
    const contents = groupEl.querySelector(':scope > contents') || groupEl;
    // Processors — direct children of contents
    contents.querySelectorAll(':scope > processors').forEach(proc => {
      const name = getChildText(proc, 'name');
      const type = getChildText(proc, 'type');
      const shortType = type.split('.').pop();
      const state = getChildText(proc, 'state');
      const props = extractProperties(proc);
      const schedPeriod = proc.querySelector('config > schedulingPeriod')?.textContent || '';
      const schedStrategy = proc.querySelector('config > schedulingStrategy')?.textContent || '';
      const id = getChildText(proc, 'id');
      if (id) idToName[id] = name || shortType;
      processors.push({name, type:shortType, fullType:type, state, properties:props, group:groupName, schedulingPeriod:schedPeriod, schedulingStrategy:schedStrategy});
    });
    // Connections — direct children of contents
    contents.querySelectorAll(':scope > connections').forEach(conn => {
      const srcId = conn.querySelector('source > id')?.textContent || getChildText(conn, 'sourceId') || '';
      const dstId = conn.querySelector('destination > id')?.textContent || getChildText(conn, 'destinationId') || '';
      const srcType = conn.querySelector('source > type')?.textContent || '';
      const dstType = conn.querySelector('destination > type')?.textContent || '';
      const rels = [];
      conn.querySelectorAll(':scope > selectedRelationships').forEach(r => { if(r.textContent) rels.push(r.textContent); });
      const bp = getChildText(conn, 'backPressureObjectThreshold');
      connections.push({sourceId:srcId, destinationId:dstId, sourceType:srcType, destinationType:dstType, relationships:rels, backPressure:bp});
    });
    // Input/output ports
    contents.querySelectorAll(':scope > inputPorts').forEach(p => {
      const id = getChildText(p, 'id'), name = getChildText(p, 'name');
      if(id) idToName[id] = name || 'input_port';
    });
    contents.querySelectorAll(':scope > outputPorts').forEach(p => {
      const id = getChildText(p, 'id'), name = getChildText(p, 'name');
      if(id) idToName[id] = name || 'output_port';
    });
    // Nested processGroups
    contents.querySelectorAll(':scope > processGroups').forEach(pg => {
      const pgName = getChildText(pg, 'name');
      const pgId = getChildText(pg, 'id');
      if(pgId) idToName[pgId] = pgName;
      processGroups.push({name:pgName, parentGroup:groupName});
      extractFromGroup(pg, pgName);
    });
  }

  function getChildText(el, tag) {
    const child = el.querySelector(':scope > ' + tag);
    return child ? child.textContent.trim() : '';
  }

  function extractProperties(el) {
    const props = {};
    // NiFi template format: config > properties > entry > key + value
    el.querySelectorAll('config > properties > entry').forEach(entry => {
      const key = entry.querySelector(':scope > key')?.textContent || '';
      const valEl = entry.querySelector(':scope > value');
      if (key && valEl) props[key] = valEl.textContent || '';
    });
    // Also try direct properties > entry (for controllerServices at snippet level)
    if (!Object.keys(props).length) {
      el.querySelectorAll(':scope > properties > entry').forEach(entry => {
        const key = entry.querySelector(':scope > key')?.textContent || '';
        const valEl = entry.querySelector(':scope > value');
        if (key && valEl) props[key] = valEl.textContent || '';
      });
    }
    return props;
  }

  // Start from snippet (template format), flowController (NiFi registry), or root
  const snippet = doc.querySelector('template > snippet') || doc.querySelector('snippet') ||
    doc.querySelector('flowController > rootGroup') || doc.querySelector('rootGroup') ||
    doc.querySelector('processGroupFlow > flow') || doc.documentElement;

  // Top-level controllerServices
  snippet.querySelectorAll(':scope > controllerServices').forEach(cs => {
    const name = getChildText(cs, 'name');
    const type = getChildText(cs, 'type');
    const state = getChildText(cs, 'state');
    const props = {};
    cs.querySelectorAll(':scope > properties > entry').forEach(entry => {
      const key = entry.querySelector(':scope > key')?.textContent || '';
      const valEl = entry.querySelector(':scope > value');
      if (key && valEl) props[key] = valEl.textContent || '';
    });
    controllerServices.push({name, type:type.split('.').pop(), fullType:type, state, properties:props});
  });

  // Top-level processGroups
  snippet.querySelectorAll(':scope > processGroups').forEach(pg => {
    const pgName = getChildText(pg, 'name');
    const pgId = getChildText(pg, 'id');
    if(pgId) idToName[pgId] = pgName;
    processGroups.push({name:pgName, parentGroup:'(root)'});
    extractFromGroup(pg, pgName);
  });

  // Also check for top-level processors directly in snippet
  snippet.querySelectorAll(':scope > processors').forEach(proc => {
    const name = getChildText(proc, 'name');
    const type = getChildText(proc, 'type');
    const id = getChildText(proc, 'id');
    if(id) idToName[id] = name || type.split('.').pop();
    const props = extractProperties(proc);
    processors.push({name, type:type.split('.').pop(), fullType:type, state:getChildText(proc,'state'), properties:props, group:'(root)', schedulingPeriod:'', schedulingStrategy:''});
  });

  // Resolve connection IDs to processor names
  connections.forEach(c => {
    c.sourceName = idToName[c.sourceId] || c.sourceId.substring(0,12)+'...';
    c.destinationName = idToName[c.destinationId] || c.destinationId.substring(0,12)+'...';
  });

  // Extract SQL and table refs from processor properties
  const sqlTables = new Set();
  processors.forEach(p => {
    Object.values(p.properties).forEach(v => {
      if (!v) return;
      // Try to find CREATE TABLE
      if (/CREATE\s+(?:EXTERNAL\s+)?TABLE/i.test(v)) {
        try { const r = parseDDL(v, p.name); tables.push(...r.tables); } catch(e) {}
      }
      // Extract table name refs from SQL
      const tblRefs = v.match(/(?:FROM|JOIN|INTO|TABLE|UPDATE)\s+(?:\$\{[^}]+\}|[\w.]+)/gi);
      if (tblRefs) tblRefs.forEach(m => {
        const tn = m.replace(/^(FROM|JOIN|INTO|TABLE|UPDATE)\s+/i,'').trim();
        if (tn && !tn.startsWith('(') && tn.length > 2 && !/^(select|where|set|and|or|as|on|in|is|not|null|case|when|then|else|end|group|order|by|having|limit|offset|union|all|exists|between|like|true|false|values|into|for|if|with|from|table|now|production|varchar|int|bigint|text|date|timestamp|decimal|boolean|float|double)$/i.test(tn)) sqlTables.add(tn);
      });
    });
    // Extract table names from specific NiFi properties
    ['Table Name','table-name','put-db-record-table-name'].forEach(k => {
      if (p.properties[k]) sqlTables.add(p.properties[k]);
    });
  });

  // Build NiFi flow inventory tables (always — this IS the synthetic env for a NiFi flow)
  const procTypes = processors.map(p=>p.type).filter((v,i,a)=>a.indexOf(v)===i);
  const procGroups = processors.map(p=>p.group).filter((v,i,a)=>a.indexOf(v)===i);
  const procStates = processors.map(p=>p.state).filter(Boolean).filter((v,i,a)=>a.indexOf(v)===i);

  tables.push({name:'nifi_processors', schema:'nifi_flow', row_count:processors.length, columns:[
    {name:'processor_name',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
    {name:'processor_type',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:procTypes.slice(0,50),max_length:200,precision:null,scale:null,default_value:null},
    {name:'process_group',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:procGroups,max_length:200,precision:null,scale:null,default_value:null},
    {name:'state',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:procStates,max_length:20,precision:null,scale:null,default_value:null},
    {name:'scheduling_strategy',data_type:'varchar',raw_type:'string',nullable:true,is_primary_key:false,is_unique:false,check_constraints:['TIMER_DRIVEN','CRON_DRIVEN','EVENT_DRIVEN'],max_length:30,precision:null,scale:null,default_value:null},
    {name:'scheduling_period',data_type:'varchar',raw_type:'string',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:50,precision:null,scale:null,default_value:null},
    {name:'property_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}
  ], foreign_keys:[]});

  if (connections.length) {
    const relTypes = connections.flatMap(c=>c.relationships).filter((v,i,a)=>a.indexOf(v)===i);
    tables.push({name:'nifi_connections', schema:'nifi_flow', row_count:connections.length, columns:[
      {name:'connection_id',data_type:'int',raw_type:'int',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null},
      {name:'source_processor',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'destination_processor',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'relationship',data_type:'varchar',raw_type:'string',nullable:true,is_primary_key:false,is_unique:false,check_constraints:relTypes.slice(0,20),max_length:100,precision:null,scale:null,default_value:null},
      {name:'back_pressure_threshold',data_type:'int',raw_type:'int',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}
    ], foreign_keys:[{fk_column:'source_processor',referenced_table:'nifi_processors',referenced_column:'processor_name'}]});
  }

  if (processGroups.length) {
    tables.push({name:'nifi_process_groups', schema:'nifi_flow', row_count:processGroups.length, columns:[
      {name:'group_name',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'parent_group',data_type:'varchar',raw_type:'string',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'processor_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null},
      {name:'connection_count',data_type:'int',raw_type:'int',nullable:false,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}
    ], foreign_keys:[]});
  }

  if (controllerServices.length) {
    tables.push({name:'nifi_controller_services', schema:'nifi_flow', row_count:controllerServices.length, columns:[
      {name:'service_name',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'service_type',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:controllerServices.map(s=>s.type).filter((v,i,a)=>a.indexOf(v)===i),max_length:200,precision:null,scale:null,default_value:null},
      {name:'state',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:['ENABLED','DISABLED','ENABLING','DISABLING'],max_length:20,precision:null,scale:null,default_value:null},
      {name:'config_json',data_type:'text',raw_type:'text',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:null,precision:null,scale:null,default_value:null}
    ], foreign_keys:[]});
  }

  // If SQL references found, add a reference table
  if (sqlTables.size) {
    const refs = [...sqlTables];
    tables.push({name:'nifi_sql_table_refs', schema:'nifi_flow', row_count:refs.length, columns:[
      {name:'table_reference',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:true,is_unique:true,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null},
      {name:'reference_type',data_type:'varchar',raw_type:'string',nullable:false,is_primary_key:false,is_unique:false,check_constraints:['table','variable','external_table'],max_length:50,precision:null,scale:null,default_value:null},
      {name:'referenced_by_processor',data_type:'varchar',raw_type:'string',nullable:true,is_primary_key:false,is_unique:false,check_constraints:[],max_length:200,precision:null,scale:null,default_value:null}
    ], foreign_keys:[]});
  }

  const warnings = [];
  if (sqlTables.size) warnings.push(`Found ${sqlTables.size} SQL table references: ${[...sqlTables].slice(0,10).join(', ')}${sqlTables.size>10?'...':''}`);

  const result = {source_name:sourceName||'Apache NiFi Flow', source_type:'nifi', tables, input_format:'nifi_xml', parse_warnings:warnings};
  result._nifi = {processors, connections, controllerServices, processGroups, sqlTables:[...sqlTables]};
  return result;
}

// ================================================================
// SOURCE SYSTEM DETECTION
// ================================================================
function detectSourceSystem(content, fmt) {
  if (fmt==='dependency_json') return {name:'Dependency Graph',type:'ETL Session Lineage',color:'#8B5CF6'};
  if (fmt==='informatica_xml') return {name:'Informatica',type:'ETL & Integration',color:'#FF4A00'};
  if (fmt==='talend_xml') return {name:'Talend',type:'Data Integration',color:'#FF6D70'};
  if (fmt==='nifi_xml') return {name:'Apache NiFi',type:'Flow Definition',color:'#728E9B'};
  if (fmt==='pyspark') return {name:'PySpark / Databricks',type:'Spark Schema',color:'#E25A1C'};
  if (fmt==='scala') return {name:'Scala / Spark',type:'Case Classes',color:'#DC382D'};
  if (fmt==='dbt') return {name:'dbt',type:'Data Transformation',color:'#FF694B'};
  if (fmt==='avro') return {name:'Apache Avro',type:'Schema Registry',color:'#3ECF8E'};
  if (fmt==='protobuf') return {name:'Protobuf',type:'Schema Definition',color:'#3ECF8E'};
  if (fmt==='spark_schema') return {name:'Spark',type:'printSchema Output',color:'#E25A1C'};
  if (fmt==='yaml') return {name:'YAML Schema',type:'Universal',color:'#CB171E'};
  if (fmt==='json') return {name:'JSON Schema',type:'Universal',color:'#000000'};
  if (fmt==='csv') return {name:'CSV Mapping',type:'Universal',color:'#217346'};
  if (fmt==='xml') return {name:'XML Schema',type:'Universal',color:'#0060AC'};
  const c = content || '';
  if (/\bVARCHAR2\b|\bNUMBER\s*\(|\bCLOB\b|\bBINARY_FLOAT\b/i.test(c)) return {name:'Oracle',type:'Database',color:'#F80000'};
  if (/\[\w+\]|\bIDENTITY\s*\(|\bDATETIME2\b|\bUNIQUEIDENTIFIER\b|\bNVARCHAR\b/i.test(c)) return {name:'SQL Server',type:'Microsoft SQL',color:'#CC2927'};
  if (/\bDISTKEY\b|\bSORTKEY\b|\bENCODE\s+(lzo|zstd|raw|bytedict)\b/i.test(c)) return {name:'AWS Redshift',type:'Data Warehouse',color:'#FF9900'};
  if (/\bVARIANT\b|\bCLUSTER\s+BY\b|\bTRANSIENT\s+TABLE\b/i.test(c)) return {name:'Snowflake',type:'Data Cloud',color:'#29B5E8'};
  if (/\bMULTISET\b|\bBYTEINT\b|\bTITLE\s+'/i.test(c)) return {name:'Teradata',type:'Enterprise DW',color:'#F37440'};
  if (/\bCOLUMN\s+TABLE\b|\bCS_STRING\b|\bALPHANUM\b/i.test(c)) return {name:'SAP HANA',type:'ERP / BW',color:'#0FAAFF'};
  if (/\bINT64\b|\bFLOAT64\b|\bSTRUCT\s*</i.test(c)) return {name:'Google BigQuery',type:'Cloud Platform',color:'#4285F4'};
  if (/\bUSING\s+DELTA\b|\bTBLPROPERTIES\b|\bLOCATION\s+'/i.test(c)) return {name:'Databricks',type:'Unity Catalog',color:'#FF3621'};
  if (/\bDISTRIBUTION\s*=\s*(HASH|ROUND_ROBIN|REPLICATE)\b/i.test(c)) return {name:'Azure Synapse',type:'Analytics',color:'#0078D4'};
  if (/\bSERIAL\b|\bBYTEA\b|\bJSONB\b|\bINET\b|\bTSVECTOR\b/i.test(c)) return {name:'PostgreSQL',type:'Database',color:'#4169E1'};
  if (/\bAUTO_INCREMENT\b|\bENGINE\s*=\s*(InnoDB|MyISAM)/i.test(c)) return {name:'MySQL',type:'Database',color:'#4479A1'};
  if (/\bSTORED\s+AS\s+(ORC|PARQUET|TEXTFILE)\b|\bROW\s+FORMAT\b/i.test(c)) return {name:'Apache Hive',type:'Data Warehouse',color:'#FDEE21'};
  return {name:'SQL',type:'Standard DDL',color:'#808495'};
}

// ================================================================
// DEFAULT STATS
// ================================================================
function genStats(col, rowCount) {
  const dt = col.data_type.toLowerCase();
  const s = {null_ratio: col.nullable ? 0.05 : 0.0};
  if (col.check_constraints && col.check_constraints.length) {
    const n = col.check_constraints.length;
    s.top_values = col.check_constraints.map(v=>({value:v, frequency:Math.round(1/n*10000)/10000}));
    s.distinct_count = n; return s;
  }
  if (['int','integer','smallint','tinyint'].includes(dt)) {
    if (col.is_primary_key) Object.assign(s, {min:1,max:rowCount,mean:rowCount/2,stddev:rowCount/6,distinct_count:rowCount});
    else Object.assign(s, {min:1,max:1000,mean:500,stddev:300,distinct_count:Math.min(500,rowCount)});
  } else if (['bigint','long'].includes(dt)) Object.assign(s, {min:1,max:100000,mean:50000,stddev:30000,distinct_count:Math.min(10000,rowCount)});
  else if (['float','double'].includes(dt)) Object.assign(s, {min:0,max:10000,mean:100,stddev:50,distinct_count:rowCount});
  else if (['decimal','numeric'].includes(dt)) { const mx = Math.pow(10,(col.precision||10)-(col.scale||2))-1; Object.assign(s, {min:0,max:mx,mean:mx/10,stddev:mx/20,distinct_count:rowCount}); }
  else if (['varchar','char','text','string'].includes(dt)) Object.assign(s, {min_length:3,max_length:Math.min(col.max_length||50,100),distinct_count:rowCount});
  else if (dt==='date') Object.assign(s, {min:'2020-01-01',max:'2025-12-31',distinct_count:Math.min(rowCount,2000)});
  else if (['timestamp','datetime'].includes(dt)) Object.assign(s, {min:'2020-01-01',max:'2025-12-31',distinct_count:rowCount});
  else if (['boolean','bool'].includes(dt)) { s.top_values=[{value:true,frequency:0.5},{value:false,frequency:0.5}]; s.distinct_count=2; }
  else Object.assign(s, {min_length:5,max_length:20,distinct_count:rowCount});
  return s;
}

// ================================================================
// BLUEPRINT ASSEMBLER
// ================================================================
function assembleBlueprint_fn(parsed) {
  const bid = crypto.randomUUID ? crypto.randomUUID() : 'bp-'+Math.random().toString(36).substring(2,10);
  const tables = parsed.tables.map(pt => {
    const rc = pt.row_count || 1000; // Use actual row count from source parser
    const cols = pt.columns.map(c => ({name:c.name, data_type:c.data_type, nullable:c.nullable, is_primary_key:c.is_primary_key, stats:genStats(c, rc)}));
    const fks = pt.foreign_keys.map(fk => ({column:fk.fk_column, references_table:fk.referenced_table, references_column:fk.referenced_column}));
    return {name:pt.name, schema:pt.schema, row_count:rc, columns:cols, foreign_keys:fks};
  });
  const rels = [];
  parsed.tables.forEach(pt => pt.foreign_keys.forEach(fk => rels.push({from_table:`${pt.schema}.${pt.name}`,to_table:`${pt.schema}.${fk.referenced_table}`,relationship_type:'one_to_many',join_columns:[{from_column:fk.fk_column,to_column:fk.referenced_column}]})));
  return {blueprint_id:bid, source_system:{name:parsed.source_name,type:parsed.source_type}, tables, relationships:rels};
}

// ================================================================
// TIER DIAGRAM — Adaptive Environment Visualization
// ================================================================
const NIFI_ROLE_MAP = {
  // Sources (Tier 1)
  GetFile:'source',GetHTTP:'source',GetSFTP:'source',GetFTP:'source',ConsumeKafka:'source',
  ConsumeKafka_2_6:'source',ConsumeKafkaRecord_2_6:'source',ListenHTTP:'source',
  QueryDatabaseTable:'source',QueryDatabaseTableRecord:'source',GenerateFlowFile:'source',
  GetHDFS:'source',ListS3:'source',FetchS3Object:'source',GetS3Object:'source',
  ListFile:'source',FetchFile:'source',ConsumeJMS:'source',ListenTCP:'source',
  ListenUDP:'source',GetMongo:'source',GetElasticsearch:'source',TailFile:'source',
  // Routing (Tier 2)
  RouteOnAttribute:'route',RouteOnContent:'route',DistributeLoad:'route',ControlRate:'route',
  RouteText:'route',DetectDuplicate:'route',ValidateRecord:'route',
  // Transform (Tier 2)
  UpdateAttribute:'transform',JoltTransformJSON:'transform',ReplaceText:'transform',
  ConvertRecord:'transform',SplitRecord:'transform',MergeContent:'transform',MergeRecord:'transform',
  ExecuteScript:'transform',ExecuteStreamCommand:'transform',ConvertJSONToSQL:'transform',
  TransformXml:'transform',SplitJson:'transform',SplitXml:'transform',SplitText:'transform',
  EvaluateJsonPath:'transform',ExtractText:'transform',CompressContent:'transform',
  EncryptContent:'transform',HashContent:'transform',Base64EncodeContent:'transform',
  ConvertCharacterSet:'transform',FlattenJson:'transform',ConvertAvroToJSON:'transform',
  ConvertJSONToAvro:'transform',
  // Processing (Tier 3)
  ExecuteSQL:'process',ExecuteSQLRecord:'process',PutDatabaseRecord:'process',
  LookupAttribute:'process',LookupRecord:'process',InvokeHTTP:'process',
  ExecuteProcess:'process',HandleHttpRequest:'process',HandleHttpResponse:'process',
  // Sinks (Tier 4)
  PutFile:'sink',PutHDFS:'sink',PutS3Object:'sink',PutSQL:'sink',PutKafka:'sink',
  PutKafkaRecord:'sink',PutEmail:'sink',PutSFTP:'sink',PutFTP:'sink',PublishKafka:'sink',
  PublishKafka_2_6:'sink',PublishKafkaRecord_2_6:'sink',PutMongo:'sink',PutElasticsearch:'sink',
  PutDatabaseRecord:'sink',PutSyslog:'sink',PutTCP:'sink',
  // Utility
  LogMessage:'utility',LogAttribute:'utility',Wait:'utility',Notify:'utility',
  DebugFlow:'utility',CountText:'utility',AttributesToJSON:'utility',
};

function classifyNiFiProcessor(type) {
  return NIFI_ROLE_MAP[type] || (
    /^(Get|List|Consume|Listen|Fetch|Tail|Query)/i.test(type) ? 'source' :
    /^(Put|Publish|Send|Post)/i.test(type) ? 'sink' :
    /^(Route|Distribute|Control|Validate|Detect)/i.test(type) ? 'route' :
    /^(Convert|Split|Merge|Replace|Transform|Extract|Evaluate|Flatten|Compress|Encrypt|Hash)/i.test(type) ? 'transform' :
    /^(Execute|Invoke|Lookup|Handle)/i.test(type) ? 'process' :
    /^(Log|Debug|Count|Wait|Notify)/i.test(type) ? 'utility' :
    'process'
  );
}

// ── NiFi role-tier constants (shared by build + render) ──
const ROLE_TIER_ORDER = ['source', 'route', 'transform', 'process', 'sink', 'utility'];
const ROLE_TIER_COLORS = { source:'#3B82F6', route:'#EAB308', transform:'#A855F7', process:'#6366F1', sink:'#21C354', utility:'#808495' };
const ROLE_TIER_LABELS = {
  source:'SOURCES — Ingestion & Acquisition', route:'ROUTING — Distribution & Validation',
  transform:'TRANSFORMS — Conversion & Enrichment', process:'PROCESSING — Execution & Lookup',
  sink:'SINKS — Output & Delivery', utility:'UTILITY — Logging & Control'
};

// ── NiFi → Databricks processor mapping ──
const NIFI_DATABRICKS_MAP = {
  // SOURCES
  GetFile:{cat:'Auto Loader',tpl:'df_{v} = (spark.readStream\n  .format("cloudFiles")\n  .option("cloudFiles.format", "{format}")\n  .option("cloudFiles.schemaLocation", "/mnt/schema/{v}")\n  .load("/Volumes/{catalog}/{schema}/{path}"))',desc:'Auto Loader from Databricks Volumes',notes:'Configure volume mount path',imp:[],conf:0.85},
  GetHTTP:{cat:'Python Requests',tpl:'import requests\n_resp = requests.get("{url}")\ndf_{v} = spark.createDataFrame([_resp.json()])',desc:'REST API ingestion',notes:'Wrap in UDF for large-scale; add error handling',imp:['import requests'],conf:0.70},
  ConsumeKafka:{cat:'Structured Streaming',tpl:'df_{v} = (spark.readStream\n  .format("kafka")\n  .option("kafka.bootstrap.servers", "{brokers}")\n  .option("subscribe", "{topic}")\n  .load())',desc:'Kafka streaming source',notes:'Configure security protocol if needed',imp:[],conf:0.90},
  ConsumeKafka_2_6:{cat:'Structured Streaming',tpl:'df_{v} = (spark.readStream\n  .format("kafka")\n  .option("kafka.bootstrap.servers", "{brokers}")\n  .option("subscribe", "{topic}")\n  .load())',desc:'Kafka streaming source',notes:'Same as ConsumeKafka',imp:[],conf:0.90},
  ConsumeKafkaRecord_2_6:{cat:'Structured Streaming',tpl:'df_{v} = (spark.readStream\n  .format("kafka")\n  .option("kafka.bootstrap.servers", "{brokers}")\n  .option("subscribe", "{topic}")\n  .load()\n  .select(from_json(col("value").cast("string"), schema).alias("data"))\n  .select("data.*"))',desc:'Kafka record streaming',notes:'Define schema for deserialization',imp:[],conf:0.85},
  QueryDatabaseTable:{cat:'JDBC Source',tpl:'df_{v} = (spark.read\n  .format("jdbc")\n  .option("url", "{url}")\n  .option("dbtable", "{table}")\n  .option("driver", "{driver}")\n  .load())',desc:'JDBC database read',notes:'Store credentials in Databricks secret scope',imp:[],conf:0.90},
  QueryDatabaseTableRecord:{cat:'JDBC Source',tpl:'df_{v} = (spark.read\n  .format("jdbc")\n  .option("url", "{url}")\n  .option("dbtable", "{table}")\n  .load())',desc:'JDBC database read with record',notes:'Same as QueryDatabaseTable',imp:[],conf:0.90},
  ListenHTTP:{cat:'Manual',tpl:'# TODO: No direct equivalent for ListenHTTP\n# Consider: Databricks Model Serving, REST API, or webhook trigger',desc:'HTTP listener endpoint',notes:'No native HTTP server in Databricks — use Model Serving or external trigger',imp:[],conf:0.10},
  GetSFTP:{cat:'External Storage',tpl:'# Copy from SFTP to Volumes\ndbutils.fs.cp("sftp://{host}/{path}", "/Volumes/{catalog}/{schema}/landing/")\ndf_{v} = spark.read.format("{format}").load("/Volumes/{catalog}/{schema}/landing/")',desc:'SFTP file retrieval',notes:'Requires SFTP mount or external transfer utility',imp:[],conf:0.50},
  GetFTP:{cat:'External Storage',tpl:'# Copy from FTP (use external transfer)\ndf_{v} = spark.read.format("{format}").load("/Volumes/{catalog}/{schema}/landing/")',desc:'FTP file retrieval',notes:'No native FTP; use external transfer tool',imp:[],conf:0.40},
  GenerateFlowFile:{cat:'Test Data',tpl:'df_{v} = spark.range({count}).toDF("id")\n# Add test columns as needed',desc:'Test data generator',notes:'Replace with actual test data generation',imp:[],conf:0.60},
  ListS3:{cat:'Cloud Storage',tpl:'files = dbutils.fs.ls("s3://{bucket}/{prefix}")\ndf_{v} = spark.createDataFrame(files)',desc:'List S3 objects',notes:'Use Unity Catalog external locations',imp:[],conf:0.85},
  FetchS3Object:{cat:'Cloud Storage',tpl:'df_{v} = spark.read.format("{format}").load("s3://{bucket}/{key}")',desc:'Read S3 object',notes:'Configure external location in Unity Catalog',imp:[],conf:0.85},
  GetS3Object:{cat:'Cloud Storage',tpl:'df_{v} = spark.read.format("{format}").load("s3://{bucket}/{key}")',desc:'Read S3 object',notes:'Same as FetchS3Object',imp:[],conf:0.85},
  TailFile:{cat:'Auto Loader',tpl:'df_{v} = (spark.readStream\n  .format("cloudFiles")\n  .option("cloudFiles.format", "text")\n  .load("/Volumes/{catalog}/{schema}/{path}"))',desc:'File tail via Auto Loader',notes:'Streaming mode handles new files automatically',imp:[],conf:0.80},
  ListFile:{cat:'Cloud Storage',tpl:'files = dbutils.fs.ls("/Volumes/{catalog}/{schema}/{path}")\ndf_{v} = spark.createDataFrame(files)',desc:'List files in directory',notes:'Use Volumes or external location',imp:[],conf:0.80},
  GetMongo:{cat:'MongoDB Connector',tpl:'df_{v} = (spark.read\n  .format("mongodb")\n  .option("connection.uri", "{uri}")\n  .option("database", "{database}")\n  .option("collection", "{collection}")\n  .load())',desc:'MongoDB read',notes:'Install mongodb-spark-connector library',imp:[],conf:0.75},
  GetElasticsearch:{cat:'ES Connector',tpl:'df_{v} = (spark.read\n  .format("org.elasticsearch.spark.sql")\n  .option("es.nodes", "{host}")\n  .option("es.resource", "{index}")\n  .load())',desc:'Elasticsearch read',notes:'Install elasticsearch-spark library',imp:[],conf:0.65},
  // TRANSFORMS
  ConvertRecord:{cat:'DataFrame API',tpl:'df_{v} = df_{in}.selectExpr("*")  # Convert record format\n# Adjust column types/names as needed',desc:'Record format conversion',notes:'Spark handles format conversion natively',imp:[],conf:0.80},
  ConvertJSONToSQL:{cat:'Spark SQL',tpl:'df_{in}.createOrReplaceTempView("tmp_{v}")\ndf_{v} = spark.sql("SELECT * FROM tmp_{v}")',desc:'JSON to SQL conversion',notes:'Parse JSON and query with SQL',imp:[],conf:0.75},
  SplitRecord:{cat:'DataFrame API',tpl:'df_{v} = df_{in}.withColumn("item", explode(col("{array_field}")))\n  .select("item.*")',desc:'Split records by array field',notes:'Identify the array field to explode',imp:[],conf:0.75},
  MergeRecord:{cat:'DataFrame API',tpl:'df_{v} = df_{in1}.unionByName(df_{in2}, allowMissingColumns=True)',desc:'Merge/union records',notes:'Ensure compatible schemas',imp:[],conf:0.85},
  MergeContent:{cat:'DataFrame API',tpl:'df_{v} = df_{in1}.unionByName(df_{in2}, allowMissingColumns=True)',desc:'Merge content streams',notes:'Same as MergeRecord for DataFrames',imp:[],conf:0.80},
  ReplaceText:{cat:'DataFrame API',tpl:'from pyspark.sql.functions import regexp_replace\ndf_{v} = df_{in}.withColumn("{col}", regexp_replace(col("{col}"), "{pattern}", "{replacement}"))',desc:'Regex text replacement',notes:'Apply to specific text columns',imp:[],conf:0.85},
  UpdateAttribute:{cat:'DataFrame API',tpl:'df_{v} = df_{in}.withColumn("{attr}", lit("{value}"))',desc:'Set/update attributes as columns',notes:'Map NiFi attributes to DataFrame columns',imp:[],conf:0.80},
  JoltTransformJSON:{cat:'JSON Processing',tpl:'from pyspark.sql.functions import from_json, to_json, col\n# Define target schema\nschema = "..."\ndf_{v} = df_{in}.withColumn("parsed", from_json(col("value"), schema))\n  .select("parsed.*")',desc:'Complex JSON transformation',notes:'Jolt specs must be manually translated to Spark JSON ops',imp:[],conf:0.50},
  EvaluateJsonPath:{cat:'DataFrame API',tpl:'from pyspark.sql.functions import get_json_object\ndf_{v} = df_{in}.withColumn("{field}", get_json_object(col("value"), "$.{path}"))',desc:'Extract JSON paths',notes:'Map each JsonPath expression to get_json_object',imp:[],conf:0.80},
  ExtractText:{cat:'DataFrame API',tpl:'from pyspark.sql.functions import regexp_extract\ndf_{v} = df_{in}.withColumn("{field}", regexp_extract(col("{col}"), "{pattern}", {group}))',desc:'Regex text extraction',notes:'Translate NiFi regex groups to Spark',imp:[],conf:0.80},
  SplitJson:{cat:'DataFrame API',tpl:'df_{v} = df_{in}.withColumn("items", explode(from_json(col("value"), ArrayType(StringType()))))',desc:'Split JSON array',notes:'Define element schema',imp:[],conf:0.75},
  SplitText:{cat:'DataFrame API',tpl:'df_{v} = df_{in}.withColumn("lines", explode(split(col("value"), "\\\\n")))',desc:'Split text by delimiter',notes:'Adjust delimiter as needed',imp:[],conf:0.80},
  CompressContent:{cat:'Native',tpl:'# Delta Lake handles compression natively (snappy/zstd)\n# No explicit compression step needed',desc:'Compression',notes:'Delta Lake auto-compresses',imp:[],conf:0.95},
  EncryptContent:{cat:'Security',tpl:'# Use Databricks column-level encryption\n# Or configure encryption at storage level\ndf_{v} = df_{in}  # TODO: Add encryption logic',desc:'Encryption',notes:'Use workspace-level encryption or column masking',imp:[],conf:0.40},
  HashContent:{cat:'DataFrame API',tpl:'from pyspark.sql.functions import sha2\ndf_{v} = df_{in}.withColumn("{col}_hash", sha2(col("{col}"), 256))',desc:'SHA-256 hashing',notes:'Apply to specific columns',imp:[],conf:0.90},
  TransformXml:{cat:'XML Processing',tpl:'# Use spark-xml library\ndf_{v} = spark.read.format("com.databricks.spark.xml").option("rowTag", "{tag}").load("{path}")',desc:'XML transformation',notes:'Install spark-xml; define row tag',imp:[],conf:0.60},
  ExecuteScript:{cat:'Python Cell',tpl:'# Custom script from NiFi ExecuteScript\n# Original engine: {engine}\n# TODO: Translate script logic to PySpark\ndf_{v} = df_{in}',desc:'Custom script execution',notes:'Manual translation required — review original script',imp:[],conf:0.30},
  ExecuteStreamCommand:{cat:'Shell Command',tpl:'import subprocess\nresult = subprocess.run(["{command}"], capture_output=True, text=True)\nprint(result.stdout)',desc:'External command execution',notes:'Ensure command is available on cluster',imp:[],conf:0.40},
  ConvertAvroToJSON:{cat:'DataFrame API',tpl:'from pyspark.sql.avro.functions import from_avro\ndf_{v} = df_{in}.select(from_avro("value", schema).alias("data")).select("data.*")',desc:'Avro to JSON',notes:'Spark handles Avro natively',imp:[],conf:0.85},
  AttributesToJSON:{cat:'DataFrame API',tpl:'from pyspark.sql.functions import to_json, struct\ndf_{v} = df_{in}.select(to_json(struct("*")).alias("json_value"))',desc:'Columns to JSON',notes:'Converts all columns to single JSON string',imp:[],conf:0.85},
  // ROUTES
  RouteOnAttribute:{cat:'DataFrame Filter',tpl:'# Route based on attribute conditions\ndf_{v}_matched = df_{in}.filter("{condition}")\ndf_{v}_unmatched = df_{in}.filter("NOT ({condition})")',desc:'Conditional routing',notes:'Map NiFi routing rules to filter conditions',imp:[],conf:0.80},
  RouteOnContent:{cat:'DataFrame Filter',tpl:'df_{v} = df_{in}.filter(col("value").rlike("{pattern}"))',desc:'Content-based routing',notes:'Translate content match patterns to regex',imp:[],conf:0.75},
  ValidateRecord:{cat:'DLT Expectations',tpl:'# Data quality validation\n# In DLT: @dlt.expect_or_drop("{rule}", "{expression}")\ndf_{v} = df_{in}.filter("{expression}")  # Drop invalid rows',desc:'Record validation',notes:'Best implemented as DLT expectations',imp:[],conf:0.85},
  DistributeLoad:{cat:'Spark Partitioning',tpl:'df_{v} = df_{in}.repartition({partitions})',desc:'Load distribution',notes:'Spark handles distribution automatically; repartition if needed',imp:[],conf:0.90},
  DetectDuplicate:{cat:'DataFrame API',tpl:'df_{v} = df_{in}.dropDuplicates(["{key}"])',desc:'Duplicate detection/removal',notes:'Specify dedup key columns',imp:[],conf:0.90},
  // PROCESSING
  ExecuteSQL:{cat:'Spark SQL',tpl:'df_{in}.createOrReplaceTempView("tmp_{v}")\ndf_{v} = spark.sql("""\n{sql}\n""")',desc:'SQL execution',notes:'Register input as temp view first',imp:[],conf:0.90},
  ExecuteSQLRecord:{cat:'Spark SQL',tpl:'df_{in}.createOrReplaceTempView("tmp_{v}")\ndf_{v} = spark.sql("""\n{sql}\n""")',desc:'SQL execution with records',notes:'Same as ExecuteSQL',imp:[],conf:0.90},
  LookupRecord:{cat:'DataFrame Join',tpl:'# Load lookup table\ndf_lookup = spark.table("{catalog}.{schema}.{lookup_table}")\ndf_{v} = df_{in}.join(df_lookup, on="{key}", how="left")',desc:'Record lookup via join',notes:'Ensure lookup table exists in Unity Catalog',imp:[],conf:0.85},
  InvokeHTTP:{cat:'Python Requests',tpl:'import requests\ndef call_api(row):\n  resp = requests.{method}("{url}", json=row.asDict())\n  return resp.json()\n# Apply row-wise (for small datasets)\n# For large: use pandas UDF',desc:'HTTP API call',notes:'Consider rate limiting and error handling',imp:['import requests'],conf:0.60},
  PutDatabaseRecord:{cat:'JDBC Write',tpl:'(df_{in}.write\n  .format("jdbc")\n  .option("url", "{url}")\n  .option("dbtable", "{table}")\n  .mode("append")\n  .save())',desc:'Database record write',notes:'Store JDBC credentials in secret scope',imp:[],conf:0.85},
  HandleHttpRequest:{cat:'Manual',tpl:'# TODO: No direct equivalent for HandleHttpRequest\n# Consider: Databricks Model Serving endpoint\n# Or: External API gateway triggering a Databricks job',desc:'HTTP server endpoint',notes:'Databricks cannot host HTTP endpoints natively — use Model Serving',imp:[],conf:0.10},
  HandleHttpResponse:{cat:'Manual',tpl:'# TODO: No direct equivalent for HandleHttpResponse\n# Pair with HandleHttpRequest replacement',desc:'HTTP response handler',notes:'Use with HandleHttpRequest alternative',imp:[],conf:0.10},
  // SINKS
  PutFile:{cat:'Delta Lake Write',tpl:'(df_{in}.write\n  .format("delta")\n  .mode("append")\n  .saveAsTable("{catalog}.{schema}.{table}"))',desc:'Write to Delta Lake table',notes:'Uses Unity Catalog managed table',imp:[],conf:0.90},
  PutSQL:{cat:'JDBC Write',tpl:'(df_{in}.write\n  .format("jdbc")\n  .option("url", "{url}")\n  .option("dbtable", "{table}")\n  .mode("append")\n  .save())',desc:'SQL database write',notes:'Store credentials in secret scope',imp:[],conf:0.85},
  PutKafka:{cat:'Kafka Write',tpl:'(df_{in}\n  .selectExpr("to_json(struct(*)) AS value")\n  .write\n  .format("kafka")\n  .option("kafka.bootstrap.servers", "{brokers}")\n  .option("topic", "{topic}")\n  .save())',desc:'Write to Kafka topic',notes:'Configure security protocol',imp:[],conf:0.85},
  PublishKafka:{cat:'Kafka Write',tpl:'(df_{in}\n  .selectExpr("to_json(struct(*)) AS value")\n  .write\n  .format("kafka")\n  .option("kafka.bootstrap.servers", "{brokers}")\n  .option("topic", "{topic}")\n  .save())',desc:'Publish to Kafka',notes:'Same as PutKafka',imp:[],conf:0.85},
  PublishKafka_2_6:{cat:'Kafka Write',tpl:'(df_{in}\n  .selectExpr("to_json(struct(*)) AS value")\n  .write\n  .format("kafka")\n  .option("kafka.bootstrap.servers", "{brokers}")\n  .option("topic", "{topic}")\n  .save())',desc:'Publish to Kafka 2.6',notes:'Same as PutKafka',imp:[],conf:0.85},
  PublishKafkaRecord_2_6:{cat:'Kafka Write',tpl:'(df_{in}\n  .selectExpr("to_json(struct(*)) AS value")\n  .write\n  .format("kafka")\n  .option("kafka.bootstrap.servers", "{brokers}")\n  .option("topic", "{topic}")\n  .save())',desc:'Publish Kafka records',notes:'Same as PutKafka',imp:[],conf:0.85},
  PutS3Object:{cat:'Cloud Storage Write',tpl:'(df_{in}.write\n  .format("delta")\n  .mode("append")\n  .save("s3a://{bucket}/{path}"))',desc:'Write to S3',notes:'Use external location in Unity Catalog',imp:[],conf:0.85},
  PutHDFS:{cat:'Cloud Storage Write',tpl:'(df_{in}.write\n  .format("delta")\n  .mode("append")\n  .save("{path}"))',desc:'Write to cloud storage',notes:'Map HDFS path to cloud storage',imp:[],conf:0.80},
  PutEmail:{cat:'Webhook',tpl:'import requests\nrequests.post("{webhook_url}", json={"subject": "{subject}", "body": "Pipeline completed"})',desc:'Email notification',notes:'No native email — use webhook or notification service',imp:['import requests'],conf:0.35},
  PutMongo:{cat:'MongoDB Connector',tpl:'(df_{in}.write\n  .format("mongodb")\n  .option("connection.uri", "{uri}")\n  .option("database", "{database}")\n  .option("collection", "{collection}")\n  .mode("append")\n  .save())',desc:'MongoDB write',notes:'Install mongodb-spark-connector',imp:[],conf:0.75},
  PutElasticsearch:{cat:'ES Connector',tpl:'(df_{in}.write\n  .format("org.elasticsearch.spark.sql")\n  .option("es.nodes", "{host}")\n  .save("{index}"))',desc:'Elasticsearch write',notes:'Install elasticsearch-spark',imp:[],conf:0.65},
  PutDatabaseRecord:{cat:'JDBC Write',tpl:'(df_{in}.write\n  .format("jdbc")\n  .option("url", "{url}")\n  .option("dbtable", "{table}")\n  .mode("append")\n  .save())',desc:'Database record write',notes:'Store credentials in secret scope',imp:[],conf:0.85},
  // UTILITY
  LogMessage:{cat:'Python Logging',tpl:'import logging\nlogger = logging.getLogger("{v}")\nlogger.info("Processing complete for {v}")',desc:'Logging',notes:'Use Spark driver logs',imp:[],conf:0.90},
  LogAttribute:{cat:'Python Logging',tpl:'print(f"Schema: {df_{in}.columns}")\ndf_{in}.show(5, truncate=False)',desc:'Log attributes/preview',notes:'Use display() in notebooks',imp:[],conf:0.85},
  Wait:{cat:'Scheduling',tpl:'import time\ntime.sleep({duration})  # Consider Databricks workflow scheduling instead',desc:'Wait/delay',notes:'Prefer workflow-level scheduling over sleep',imp:[],conf:0.70},
  Notify:{cat:'Workflow Signal',tpl:'dbutils.notebook.exit("SUCCESS")  # Signal to downstream workflow tasks',desc:'Signal/notify completion',notes:'Use workflow task dependencies',imp:[],conf:0.80},
  DebugFlow:{cat:'Debug',tpl:'display(df_{in})\ndf_{in}.printSchema()',desc:'Debug/inspect data',notes:'Use display() in Databricks notebooks',imp:[],conf:0.90},
  CountText:{cat:'DataFrame API',tpl:'_count = df_{in}.count()\nprint(f"Row count: {_count}")',desc:'Count rows',notes:'',imp:[],conf:0.95},
  ControlRate:{cat:'Streaming Trigger',tpl:'# Rate control: use trigger interval\n# .trigger(processingTime="{interval}")',desc:'Rate limiting',notes:'Use structured streaming trigger interval',imp:[],conf:0.70},
};

function sanitizeVarName(name) {
  return name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^(\d)/, '_$1').toLowerCase().substring(0, 40);
}

function mapNiFiToDatabricks(nifi) {
  const processors = nifi.processors || [];
  const conns = nifi.connections || [];
  // Build connection graph: processor name -> {inputs:[], outputs:[]}
  const connGraph = {};
  conns.forEach(c => {
    if (!connGraph[c.destinationName]) connGraph[c.destinationName] = {inputs:[],outputs:[]};
    connGraph[c.destinationName].inputs.push(c.sourceName);
    if (!connGraph[c.sourceName]) connGraph[c.sourceName] = {inputs:[],outputs:[]};
    connGraph[c.sourceName].outputs.push(c.destinationName);
  });
  return processors.map(p => {
    const role = classifyNiFiProcessor(p.type);
    const mapEntry = NIFI_DATABRICKS_MAP[p.type];
    const varName = sanitizeVarName(p.name);
    const inputProcs = (connGraph[p.name] && connGraph[p.name].inputs) || [];
    const inputVar = inputProcs.length ? sanitizeVarName(inputProcs[0]) : 'input';
    if (mapEntry) {
      let code = mapEntry.tpl.replace(/\{v\}/g, varName).replace(/\{in\}/g, inputVar)
        .replace(/\{in1\}/g, inputVar).replace(/\{in2\}/g, inputProcs[1] ? sanitizeVarName(inputProcs[1]) : 'input2');
      // Substitute from processor properties
      Object.entries(p.properties || {}).forEach(([k, val]) => {
        const key = k.replace(/\s+/g, '_').toLowerCase();
        code = code.replace(new RegExp('\\{' + key + '\\}', 'gi'), val);
      });
      code = code.replace(/\{(\w+)\}/g, '<$1>');
      return { name: p.name, type: p.type, group: p.group, role, mapped: true,
        confidence: mapEntry.conf, category: mapEntry.cat, code, desc: mapEntry.desc,
        notes: mapEntry.notes, imports: mapEntry.imp || [], state: p.state };
    }
    return { name: p.name, type: p.type, group: p.group, role, mapped: false,
      confidence: 0, category: 'Unknown', code: `# TODO: No mapping for ${p.type}\n# Processor: ${p.name}\n# Review manually`,
      desc: 'No known Databricks equivalent', notes: 'Manual migration required',
      imports: [], state: p.state, gapReason: `Processor type "${p.type}" has no known Databricks equivalent` };
  });
}

function generateDatabricksNotebook(mappings, nifi, blueprint) {
  const cells = [];
  const allImports = new Set(['from pyspark.sql.functions import *','from pyspark.sql.types import *']);
  mappings.forEach(m => (m.imports || []).forEach(i => allImports.add(i)));
  const flowName = (nifi.processGroups && nifi.processGroups[0] ? nifi.processGroups[0].name : 'NiFi Flow');
  // Header
  cells.push({type:'md',label:'Header',source:`# MAGIC %md\n# MAGIC # NiFi Migration: ${flowName}\n# MAGIC Generated by SEG Demo | ${new Date().toISOString().split('T')[0]}\n# MAGIC \n# MAGIC **Processors:** ${mappings.length} | **Mapped:** ${mappings.filter(m=>m.mapped).length} | **Coverage:** ${Math.round(mappings.filter(m=>m.mapped).length/mappings.length*100)}%`,role:'config'});
  // Imports
  cells.push({type:'code',label:'Imports & Config',source:[...allImports].join('\n')+'\n\n# Configure logging\nimport logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger("nifi_migration")',role:'config'});
  // Unity Catalog DDL
  const tables = (blueprint && blueprint.tables) || [];
  if (tables.length) {
    let ddl = '# MAGIC %sql\n# MAGIC CREATE SCHEMA IF NOT EXISTS nifi_migration;\n';
    tables.forEach(t => {
      ddl += `# MAGIC CREATE TABLE IF NOT EXISTS nifi_migration.${t.name} (\n`;
      ddl += t.columns.map(c => `# MAGIC   ${c.name} ${(c.data_type||c.type||'STRING').toUpperCase()}`).join(',\n');
      ddl += '\n# MAGIC ) USING DELTA;\n';
    });
    cells.push({type:'sql',label:'Unity Catalog Setup',source:ddl,role:'config'});
  }
  // Group by process group, sorted by role
  const groups = {};
  mappings.forEach(m => { if (!groups[m.group]) groups[m.group] = []; groups[m.group].push(m); });
  const roleOrd = {source:0,route:1,transform:2,process:3,sink:4,utility:5};
  const sortedGroups = Object.entries(groups).sort((a,b) => {
    const aMin = Math.min(...a[1].map(m => roleOrd[m.role] || 3));
    const bMin = Math.min(...b[1].map(m => roleOrd[m.role] || 3));
    return aMin - bMin;
  });
  sortedGroups.forEach(([gName, procs]) => {
    const mapped = procs.filter(m=>m.mapped).length;
    cells.push({type:'md',label:gName,source:`# MAGIC %md\n# MAGIC ## Process Group: ${gName}\n# MAGIC **${procs.length} processors** | ${mapped} mapped | ${procs.length-mapped} manual`,role:'config'});
    // Sort processors: sources first, then transforms, then sinks
    procs.sort((a,b) => (roleOrd[a.role]||3) - (roleOrd[b.role]||3));
    procs.forEach(m => {
      const lbl = `[${m.role.toUpperCase()}] ${m.name} → ${m.category}`;
      cells.push({type:'code',label:lbl,source:`# ${lbl}\n# ${m.desc}${m.notes ? '  |  ' + m.notes : ''}\n${m.code}`,role:m.role,processor:m.name,procType:m.type,confidence:m.confidence,mapped:m.mapped});
    });
  });
  // Footer
  cells.push({type:'code',label:'Pipeline Complete',source:'logger.info("NiFi migration pipeline complete")\ndbutils.notebook.exit("SUCCESS")',role:'utility'});
  return { cells, flowName, metadata: { processorCount: mappings.length, mappedCount: mappings.filter(m=>m.mapped).length, generatedAt: new Date().toISOString() }};
}

function generateWorkflowJSON(mappings, nifi) {
  const conns = nifi.connections || [];
  const procToGroup = {};
  (nifi.processors || []).forEach(p => { procToGroup[p.name] = p.group || '(root)'; });
  const groups = [...new Set(Object.values(procToGroup))];
  const groupDeps = {};
  groups.forEach(g => { groupDeps[g] = new Set(); });
  conns.forEach(c => {
    const sg = procToGroup[c.sourceName], dg = procToGroup[c.destinationName];
    if (sg && dg && sg !== dg) groupDeps[dg].add(sg);
  });
  const tasks = groups.map(g => ({
    task_key: sanitizeVarName(g),
    description: `Process group: ${g}`,
    notebook_task: { notebook_path: `/Workspace/Migrations/NiFi/${sanitizeVarName(g)}_notebook`, source: 'WORKSPACE' },
    depends_on: [...groupDeps[g]].map(d => ({ task_key: sanitizeVarName(d) })),
    new_cluster: { spark_version: '14.3.x-scala2.12', node_type_id: 'Standard_DS3_v2', num_workers: 2 }
  }));
  return { name: `NiFi_Migration_${sanitizeVarName(groups[0] || 'flow')}`, tasks, format: 'MULTI_TASK',
    tags: { source: 'nifi_migration', generated_by: 'seg_demo' } };
}

function generateMigrationReport(mappings, nifi) {
  const total = mappings.length, mapped = mappings.filter(m=>m.mapped).length;
  const byRole = {};
  ROLE_TIER_ORDER.forEach(r => { byRole[r] = { total:0, mapped:0, unmapped:0, procs:[] }; });
  mappings.forEach(m => {
    const r = byRole[m.role] || byRole.process;
    r.total++; if (m.mapped) r.mapped++; else r.unmapped++;
    r.procs.push(m);
  });
  const byGroup = {};
  mappings.forEach(m => {
    if (!byGroup[m.group]) byGroup[m.group] = { total:0, mapped:0, unmapped:0, procs:[] };
    byGroup[m.group].total++; if (m.mapped) byGroup[m.group].mapped++; else byGroup[m.group].unmapped++;
    byGroup[m.group].procs.push(m);
  });
  const gaps = mappings.filter(m => !m.mapped || m.confidence < 0.3).map(m => ({
    name: m.name, type: m.type, group: m.group, role: m.role,
    reason: m.gapReason || `Low confidence mapping (${Math.round(m.confidence*100)}%)`,
    recommendation: m.type.match(/^(Listen|Handle)/) ? 'Consider Databricks Model Serving or external API gateway'
      : m.type.match(/^Execute(Script|Stream)/) ? 'Manual translation required — review original script logic'
      : m.type.match(/^(Put|Send)(Email|TCP|Syslog)/) ? 'Use webhook notification service or Databricks workflow alerts'
      : 'Review processor documentation and implement custom PySpark logic'
  }));
  const recs = [];
  if (gaps.length > total * 0.2) recs.push('High gap rate — consider custom UDFs for unsupported processor types');
  if (mappings.some(m => m.type.match(/Listen|Handle/))) recs.push('HTTP endpoints detected — evaluate Databricks Model Serving for REST API replacement');
  if (mappings.some(m => m.type.match(/Consume.*Kafka|Subscribe/))) recs.push('Streaming sources present — use Structured Streaming with Auto Loader trigger intervals');
  if ((nifi.controllerServices||[]).length) recs.push(`${nifi.controllerServices.length} controller service(s) detected — map credentials to Databricks secret scopes`);
  if (mapped > total * 0.8) recs.push('High coverage — prioritize testing the mapped processors before addressing gaps');
  recs.push('Run the generated notebook in a Databricks workspace to validate each cell');
  const coveragePct = total ? Math.round(mapped / total * 100) : 0;
  const effort = coveragePct >= 85 ? 'Low' : coveragePct >= 60 ? 'Medium' : 'High';
  return { summary: { totalProcessors: total, mappedProcessors: mapped, unmappedProcessors: total - mapped, coveragePercent: coveragePct,
    totalProcessGroups: Object.keys(byGroup).length, totalConnections: (nifi.connections||[]).length, controllerServices: (nifi.controllerServices||[]).length },
    byRole, byGroup, gaps, recommendations: recs, effort };
}

// Tarjan's SCC algorithm — returns arrays of node groups forming cycles (size > 1 only)
function detectCyclesSCC(adjacencyMap) {
  let idx = 0; const stack = [], onStack = new Set(), indices = {}, lowlinks = {}, sccs = [];
  function sc(v) {
    indices[v] = lowlinks[v] = idx++;
    stack.push(v); onStack.add(v);
    for (const w of (adjacencyMap[v] || [])) {
      if (indices[w] === undefined) { sc(w); lowlinks[v] = Math.min(lowlinks[v], lowlinks[w]); }
      else if (onStack.has(w)) { lowlinks[v] = Math.min(lowlinks[v], indices[w]); }
    }
    if (lowlinks[v] === indices[v]) {
      const scc = []; let w;
      do { w = stack.pop(); onStack.delete(w); scc.push(w); } while (w !== v);
      if (scc.length > 1) sccs.push(scc);
    }
  }
  for (const v of Object.keys(adjacencyMap)) { if (indices[v] === undefined) sc(v); }
  return sccs;
}

function classifyGroupDominantRole(stats) {
  const counts = [['source',stats.sources],['route',stats.routes],['transform',stats.transforms],
    ['process',stats.processes],['sink',stats.sinks],['utility',stats.utilities]];
  counts.sort((a,b) => b[1] !== a[1] ? b[1] - a[1] : ROLE_TIER_ORDER.indexOf(a[0]) - ROLE_TIER_ORDER.indexOf(b[0]));
  return counts[0][1] > 0 ? counts[0][0] : 'process';
}

// BFS shortest path through directed connections array; returns {pathNodes, pathEdgeKeys, found}
function bfsShortestPath(connections, startId, endId) {
  const adj = {};
  connections.forEach(c => {
    if (!adj[c.from]) adj[c.from] = [];
    adj[c.from].push({ to: c.to, key: c.from + '|' + c.to });
  });
  const visited = new Set([startId]);
  const parent = {};
  const queue = [startId];
  while (queue.length) {
    const cur = queue.shift();
    if (cur === endId) {
      const pathNodes = [], pathEdgeKeys = [];
      let n = endId;
      while (n !== startId) { pathNodes.unshift(n); pathEdgeKeys.unshift(parent[n].key); n = parent[n].from; }
      pathNodes.unshift(startId);
      return { pathNodes, pathEdgeKeys, found: true };
    }
    for (const nb of (adj[cur] || [])) {
      if (!visited.has(nb.to)) { visited.add(nb.to); parent[nb.to] = { from: cur, key: nb.key }; queue.push(nb.to); }
    }
  }
  return { pathNodes: [], pathEdgeKeys: [], found: false };
}

function buildTierData(blueprint, parsed) {
  const fmt = parsed ? parsed.input_format : '';
  if (fmt === 'nifi_xml' && parsed._nifi) return buildNiFiTierData(parsed._nifi, blueprint);
  if (fmt === 'dependency_json' && parsed._dependency) return buildDependencyTierData(parsed._dependency, blueprint);
  if (blueprint.relationships && blueprint.relationships.length > 0) return buildSQLTierData(blueprint);
  return buildFlatTierData(blueprint);
}

function buildNiFiTierData(nifi, blueprint) {
  const nodes = [], connections = [];
  const tierLabels = {};
  const processors = nifi.processors || [];
  const conns = nifi.connections || [];
  const processGroups = nifi.processGroups || [];

  // ── Step 1: Build per-group stats ──
  const groupStats = {};  // groupName -> {sources, sinks, routes, transforms, processes, utilities, total, processors:[]}
  processors.forEach(p => {
    const g = p.group || '(root)';
    if (!groupStats[g]) groupStats[g] = { sources:0, sinks:0, routes:0, transforms:0, processes:0, utilities:0, total:0, processors:[], typeCount:{} };
    const role = classifyNiFiProcessor(p.type);
    groupStats[g][role + 's'] = (groupStats[g][role + 's'] || 0) + 1;
    groupStats[g].total++;
    groupStats[g].processors.push(p);
    groupStats[g].typeCount[p.type] = (groupStats[g].typeCount[p.type] || 0) + 1;
  });

  // ── Step 2: Build inter-group connections ──
  // Map processor name -> group
  const procToGroup = {};
  processors.forEach(p => { procToGroup[p.name] = p.group || '(root)'; });
  // Count inter-group connections
  const interGroupConns = {};  // "fromGroup|toGroup" -> count
  const intraGroupConns = {};  // groupName -> count
  conns.forEach(c => {
    const srcGroup = procToGroup[c.sourceName] || '(root)';
    const dstGroup = procToGroup[c.destinationName] || '(root)';
    if (srcGroup !== dstGroup) {
      const key = srcGroup + '|' + dstGroup;
      interGroupConns[key] = (interGroupConns[key] || 0) + 1;
    } else {
      intraGroupConns[srcGroup] = (intraGroupConns[srcGroup] || 0) + 1;
    }
  });

  // ── Step 3: Detect cycles + assign role-based tiers ──
  const groupNames = Object.keys(groupStats);
  const groupDownstream = {};
  Object.keys(interGroupConns).forEach(key => {
    const [from, to] = key.split('|');
    if (!groupDownstream[from]) groupDownstream[from] = new Set();
    groupDownstream[from].add(to);
  });
  groupNames.forEach(gn => { if (!groupDownstream[gn]) groupDownstream[gn] = new Set(); });

  const sccs = detectCyclesSCC(groupDownstream);
  const cycleGroups = new Set();
  const groupToSCC = {};
  sccs.forEach((scc, i) => { scc.forEach(gn => { cycleGroups.add(gn); groupToSCC[gn] = i; }); });

  // Assign dominant role per group
  const groupDominantRole = {};
  groupNames.forEach(gn => { groupDominantRole[gn] = classifyGroupDominantRole(groupStats[gn]); });

  // Group groups by dominant role
  const roleGroups = {};
  ROLE_TIER_ORDER.forEach(r => { roleGroups[r] = []; });
  groupNames.forEach(gn => { roleGroups[groupDominantRole[gn]].push(gn); });
  // Sort within each role: purity desc, then total desc
  ROLE_TIER_ORDER.forEach(role => {
    const key = role + 's';
    roleGroups[role].sort((a, b) => {
      const aFrac = (groupStats[a][key] || 0) / (groupStats[a].total || 1);
      const bFrac = (groupStats[b][key] || 0) / (groupStats[b].total || 1);
      if (bFrac !== aFrac) return bFrac - aFrac;
      return groupStats[b].total - groupStats[a].total;
    });
  });

  // ── Step 4: Build role-based tier layout ──
  let tierNum = 0;
  ROLE_TIER_ORDER.forEach(role => {
    const groups = roleGroups[role];
    if (!groups.length) return;
    tierNum++;
    const color = ROLE_TIER_COLORS[role];
    const rgb = color.replace('#','').match(/.{2}/g).map(h => parseInt(h, 16));
    tierLabels[tierNum] = { label: ROLE_TIER_LABELS[role], color, bg: `rgba(${rgb[0]},${rgb[1]},${rgb[2]},0.06)`, role };

    groups.forEach(gn => {
      const stats = groupStats[gn];
      const topTypes = Object.entries(stats.typeCount).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([t, c]) => `${t}(${c})`).join(', ');
      const inCycle = cycleGroups.has(gn);
      const sccIdx = groupToSCC[gn];
      const sccMembers = inCycle ? sccs[sccIdx] : [];
      const cycleEdges = inCycle ? Object.entries(interGroupConns)
        .filter(([k]) => { const [f, t] = k.split('|'); return sccs[sccIdx].includes(f) && sccs[sccIdx].includes(t); })
        .map(([k, v]) => { const [f, t] = k.split('|'); return { from: f, to: t, count: v }; }) : [];

      nodes.push({
        id: 'pg_' + gn, name: gn, tier: tierNum,
        type: 'process_group', dominantRole: groupDominantRole[gn],
        subtype: groupDominantRole[gn] + 's',
        procCount: stats.total,
        srcCount: stats.sources, sinkCount: stats.sinks,
        routeCount: stats.routes, transformCount: stats.transforms,
        processCount: stats.processes, utilityCount: stats.utilities,
        intraConns: intraGroupConns[gn] || 0,
        topTypes, inCycle, sccMembers, cycleEdges, expandable: true,
        detail: { processors: stats.processors, typeCount: stats.typeCount, intraConns: intraGroupConns[gn] || 0 }
      });
    });
  });

  // ── Step 5: Build inter-group connections (red for cycle edges) ──
  Object.entries(interGroupConns).forEach(([key, count]) => {
    const [from, to] = key.split('|');
    const bothInCycle = cycleGroups.has(from) && cycleGroups.has(to) && groupToSCC[from] === groupToSCC[to];
    connections.push({
      from: 'pg_' + from, to: 'pg_' + to,
      label: count > 1 ? count + ' flows' : '1 flow',
      type: 'flow', color: bothInCycle ? '#EF4444' : '#4B5563',
      width: Math.min(1 + count * 0.3, 4), inCycle: bothInCycle
    });
  });

  // ── Step 6: Connection density sidebar ──
  const densityData = [];
  const globalTypeCount = {};
  processors.forEach(p => { globalTypeCount[p.type] = (globalTypeCount[p.type] || 0) + 1; });
  Object.entries(globalTypeCount).sort((a, b) => b[1] - a[1]).forEach(([type, count]) => {
    const role = classifyNiFiProcessor(type);
    densityData.push({ name: type, writers: count, readers: 0, lookups: 0, total: count, role });
  });

  // ── Step 7: Cycle summary ──
  const cycleData = sccs.map((scc, i) => ({
    id: i, groups: scc,
    edgeCount: Object.keys(interGroupConns).filter(k => { const [f, t] = k.split('|'); return scc.includes(f) && scc.includes(t); }).length
  }));

  return { nodes, connections, tierLabels, diagramType: 'nifi_flow', densityData, cycleData };
}

function buildSQLTierData(blueprint) {
  const nodes = [], connections = [];
  const tierLabels = {};
  // Compute dependency depth via topological sort
  const depthMap = {};
  const tableNames = blueprint.tables.map(t => t.name);
  const fkTargets = {};
  blueprint.tables.forEach(t => {
    t.foreign_keys.forEach(fk => {
      const ref = fk.references_table;
      if (!fkTargets[t.name]) fkTargets[t.name] = [];
      fkTargets[t.name].push(ref);
    });
  });
  function getDepth(tn, visited) {
    if (depthMap[tn] !== undefined) return depthMap[tn];
    if (visited.has(tn)) return 0; // cycle
    visited.add(tn);
    const deps = fkTargets[tn] || [];
    if (!deps.length) { depthMap[tn] = 0; return 0; }
    const maxDep = Math.max(...deps.map(d => getDepth(d, new Set(visited))));
    depthMap[tn] = maxDep + 1;
    return depthMap[tn];
  }
  tableNames.forEach(tn => getDepth(tn, new Set()));
  const maxDepth = Math.max(0, ...Object.values(depthMap));
  // Build tier labels
  for (let d = 0; d <= maxDepth; d++) {
    if (d === 0) tierLabels[1] = {label:'INDEPENDENT TABLES', color:'#3B82F6', bg:'rgba(59,130,246,0.06)'};
    else tierLabels[d+1] = {label:`DEPENDENCY LEVEL ${d}`, color: d===1?'#EAB308':d===2?'#A855F7':'#21C354', bg: d===1?'rgba(234,179,8,0.06)':d===2?'rgba(168,85,247,0.06)':'rgba(33,195,84,0.06)'};
  }
  // Build nodes
  blueprint.tables.forEach(t => {
    const depth = depthMap[t.name] || 0;
    const pkCols = t.columns.filter(c => c.is_primary_key);
    nodes.push({
      id: t.name,
      name: t.name,
      tier: depth + 1,
      type: 'table',
      meta: `${t.columns.length} cols${pkCols.length?' · PK: '+pkCols.map(c=>c.name).join(','):''}`,
      rows: t.row_count,
      fkCount: t.foreign_keys.length,
      detail: t
    });
  });
  // Build connections from relationships
  blueprint.relationships.forEach(r => {
    const fromName = r.from_table.split('.').pop();
    const toName = r.to_table.split('.').pop();
    const colLabel = r.join_columns.map(j => `${j.from_column}→${j.to_column}`).join(', ');
    connections.push({
      from: fromName, to: toName,
      label: colLabel,
      type: 'foreign_key', color: '#3B82F6', width: 2
    });
  });
  return {nodes, connections, tierLabels, diagramType: 'sql_tables'};
}

function buildFlatTierData(blueprint) {
  const nodes = [], connections = [];
  const tierLabels = {1:{label:'SCHEMA OBJECTS',color:'#3B82F6',bg:'rgba(59,130,246,0.06)'}};
  blueprint.tables.forEach(t => {
    nodes.push({
      id: t.name, name: t.name, tier: 1, type: 'table',
      meta: `${t.columns.length} cols`,
      rows: t.row_count, detail: t
    });
  });
  // Look for implicit connections: shared column names between tables
  const colToTables = {};
  blueprint.tables.forEach(t => {
    t.columns.forEach(c => {
      const cn = c.name.toLowerCase();
      if (!colToTables[cn]) colToTables[cn] = [];
      colToTables[cn].push(t.name);
    });
  });
  Object.entries(colToTables).forEach(([cn, tbls]) => {
    if (tbls.length === 2 && (cn.endsWith('_id') || cn === 'id')) {
      connections.push({from:tbls[0], to:tbls[1], label:cn, type:'implicit', color:'#4B5563', width:1, dash:true});
    }
  });
  return {nodes, connections, tierLabels, diagramType: 'flat'};
}

function buildDependencyTierData(dep, blueprint) {
  const nodes = [], connections = [];
  const tierLabels = {};
  const sessions = dep.sessions || [];
  const edges = dep.edges || [];
  const order = dep.order || [];
  const conflicts = dep.conflicts || [];
  const rawSessions = dep.rawSessions || {};
  const allTables = dep.allTables || {};

  // ── Step 1: Build session adjacency + topological depth ──
  const depthMap = {};
  const upstreamMap = {};   // session -> [upstream session names]
  const downstreamMap = {}; // session -> [downstream session names]
  const edgeVia = {};       // "up|down" -> via_table
  edges.forEach(e => {
    const up = e.upstream || e.upstream_session || e.from;
    const down = e.downstream || e.downstream_session || e.to;
    if (!upstreamMap[down]) upstreamMap[down] = [];
    upstreamMap[down].push(up);
    if (!downstreamMap[up]) downstreamMap[up] = [];
    downstreamMap[up].push(down);
    edgeVia[up + '|' + down] = e.shared_tables ? e.shared_tables.join(', ') : (e.via_table || '');
  });
  const sessionNames = sessions.map(s => s.name);
  function getDepth(sn, visited) {
    if (depthMap[sn] !== undefined) return depthMap[sn];
    if (visited.has(sn)) return 0;
    visited.add(sn);
    const ups = upstreamMap[sn] || [];
    if (!ups.length) { depthMap[sn] = 0; return 0; }
    const maxD = Math.max(...ups.map(u => getDepth(u, new Set(visited))));
    depthMap[sn] = maxD + 1;
    return depthMap[sn];
  }
  sessionNames.forEach(sn => getDepth(sn, new Set()));
  if (order.length && Math.max(0, ...Object.values(depthMap)) === 0) {
    order.forEach((sn, i) => { depthMap[sn] = i; });
  }
  const maxSessionDepth = Math.max(0, ...Object.values(depthMap));

  // ── Step 2: Build table index from raw session data ──
  const tableWriters = {};  // table -> [session names that write it]
  const tableReaders = {};  // table -> [session names that read it as source]
  const tableLookups = {};  // table -> [session names that use it as lookup]
  for (const [sName, sess] of Object.entries(rawSessions)) {
    (sess.target_tables || []).forEach(t => {
      if (!tableWriters[t.name]) tableWriters[t.name] = [];
      tableWriters[t.name].push(sName);
    });
    (sess.source_tables || []).forEach(t => {
      if (!tableReaders[t.name]) tableReaders[t.name] = [];
      tableReaders[t.name].push(sName);
    });
    (sess.lookup_tables || []).forEach(t => {
      if (!tableLookups[t.name]) tableLookups[t.name] = [];
      tableLookups[t.name].push(sName);
    });
  }

  // ── Step 3: Classify tables ──
  // Chain tables: written by one session, read/looked-up by different sessions
  // Independent: written but only read back by the same writer
  // Conflict: written by multiple sessions
  const chainTables = {};    // table -> {writers, readers, lookups, isConflict, isChain}
  const conflictMap = {};
  conflicts.forEach(c => {
    if (!conflictMap[c.table_name]) conflictMap[c.table_name] = [];
    conflictMap[c.table_name].push(c);
  });
  const allWrittenTables = Object.keys(tableWriters);
  allWrittenTables.forEach(tn => {
    const writers = tableWriters[tn] || [];
    const readers = (tableReaders[tn] || []).filter(r => !writers.includes(r));
    const lookups = (tableLookups[tn] || []).filter(l => !writers.includes(l));
    const isConflict = writers.length > 1 || !!(conflictMap[tn] && conflictMap[tn].length);
    const isChain = readers.length > 0 || lookups.length > 0;
    if (isConflict || isChain) {
      chainTables[tn] = { writers, readers, lookups, isConflict, isChain, conflicts: conflictMap[tn] || [] };
    }
  });

  // ── Step 4: Group sessions by depth (wave) ──
  const waves = {};
  sessionNames.forEach(sn => {
    const d = depthMap[sn] || 0;
    if (!waves[d]) waves[d] = [];
    waves[d].push(sn);
  });
  const sortedWaves = Object.keys(waves).map(Number).sort((a, b) => a - b);

  // ── Step 5: Build interleaved tiers (session → outputs → conflict gate → next session) ──
  let tierNum = 0;
  const sessionTier = {};    // session name -> tier number
  const tableTier = {};      // table name -> tier number (for output tables)
  const sessionSeqMap = {};  // session name -> execution order number
  order.forEach((sn, i) => { sessionSeqMap[sn] = i + 1; });
  // If no order, assign by depth then alphabetical
  if (!order.length) sessionNames.sort().forEach((sn, i) => { sessionSeqMap[sn] = i + 1; });

  const tierColorPool = ['#3B82F6','#EAB308','#A855F7','#21C354','#F97316','#EC4899','#06B6D4','#8B5CF6','#F43F5E','#10B981'];
  const tierBgPool = ['rgba(59,130,246,0.06)','rgba(234,179,8,0.06)','rgba(168,85,247,0.06)','rgba(33,195,84,0.06)','rgba(249,115,22,0.06)','rgba(236,72,153,0.06)','rgba(6,182,212,0.06)','rgba(139,92,246,0.06)','rgba(244,63,94,0.06)','rgba(16,185,129,0.06)'];
  function tierColor(n) { return tierColorPool[n % tierColorPool.length]; }
  function tierBg(n) { return tierBgPool[n % tierBgPool.length]; }

  // Pre-compute: for each multi-writer conflict table, find which wave contains its LAST writer
  const conflictLastWave = {};  // table name -> wave index of last writer
  allWrittenTables.forEach(tn => {
    const info = chainTables[tn];
    if (info && info.isConflict && info.writers.length > 1) {
      let maxWave = 0;
      info.writers.forEach(w => {
        const d = depthMap[w] || 0;
        if (d > maxWave) maxWave = d;
      });
      conflictLastWave[tn] = maxWave;
    }
  });
  const placedTables = new Set();  // Track globally placed table nodes

  sortedWaves.forEach((waveIdx, wi) => {
    const waveSessions = waves[waveIdx];

    // ── Session tier ──
    tierNum++;
    const sLabel = waveIdx === 0 ? 'INDEPENDENT PARALLEL EXECUTION'
      : (wi === sortedWaves.length - 1 && sortedWaves.length > 1) ? 'END OF PIPELINE'
      : `EXECUTION WAVE ${waveIdx}`;
    tierLabels[tierNum] = { label: `TIER ${wi + 1} — ${sLabel}`, color: tierColor(tierNum), bg: tierBg(tierNum) };

    waveSessions.forEach(sn => {
      sessionTier[sn] = tierNum;
      const sess = rawSessions[sn] || {};
      const srcCount = (sess.source_tables || []).length;
      const tgtCount = (sess.target_tables || []).length;
      const lkpCount = (sess.lookup_tables || []).length;
      const sConflicts = [];
      Object.values(conflictMap).forEach(cArr => cArr.forEach(c => {
        if ((c.writers || []).includes(sn)) sConflicts.push(c);
      }));
      nodes.push({
        id: sn, name: sn, tier: tierNum,
        type: 'session', subtype: waveIdx === 0 ? 'root' : 'dependent',
        seq: sessionSeqMap[sn] || 0,
        srcCount, tgtCount, lkpCount,
        hasConflict: sConflicts.length > 0,
        conflictDetails: sConflicts,
        detail: { sources: srcCount, targets: tgtCount, lookups: lkpCount,
          source_tables: sess.source_tables, target_tables: sess.target_tables, lookup_tables: sess.lookup_tables }
      });
    });

    // ── Collect output tables for this wave ──
    const waveOutputTables = [];
    const waveConflictTables = [];
    waveSessions.forEach(sn => {
      const sess = rawSessions[sn] || {};
      (sess.target_tables || []).forEach(t => {
        if (placedTables.has(t.name)) return;  // Already placed in an earlier tier
        const info = chainTables[t.name];
        if (info && info.isConflict && info.writers.length > 1) {
          // Multi-writer conflict — only place gate after the LAST writer's wave
          if (conflictLastWave[t.name] === waveIdx && !waveConflictTables.find(x => x.name === t.name)) {
            waveConflictTables.push({ name: t.name, info });
          }
        } else if (!info) {
          if (!waveOutputTables.find(x => x.name === t.name)) {
            waveOutputTables.push({ name: t.name, isChain: false, isConflict: false, writer: sn, loadType: t.load_type || '' });
          }
        } else {
          if (!waveOutputTables.find(x => x.name === t.name)) {
            waveOutputTables.push({ name: t.name, isChain: info.isChain, isConflict: info.isConflict, writer: sn, loadType: t.load_type || '' });
          }
        }
      });
    });

    // ── Output tables tier (if any) ──
    if (waveOutputTables.length) {
      tierNum++;
      tierLabels[tierNum] = { label: `TIER ${wi + 1} OUTPUTS${waveOutputTables.some(t=>t.isChain) ? ' & CHAIN TABLES' : ''}`, color: '#6366F1', bg: 'rgba(99,102,241,0.04)' };
      waveOutputTables.forEach(t => {
        placedTables.add(t.name);
        tableTier[t.name] = tierNum;
        const cls = t.isChain ? 'chain' : 'independent';
        nodes.push({
          id: 'tbl_' + t.name, name: t.name, tier: tierNum,
          type: 'table_output', subtype: cls,
          isConflict: t.isConflict, isChain: t.isChain,
          writer: t.writer, loadType: t.loadType,
          detail: { writers: tableWriters[t.name] || [], readers: tableReaders[t.name] || [], lookups: tableLookups[t.name] || [], conflicts: conflictMap[t.name] || [] }
        });
      });
    }

    // ── Conflict gate tier (for multi-writer tables whose last writer is in THIS wave) ──
    if (waveConflictTables.length) {
      tierNum++;
      const gateLabel = waveConflictTables.length === 1
        ? `CRITICAL GATE — ${waveConflictTables[0].name} CONFLICT`
        : `CRITICAL GATE — ${waveConflictTables.length} CONFLICT TABLES`;
      tierLabels[tierNum] = { label: gateLabel, color: '#EF4444', bg: 'rgba(239,68,68,0.06)' };
      waveConflictTables.forEach(t => {
        placedTables.add(t.name);
        tableTier[t.name] = tierNum;
        const info = t.info;
        nodes.push({
          id: 'gate_' + t.name, name: t.name, tier: tierNum,
          type: 'conflict_gate',
          writerCount: info.writers.length,
          readerCount: info.readers.length,
          lookupCount: info.lookups.length,
          conflictTypes: info.conflicts.map(c => c.conflict_type),
          detail: { writers: info.writers, readers: info.readers, lookups: info.lookups, conflicts: info.conflicts }
        });
      });
    }
  });

  // ── Final outputs tier — target tables from the terminal sessions ──
  const terminalWave = sortedWaves[sortedWaves.length - 1];
  const terminalSessions = waves[terminalWave] || [];
  const finalOutputs = [];
  terminalSessions.forEach(sn => {
    const sess = rawSessions[sn] || {};
    (sess.target_tables || []).forEach(t => {
      if (!placedTables.has(t.name) && !finalOutputs.find(x => x.name === t.name)) {
        const info = chainTables[t.name];
        finalOutputs.push({ name: t.name, isConflict: !!(info && info.isConflict), isChain: !!(info && info.isChain), writer: sn });
      }
    });
  });
  if (finalOutputs.length) {
    tierNum++;
    tierLabels[tierNum] = { label: 'FINAL OUTPUTS & CONFLICTS', color: '#EF4444', bg: 'rgba(239,68,68,0.04)' };
    finalOutputs.forEach(t => {
      tableTier[t.name] = tierNum;
      nodes.push({
        id: 'final_' + t.name, name: t.name, tier: tierNum,
        type: 'table_output', subtype: t.isChain ? 'chain' : 'independent',
        isConflict: t.isConflict, isChain: t.isChain, writer: t.writer,
        detail: { writers: tableWriters[t.name] || [], readers: tableReaders[t.name] || [], lookups: tableLookups[t.name] || [], conflicts: conflictMap[t.name] || [] }
      });
    });
  }

  // ── Step 6: Build connections ──
  // Session → its output tables
  for (const [sn, sess] of Object.entries(rawSessions)) {
    (sess.target_tables || []).forEach(t => {
      const tableId = nodes.find(n => (n.type === 'table_output' || n.type === 'conflict_gate') && n.name === t.name);
      if (tableId) {
        connections.push({ from: sn, to: tableId.id, label: '', type: 'produces', color: '#6366F1', width: 1.5 });
      }
    });
  }
  // Output/gate tables → downstream sessions that read them
  nodes.filter(n => n.type === 'table_output' || n.type === 'conflict_gate').forEach(tblNode => {
    const readers = (tableReaders[tblNode.name] || []).filter(r => !((tableWriters[tblNode.name] || []).includes(r)));
    const lookups = (tableLookups[tblNode.name] || []).filter(l => !((tableWriters[tblNode.name] || []).includes(l)));
    readers.forEach(r => {
      if (nodes.find(n => n.id === r)) {
        connections.push({ from: tblNode.id, to: r, label: 'reads', type: 'dependency', color: '#6366F1', width: 1.5 });
      }
    });
    lookups.forEach(l => {
      if (nodes.find(n => n.id === l)) {
        connections.push({ from: tblNode.id, to: l, label: 'lookup', type: 'lookup', color: '#F59E0B', width: 1, dash: true });
      }
    });
  });
  // Direct session → session edges where no intermediate table node exists
  edges.forEach(e => {
    const up = e.upstream || e.upstream_session || e.from;
    const down = e.downstream || e.downstream_session || e.to;
    const via = e.shared_tables ? e.shared_tables.join(', ') : (e.via_table || '');
    // Check if we already have session→table→session path for this edge
    const viaTableNode = via ? nodes.find(n => (n.type === 'table_output' || n.type === 'conflict_gate') && n.name === via) : null;
    if (!viaTableNode) {
      const isConflict = via ? !!(conflictMap[via] && conflictMap[via].length) : false;
      connections.push({
        from: up, to: down, label: via ? 'via ' + via : '',
        type: isConflict ? 'conflict' : 'dependency',
        color: isConflict ? '#EF4444' : '#6366F1', width: isConflict ? 2.5 : 1.5
      });
    }
  });

  // Deduplicate connections (same from→to→type)
  const connKeys = new Set();
  const dedupedConns = [];
  connections.forEach(c => {
    const key = `${c.from}|${c.to}|${c.type}`;
    if (!connKeys.has(key)) { connKeys.add(key); dedupedConns.push(c); }
  });
  connections.length = 0;
  connections.push(...dedupedConns);

  // ── Step 7: Connection density data for sidebar ──
  const densityData = [];
  Object.keys(tableWriters).forEach(tn => {
    const w = (tableWriters[tn] || []).length;
    const r = (tableReaders[tn] || []).filter(x => !(tableWriters[tn] || []).includes(x)).length;
    const l = (tableLookups[tn] || []).filter(x => !(tableWriters[tn] || []).includes(x)).length;
    const total = w + r + l;
    if (total > 0) densityData.push({ name: tn, writers: w, readers: r, lookups: l, total, isConflict: !!(conflictMap[tn] && conflictMap[tn].length) });
  });
  densityData.sort((a, b) => b.total - a.total);

  return { nodes, connections, tierLabels, diagramType: 'dependency_graph', densityData };
}

// ================================================================
// ENVIRONMENT SUMMARY — Source-specific dashboard
// ================================================================
function buildEnvironmentSummary(parsed, bp) {
  if (!parsed) return '';
  const fmt = parsed.input_format || '';
  let h = '<h3>Environment Overview</h3>';
  if (fmt === 'nifi_xml' && parsed._nifi) {
    const nf = parsed._nifi;
    // NiFi environment reconstruction
    const byRole = {};
    nf.processors.forEach(p => {
      const role = classifyNiFiProcessor(p.type);
      if (!byRole[role]) byRole[role] = [];
      byRole[role].push(p);
    });
    h += '<div class="alert alert-info"><strong>NiFi Flow Environment</strong> — reconstructed from template XML</div>';
    h += '<div class="row">';
    // Flow topology card
    h += '<div class="col-3">';
    h += metricsHTML([['Sources', (byRole.source||[]).length], ['Transforms', (byRole.transform||[]).length + (byRole.route||[]).length]]);
    h += '</div><div class="col-3">';
    h += metricsHTML([['Processors', (byRole.process||[]).length], ['Sinks', (byRole.sink||[]).length]]);
    h += '</div><div class="col-3">';
    // Scheduling profile
    const schedTypes = {};
    nf.processors.forEach(p => { const s = p.schedulingStrategy||'TIMER_DRIVEN'; schedTypes[s]=(schedTypes[s]||0)+1; });
    const schedInfo = Object.entries(schedTypes).map(([k,v])=>`${k}: ${v}`).join(', ');
    h += metricsHTML([['Scheduling', schedInfo], ['Controller Svc', nf.controllerServices.length]]);
    h += '</div></div>';
    // Data lineage
    if (nf.sqlTables && nf.sqlTables.length) {
      h += `<div class="alert alert-warn">SQL Lineage: ${nf.sqlTables.length} table references found across processors — ${nf.sqlTables.slice(0,5).join(', ')}${nf.sqlTables.length>5?'...':''}</div>`;
    }
  } else if (fmt === 'dependency_json' && parsed._dependency) {
    const dep = parsed._dependency;
    const allTableCount = Object.keys(dep.allTables || {}).length;
    const conflictCount = dep.conflicts.length;
    h += '<div class="alert alert-info"><strong>ETL Dependency Graph</strong> — session lineage with table-level dependencies</div>';
    h += '<div class="row">';
    h += '<div class="col-3">';
    h += metricsHTML([['Sessions', dep.sessions.length], ['Dep. Edges', dep.edges.length]]);
    h += '</div><div class="col-3">';
    h += metricsHTML([['Tables Referenced', allTableCount], ['Exec. Order Steps', dep.order.length]]);
    h += '</div><div class="col-3">';
    h += metricsHTML([['Conflicts', conflictCount], ['Types', [...new Set(dep.conflicts.map(c=>c.conflict_type))].length || 0]]);
    h += '</div></div>';
    if (conflictCount) {
      h += `<div class="alert alert-warn">${conflictCount} table conflict(s): ${dep.conflicts.slice(0,3).map(c=>c.table_name+' ('+c.conflict_type+')').join(', ')}${conflictCount>3?'...':''}</div>`;
    }
  } else {
    // Generic environment summary
    const totalCols = bp.tables.reduce((a,t)=>a+t.columns.length,0);
    const pkTables = bp.tables.filter(t => t.columns.some(c=>c.is_primary_key));
    const fkCount = bp.relationships.length;
    const types = {};
    bp.tables.forEach(t => t.columns.forEach(c => { types[c.data_type]=(types[c.data_type]||0)+1; }));
    const topTypes = Object.entries(types).sort((a,b)=>b[1]-a[1]).slice(0,5).map(([t,c])=>`${t}(${c})`).join(', ');
    h += `<div class="alert alert-info"><strong>${parsed.source_name||'Source'}</strong> — ${bp.tables.length} tables, ${totalCols} columns, ${fkCount} relationships</div>`;
    h += `<p style="font-size:0.85rem;color:var(--text2);margin:8px 0">Tables with PKs: ${pkTables.length}/${bp.tables.length} · Top types: ${topTypes}</p>`;
    if (fkCount === 0 && bp.tables.length > 1) {
      h += '<div class="alert alert-warn">No foreign key relationships detected — tables will be generated independently</div>';
    }
  }
  return h;
}

// ================================================================
// TIER DIAGRAM — SVG Rendering Engine
// ================================================================
function renderTierDiagram(tierData, containerId, detailId, legendId) {
  const container = document.getElementById(containerId);
  const detailEl = document.getElementById(detailId);
  const legendEl = document.getElementById(legendId);
  if (!container) return;
  container.innerHTML = '';
  container.style.minHeight = '200px';

  const {nodes, connections, tierLabels, diagramType, densityData} = tierData;
  if (!nodes.length) { container.innerHTML = '<p style="text-align:center;padding:20px;color:var(--text2)">No nodes to display</p>'; return; }

  // Multi-select state (closure-scoped)
  const _ms = { selected: [], pathNodes: new Set(), pathEdgeKeys: new Set(), active: false };

  // Group nodes by tier
  const tierGroups = {};
  nodes.forEach(n => {
    if (!tierGroups[n.tier]) tierGroups[n.tier] = [];
    tierGroups[n.tier].push(n);
  });

  // Render tier bands — supports up to 100 tiers, only renders used ones
  const sortedTiers = Object.keys(tierGroups).map(Number).sort((a,b)=>a-b);
  const nodeEls = {};

  sortedTiers.forEach(tier => {
    const config = tierLabels[tier] || {label:`TIER ${tier}`, color:'#808495', bg:'rgba(128,132,149,0.06)'};
    const band = document.createElement('div');
    band.className = 'tier-band';
    band.style.background = config.bg;
    band.style.borderLeft = `3px solid ${config.color}`;

    const label = document.createElement('div');
    label.className = 'tier-band-label';
    label.style.color = config.color;
    label.textContent = config.label;
    band.appendChild(label);

    const nodesDiv = document.createElement('div');
    nodesDiv.className = 'tier-nodes';

    tierGroups[tier].forEach(node => {
      const el = document.createElement('div');
      el.dataset.nodeId = node.id;

      // ── Dependency graph: session nodes ──
      if (node.type === 'session') {
        el.className = 'tier-node';
        if (node.hasConflict) { el.style.borderColor = '#EF4444'; el.style.borderTopColor = '#EF4444'; }
        else if (node.subtype === 'root') el.style.borderTopColor = '#3B82F6';
        else el.style.borderTopColor = '#6366F1';
        el.style.borderTopWidth = '3px';
        // Sequence number badge
        if (node.seq) {
          const seqEl = document.createElement('div');
          seqEl.className = 'node-seq';
          seqEl.textContent = node.seq;
          if (node.hasConflict) seqEl.style.background = '#EF4444';
          el.appendChild(seqEl);
        }
        // Name
        const nameEl = document.createElement('div');
        nameEl.className = 'node-name';
        const shortName = node.name.replace(/^s_m_(?:Load_|LOAD_)?/i, '');
        nameEl.textContent = shortName.length > 22 ? shortName.substring(0, 19) + '...' : shortName;
        nameEl.title = node.name;
        el.appendChild(nameEl);
        // Colored stat badges
        const statsDiv = document.createElement('div');
        statsDiv.className = 'node-stats';
        statsDiv.innerHTML = `<span class="ns ns-tx">${node.srcCount} tx</span><span class="ns ns-ext">${node.tgtCount} ext</span>` + (node.lkpCount ? `<span class="ns ns-lkp">${node.lkpCount} lkp</span>` : '');
        el.appendChild(statsDiv);
        // Conflict badge
        if (node.hasConflict) {
          const badge = document.createElement('div');
          badge.className = 'node-badge red';
          badge.textContent = '!';
          badge.title = node.conflictDetails.map(c => c.table_name + ': ' + c.conflict_type).join(', ');
          el.appendChild(badge);
        }
      }
      // ── Table output nodes ──
      else if (node.type === 'table_output') {
        el.className = 'tier-node table-output';
        if (node.isConflict) { el.style.borderColor = '#EF4444'; }
        else if (node.isChain) { el.style.borderColor = '#F59E0B'; }
        else el.style.borderColor = '#21C354';
        // Icon
        const icon = document.createElement('div');
        icon.style.cssText = 'font-size:0.8rem;margin-bottom:2px';
        icon.textContent = node.isConflict ? '\u26A0' : node.isChain ? '\u2161' : '\u2713';
        el.appendChild(icon);
        const nameEl = document.createElement('div');
        nameEl.className = 'node-name';
        nameEl.textContent = node.name.length > 20 ? node.name.substring(0, 17) + '...' : node.name;
        nameEl.title = node.name;
        el.appendChild(nameEl);
        const cls = document.createElement('div');
        cls.className = 'node-class';
        cls.style.color = node.isConflict ? '#FCA5A5' : node.isChain ? '#FDE68A' : '#86EFAC';
        cls.textContent = node.isConflict ? 'CONFLICT' : node.isChain ? 'CHAIN' : 'INDEPENDENT';
        el.appendChild(cls);
      }
      // ── Conflict gate nodes ──
      else if (node.type === 'conflict_gate') {
        el.className = 'tier-node conflict-gate';
        const icon = document.createElement('div');
        icon.style.cssText = 'font-size:1.2rem;margin-bottom:2px';
        icon.textContent = '\u26A0';
        el.appendChild(icon);
        const nameEl = document.createElement('div');
        nameEl.className = 'node-name';
        nameEl.textContent = node.name.length > 25 ? node.name.substring(0, 22) + '...' : node.name;
        nameEl.title = node.name;
        el.appendChild(nameEl);
        const metaEl = document.createElement('div');
        metaEl.className = 'node-meta';
        metaEl.textContent = `${node.writerCount}W / ${node.readerCount}R / ${node.lookupCount}L`;
        el.appendChild(metaEl);
        const clsEl = document.createElement('div');
        clsEl.className = 'node-class';
        clsEl.style.color = '#FCA5A5';
        clsEl.textContent = 'CONFLICT';
        el.appendChild(clsEl);
      }
      // ── Process group nodes (NiFi) ──
      else if (node.type === 'process_group') {
        el.className = 'tier-node expandable';
        if (node.inCycle) el.classList.add('in-cycle');
        const roleColor = ROLE_TIER_COLORS[node.dominantRole] || '#6366F1';
        el.style.borderTopColor = roleColor;
        el.style.borderTopWidth = '3px';
        el.style.minWidth = '160px';
        el.style.maxWidth = '240px';
        // Cycle badge
        if (node.inCycle) {
          const cyBadge = document.createElement('div');
          cyBadge.className = 'cycle-badge';
          cyBadge.textContent = '\u21BB';
          cyBadge.title = 'Cycle: ' + node.sccMembers.filter(g => g !== node.name).join(', ');
          el.appendChild(cyBadge);
        }
        // Name
        const nameEl = document.createElement('div');
        nameEl.className = 'node-name';
        nameEl.textContent = node.name.length > 28 ? node.name.substring(0, 25) + '...' : node.name;
        nameEl.title = node.name;
        el.appendChild(nameEl);
        // Processor count badge
        const badge = document.createElement('div');
        badge.className = 'node-badge';
        badge.textContent = node.procCount;
        badge.title = node.procCount + ' processors';
        el.appendChild(badge);
        // Colored stat badges
        const statsDiv = document.createElement('div');
        statsDiv.className = 'node-stats';
        if (node.srcCount) statsDiv.innerHTML += `<span class="ns ns-tx">${node.srcCount} src</span>`;
        if (node.transformCount + node.routeCount) statsDiv.innerHTML += `<span class="ns" style="background:#A855F7;color:white">${node.transformCount + node.routeCount} xfm</span>`;
        if (node.processCount) statsDiv.innerHTML += `<span class="ns ns-ext">${node.processCount} proc</span>`;
        if (node.sinkCount) statsDiv.innerHTML += `<span class="ns" style="background:#21C354;color:white">${node.sinkCount} sink</span>`;
        if (node.utilityCount) statsDiv.innerHTML += `<span class="ns" style="background:#808495;color:white">${node.utilityCount} util</span>`;
        el.appendChild(statsDiv);
        // Expand indicator
        const expandInd = document.createElement('div');
        expandInd.className = 'expand-indicator';
        expandInd.textContent = '\u25B6 expand';
        el.appendChild(expandInd);
      }
      // ── Generic nodes (NiFi processors, SQL, flat) ──
      else {
        el.className = 'tier-node';
        if (node.state === 'DISABLED' || node.state === 'STOPPED') el.style.opacity = '0.5';
        if (node.subtype === 'source') el.style.borderTopColor = '#3B82F6';
        else if (node.subtype === 'sink') el.style.borderTopColor = '#21C354';
        else if (node.subtype === 'route') el.style.borderTopColor = '#EAB308';
        else if (node.subtype === 'transform') el.style.borderTopColor = '#A855F7';
        else if (node.type === 'table') el.style.borderTopColor = '#3B82F6';
        el.style.borderTopWidth = '3px';
        const nameEl = document.createElement('div');
        nameEl.className = 'node-name';
        nameEl.textContent = node.name.length > 25 ? node.name.substring(0, 22) + '...' : node.name;
        nameEl.title = node.name;
        el.appendChild(nameEl);
        if (node.meta) {
          const metaEl = document.createElement('div');
          metaEl.className = 'node-meta';
          metaEl.textContent = node.meta;
          el.appendChild(metaEl);
        }
        if (node.rows) {
          const badge = document.createElement('div');
          badge.className = 'node-badge';
          badge.textContent = node.rows >= 1000 ? Math.round(node.rows / 1000) + 'K' : node.rows;
          el.appendChild(badge);
        }
      }

      // Hover: highlight connected (suppressed during multi-select)
      el.addEventListener('mouseenter', () => { if (!_ms.active) highlightConnected(node.id, nodes, connections, nodeEls, container); });
      el.addEventListener('mouseleave', () => { if (!_ms.active) clearHighlight(nodeEls, container); });
      // Click: route tracing + expand + detail
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        if (_ms.active && !_ms.selected.includes(node.id)) {
          // Route tracing: add this node to the route
          addToRouteTrace(node.id, _ms, connections, nodeEls, container);
          showNodeDetail(node, detailEl, diagramType);
        } else if (_ms.active && _ms.selected.includes(node.id)) {
          // Clicking an already-selected node: expand it (if process group)
          if (node.type === 'process_group' && node.expandable) {
            toggleGroupExpand(node, el, band, tierData, nodeEls, container, detailEl, diagramType);
          }
          showNodeDetail(node, detailEl, diagramType);
        } else {
          // First click: start route trace + expand if process group
          startRouteTrace(node.id, _ms, connections, nodeEls, container);
          if (node.type === 'process_group' && node.expandable) {
            toggleGroupExpand(node, el, band, tierData, nodeEls, container, detailEl, diagramType);
          }
          showNodeDetail(node, detailEl, diagramType);
        }
      });

      nodesDiv.appendChild(el);
      nodeEls[node.id] = el;
    });

    band.appendChild(nodesDiv);
    container.appendChild(band);
  });

  // Render SVG connections after DOM is laid out
  requestAnimationFrame(() => {
    renderConnections(container, connections, nodeEls);
  });

  // Escape clears route trace; click empty space clears
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && _ms.active) clearRouteTrace(_ms, nodeEls, container);
  });
  container.addEventListener('click', (e) => {
    if ((e.target === container || e.target.classList.contains('tier-band') || e.target.classList.contains('tier-band-label')) && _ms.active) {
      clearRouteTrace(_ms, nodeEls, container);
    }
  });

  // Connection density sidebar — now an active filter
  const sidebarEl = document.getElementById('tierDensitySidebar');
  const barsEl = document.getElementById('densityBars');
  const _sidebarFilter = { activeTypes: new Set() };
  if (sidebarEl && barsEl && densityData && densityData.length) {
    sidebarEl.classList.remove('hidden');
    const sidebarTitle = sidebarEl.querySelector('h4');
    if (sidebarTitle) sidebarTitle.textContent = diagramType === 'nifi_flow' ? 'Filter by Type' : 'Connection Density';
    barsEl.innerHTML = '';
    // Add hint for NiFi
    if (diagramType === 'nifi_flow') {
      const hint = document.createElement('div');
      hint.className = 'sidebar-filter-hint';
      hint.textContent = 'Click to filter diagram';
      barsEl.appendChild(hint);
    }
    const maxTotal = Math.max(...densityData.map(d => d.total));
    // Pre-build type→group mapping for NiFi filter
    const typeToGroups = {};
    if (diagramType === 'nifi_flow') {
      nodes.forEach(n => {
        if (n.type === 'process_group' && n.detail && n.detail.typeCount) {
          Object.keys(n.detail.typeCount).forEach(t => {
            if (!typeToGroups[t]) typeToGroups[t] = new Set();
            typeToGroups[t].add(n.id);
          });
        }
      });
    }
    densityData.forEach(d => {
      const row = document.createElement('div');
      row.className = 'density-row';
      row.dataset.typeName = d.name;
      if (d.role) {
        const roleColors = { source:'#3B82F6', sink:'#21C354', route:'#EAB308', transform:'#A855F7', process:'#6366F1', utility:'#808495' };
        const barW = Math.max(4, (d.total / maxTotal) * 80);
        row.innerHTML = `<span class="density-bar" style="width:${barW}px;background:${roleColors[d.role]||'#808495'}" title="${d.total}x"></span><span class="density-label" title="${d.name}">${d.name} (${d.total})</span>`;
      } else {
        const wPct = Math.max(2, (d.writers / maxTotal) * 60);
        const rPct = Math.max(0, (d.readers / maxTotal) * 60);
        const lPct = Math.max(0, (d.lookups / maxTotal) * 60);
        let barsHTML = `<span class="density-bar" style="width:${wPct}px;background:#EF4444" title="${d.writers} writer(s)"></span>`;
        if (d.readers) barsHTML += `<span class="density-bar" style="width:${rPct}px;background:#3B82F6" title="${d.readers} reader(s)"></span>`;
        if (d.lookups) barsHTML += `<span class="density-bar" style="width:${lPct}px;background:#F59E0B" title="${d.lookups} lookup(s)"></span>`;
        row.innerHTML = barsHTML + `<span class="density-label" title="${d.name}">${d.name}</span>`;
      }
      // Click handler for filter
      if (diagramType === 'nifi_flow') {
        row.addEventListener('click', () => {
          if (_ms.active) clearRouteTrace(_ms, nodeEls, container);
          const typeName = d.name;
          if (_sidebarFilter.activeTypes.has(typeName)) {
            _sidebarFilter.activeTypes.delete(typeName);
            row.classList.remove('filter-active');
          } else {
            _sidebarFilter.activeTypes.add(typeName);
            row.classList.add('filter-active');
          }
          applySidebarFilter(_sidebarFilter, typeToGroups, nodes, connections, nodeEls, container, barsEl);
        });
      }
      barsEl.appendChild(row);
    });
    // Clear filter button
    if (diagramType === 'nifi_flow') {
      const clearBtn = document.createElement('div');
      clearBtn.className = 'sidebar-clear-btn';
      clearBtn.id = 'sidebarClearBtn';
      clearBtn.textContent = '\u2715 Clear filter';
      clearBtn.addEventListener('click', () => {
        _sidebarFilter.activeTypes.clear();
        barsEl.querySelectorAll('.density-row').forEach(r => r.classList.remove('filter-active','filter-dimmed'));
        clearSidebarFilter(nodeEls, container);
        clearBtn.style.display = 'none';
      });
      barsEl.appendChild(clearBtn);
    }
  } else if (sidebarEl) {
    sidebarEl.classList.add('hidden');
  }

  // Legend
  if (legendEl) {
    legendEl.innerHTML = '';
    const sessionCount = nodes.filter(n => n.type === 'session').length;
    const tableCount = nodes.filter(n => n.type === 'table_output' || n.type === 'conflict_gate').length;
    if (diagramType === 'dependency_graph') {
      legendEl.innerHTML = [
        `<span>${sessionCount} Sessions</span>`,
        `<span>${tableCount} Tables</span>`,
        `<span style="color:#EF4444">${nodes.filter(n => n.hasConflict || n.type === 'conflict_gate').length} Conflicts</span>`,
        '<span><span class="leg-line" style="background:#6366F1"></span> Dependency</span>',
        '<span><span class="leg-line" style="background:#F59E0B;border-top:2px dashed #F59E0B"></span> Lookup</span>',
        '<span><span class="leg-line" style="background:#EF4444"></span> Conflict</span>',
        '<span><span class="leg-line" style="background:#21C354"></span> Independent</span>',
        '<span><span class="leg-line" style="background:#F59E0B"></span> Chain</span>',
      ].join('');
    } else if (diagramType === 'nifi_flow') {
      const pgCount = nodes.filter(n => n.type === 'process_group').length;
      const procCount = nodes.filter(n => n.type === 'processor').length;
      const cycleCount = tierData.cycleData ? tierData.cycleData.length : 0;
      legendEl.innerHTML = [
        `<span>${pgCount} Process Groups</span>`,
        procCount ? `<span>${procCount} Processors</span>` : '',
        `<span>${connections.length} Connections</span>`,
        cycleCount ? `<span style="color:#EF4444">${cycleCount} Cycle(s)</span>` : '',
        '<span><span class="leg-line" style="background:#3B82F6"></span> Source</span>',
        '<span><span class="leg-line" style="background:#EAB308"></span> Route</span>',
        '<span><span class="leg-line" style="background:#A855F7"></span> Transform</span>',
        '<span><span class="leg-line" style="background:#6366F1"></span> Process</span>',
        '<span><span class="leg-line" style="background:#21C354"></span> Sink</span>',
        '<span><span class="leg-line" style="background:#EF4444;border-top:2px dashed #EF4444"></span> Cycle Edge</span>',
        '<span style="color:var(--text2);font-size:0.7rem">Click nodes to trace route · Esc to clear</span>',
      ].join('');
    } else if (diagramType === 'sql_tables') {
      legendEl.innerHTML = [
        '<span><span class="leg-line" style="background:#3B82F6;border-top:2px solid #3B82F6"></span> Foreign Key</span>',
        `<span>${nodes.length} tables · ${connections.length} relationships</span>`,
      ].join('');
    } else {
      legendEl.innerHTML = [
        `<span>${nodes.length} objects</span>`,
        connections.length ? `<span><span class="leg-line" style="background:#4B5563;border-top:2px dashed #4B5563"></span> Shared columns</span>` : '',
      ].join('');
    }
  }

  document.getElementById('tierDiagramContainer').classList.remove('hidden');
}

function renderConnections(container, connections, nodeEls) {
  // Remove old SVG
  const oldSvg = container.querySelector('svg.tier-svg');
  if (oldSvg) oldSvg.remove();

  if (!connections.length) return;

  const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  svg.classList.add('tier-svg');
  svg.style.position = 'absolute';
  svg.style.top = '0';
  svg.style.left = '0';
  svg.style.width = container.scrollWidth + 'px';
  svg.style.height = container.scrollHeight + 'px';
  svg.style.pointerEvents = 'none';
  svg.style.zIndex = '1';
  svg.setAttribute('viewBox', `0 0 ${container.scrollWidth} ${container.scrollHeight}`);

  // Defs: arrow markers (default + highlighted variants) and glow filter
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  // Glow filter for highlighted paths
  const filter = document.createElementNS('http://www.w3.org/2000/svg','filter');
  filter.setAttribute('id','glow');
  filter.setAttribute('x','-50%'); filter.setAttribute('y','-50%');
  filter.setAttribute('width','200%'); filter.setAttribute('height','200%');
  const blur = document.createElementNS('http://www.w3.org/2000/svg','feGaussianBlur');
  blur.setAttribute('stdDeviation','3'); blur.setAttribute('result','blur');
  filter.appendChild(blur);
  const merge = document.createElementNS('http://www.w3.org/2000/svg','feMerge');
  const mn1 = document.createElementNS('http://www.w3.org/2000/svg','feMergeNode');
  mn1.setAttribute('in','blur');
  const mn2 = document.createElementNS('http://www.w3.org/2000/svg','feMergeNode');
  mn2.setAttribute('in','SourceGraphic');
  merge.appendChild(mn1); merge.appendChild(mn2);
  filter.appendChild(merge);
  defs.appendChild(filter);
  // Arrow markers for each color
  const arrowColors = {'default':'#4B5563','blue':'#3B82F6','purple':'#6366F1','red':'#EF4444','amber':'#F59E0B','green':'#21C354','white':'#FAFAFA'};
  Object.entries(arrowColors).forEach(([name, color]) => {
    const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
    marker.setAttribute('id', 'arrow-' + name);
    marker.setAttribute('viewBox','0 0 10 8');
    marker.setAttribute('refX','10'); marker.setAttribute('refY','4');
    marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','6');
    marker.setAttribute('orient','auto');
    const ap = document.createElementNS('http://www.w3.org/2000/svg','path');
    ap.setAttribute('d','M0,0 L10,4 L0,8 Z'); ap.setAttribute('fill', color);
    marker.appendChild(ap); defs.appendChild(marker);
  });
  svg.appendChild(defs);

  const cRect = container.getBoundingClientRect();

  connections.forEach(conn => {
    const fromEl = nodeEls[conn.from];
    const toEl = nodeEls[conn.to];
    if (!fromEl || !toEl) return;

    const fromRect = fromEl.getBoundingClientRect();
    const toRect = toEl.getBoundingClientRect();

    const fromX = fromRect.left + fromRect.width/2 - cRect.left + container.scrollLeft;
    const fromY = fromRect.top + fromRect.height - cRect.top + container.scrollTop;
    const toX = toRect.left + toRect.width/2 - cRect.left + container.scrollLeft;
    const toY = toRect.top - cRect.top + container.scrollTop;

    const dy = toY - fromY;
    const cp = Math.max(Math.abs(dy) * 0.35, 30);
    const cpx = (toX - fromX) * 0.15;

    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('d', `M${fromX},${fromY} C${fromX+cpx},${fromY+cp} ${toX-cpx},${toY-cp} ${toX},${toY}`);
    const strokeColor = conn.color || '#4B5563';
    path.setAttribute('stroke', strokeColor);
    path.setAttribute('stroke-width', String(conn.width || 1.5));
    path.setAttribute('fill', 'none');
    // Pick arrow marker by closest color
    const arrowId = strokeColor.includes('EF44') ? 'arrow-red' : strokeColor.includes('F59E') || strokeColor.includes('F5') ? 'arrow-amber' : strokeColor.includes('6366') ? 'arrow-purple' : strokeColor.includes('3B82') ? 'arrow-blue' : strokeColor.includes('21C3') ? 'arrow-green' : 'arrow-default';
    path.setAttribute('marker-end', `url(#${arrowId})`);
    path.setAttribute('opacity', '0.35');
    path.dataset.from = conn.from;
    path.dataset.to = conn.to;
    path.dataset.origColor = strokeColor;
    path.dataset.origWidth = String(conn.width || 1.5);
    if (conn.dash) path.setAttribute('stroke-dasharray', '6,4');
    if (conn.inCycle) path.setAttribute('stroke-dasharray', '8,4');
    svg.appendChild(path);
  });

  container.style.position = 'relative';
  container.insertBefore(svg, container.firstChild);
}

function highlightConnected(nodeId, nodes, connections, nodeEls, container) {
  // ── Trace the FULL path in both directions (upstream + downstream) ──
  const pathNodes = new Set([nodeId]);
  const pathEdges = new Set();  // "from|to" keys of edges in the path

  // BFS downstream: follow all connections FROM this node recursively
  function traceDown(id) {
    connections.forEach((c, i) => {
      const key = c.from + '|' + c.to;
      if (c.from === id && !pathEdges.has(key)) {
        pathEdges.add(key);
        pathNodes.add(c.to);
        traceDown(c.to);
      }
    });
  }
  // BFS upstream: follow all connections TO this node recursively
  function traceUp(id) {
    connections.forEach((c, i) => {
      const key = c.from + '|' + c.to;
      if (c.to === id && !pathEdges.has(key)) {
        pathEdges.add(key);
        pathNodes.add(c.from);
        traceUp(c.from);
      }
    });
  }
  traceDown(nodeId);
  traceUp(nodeId);

  // Dim all nodes, highlight path nodes
  Object.entries(nodeEls).forEach(([id, el]) => {
    if (pathNodes.has(id)) {
      el.classList.add('highlighted'); el.classList.remove('dimmed');
      if (id === nodeId) el.classList.add('selected');
    } else {
      el.classList.add('dimmed'); el.classList.remove('highlighted', 'selected');
    }
  });

  // Highlight SVG paths — glow effect on path edges, dim everything else
  const svg = container.querySelector('svg.tier-svg');
  if (svg) {
    svg.querySelectorAll('path[data-from]').forEach(p => {
      const edgeKey = p.dataset.from + '|' + p.dataset.to;
      if (pathEdges.has(edgeKey)) {
        // Full path highlight: bright, thick, glowing
        p.setAttribute('opacity', '1');
        p.setAttribute('stroke', '#FAFAFA');
        p.setAttribute('stroke-width', '3');
        p.setAttribute('filter', 'url(#glow)');
        p.setAttribute('marker-end', 'url(#arrow-white)');
        p.style.transition = 'all 0.2s ease';
      } else {
        p.setAttribute('opacity', '0.08');
        p.removeAttribute('filter');
      }
    });
  }
}

function clearHighlight(nodeEls, container) {
  Object.values(nodeEls).forEach(el => { el.classList.remove('highlighted', 'dimmed', 'selected'); });
  const svg = container.querySelector('svg.tier-svg');
  if (svg) {
    svg.querySelectorAll('path[data-from]').forEach(p => {
      p.setAttribute('opacity', '0.35');
      p.setAttribute('stroke', p.dataset.origColor || '#4B5563');
      p.setAttribute('stroke-width', p.dataset.origWidth || '1.5');
      p.removeAttribute('filter');
      // Restore original arrow marker
      const c = p.dataset.origColor || '';
      const arrowId = c.includes('EF44') ? 'arrow-red' : c.includes('F59E') || c.includes('F5') ? 'arrow-amber' : c.includes('6366') ? 'arrow-purple' : c.includes('3B82') ? 'arrow-blue' : c.includes('21C3') ? 'arrow-green' : 'arrow-default';
      p.setAttribute('marker-end', `url(#${arrowId})`);
      p.style.transition = '';
    });
  }
}

// ── Expand/collapse a process group ──
function toggleGroupExpand(node, el, parentBand, tierData, nodeEls, container, detailEl, diagramType) {
  const subBandId = 'sub_' + node.id;
  const existing = container.querySelector(`[data-sub-band="${subBandId}"]`);
  if (existing) {
    existing.remove();
    el.classList.remove('expanded');
    const ind = el.querySelector('.expand-indicator');
    if (ind) ind.textContent = '\u25B6 expand';
    Object.keys(nodeEls).forEach(k => { if (k.startsWith('proc_' + node.name + '|')) delete nodeEls[k]; });
    requestAnimationFrame(() => renderConnections(container, tierData.connections, nodeEls));
    return;
  }
  el.classList.add('expanded');
  const ind = el.querySelector('.expand-indicator');
  if (ind) ind.textContent = '\u25BC collapse';
  const processors = (node.detail && node.detail.processors) || [];
  const ROLE_ORDER = ['source','route','transform','process','sink','utility'];
  const ROLE_NAMES = {source:'Sources',route:'Routing',transform:'Transforms',process:'Processing',sink:'Sinks',utility:'Utility'};
  const subBand = document.createElement('div');
  subBand.className = 'tier-sub-band';
  subBand.dataset.subBand = subBandId;
  ROLE_ORDER.forEach(role => {
    const procs = processors.filter(p => classifyNiFiProcessor(p.type) === role);
    if (!procs.length) return;
    const roleLabel = document.createElement('div');
    roleLabel.className = 'tier-band-label';
    roleLabel.style.color = ROLE_TIER_COLORS[role] || '#808495';
    roleLabel.textContent = `${node.name} \u2192 ${ROLE_NAMES[role]} (${procs.length})`;
    subBand.appendChild(roleLabel);
    const nodesDiv = document.createElement('div');
    nodesDiv.className = 'tier-nodes';
    procs.forEach(p => {
      const procEl = document.createElement('div');
      procEl.className = 'tier-node';
      const procId = 'proc_' + node.name + '|' + p.name;
      procEl.dataset.nodeId = procId;
      if (p.state === 'DISABLED' || p.state === 'STOPPED') procEl.style.opacity = '0.5';
      procEl.style.borderTopColor = ROLE_TIER_COLORS[role] || '#808495';
      procEl.style.borderTopWidth = '3px';
      const nameEl = document.createElement('div');
      nameEl.className = 'node-name';
      nameEl.textContent = p.name.length > 20 ? p.name.substring(0, 17) + '...' : p.name;
      nameEl.title = p.name;
      procEl.appendChild(nameEl);
      const metaEl = document.createElement('div');
      metaEl.className = 'node-meta';
      metaEl.textContent = p.type;
      procEl.appendChild(metaEl);
      procEl.addEventListener('click', (e) => {
        e.stopPropagation();
        showNodeDetail({name:p.name, type:'processor', subtype:role, meta:p.type, group:node.name, state:p.state, propCount:Object.keys(p.properties||{}).length, detail:p}, detailEl, diagramType);
      });
      nodesDiv.appendChild(procEl);
      nodeEls[procId] = procEl;
    });
    subBand.appendChild(nodesDiv);
  });
  parentBand.after(subBand);
  requestAnimationFrame(() => renderConnections(container, tierData.connections, nodeEls));
}

// ── Progressive route tracing ──
// BFS all reachable nodes (both directions) from a starting node
function bfsReachable(nodeId, connections) {
  const reachNodes = new Set([nodeId]);
  const reachEdges = new Set();
  const queue = [nodeId];
  // Downstream
  const visited = new Set([nodeId]);
  while (queue.length) {
    const cur = queue.shift();
    connections.forEach(c => {
      if (c.from === cur && !visited.has(c.to)) {
        visited.add(c.to); reachNodes.add(c.to); reachEdges.add(c.from + '|' + c.to); queue.push(c.to);
      }
    });
  }
  // Upstream
  const queue2 = [nodeId];
  const visited2 = new Set([nodeId]);
  while (queue2.length) {
    const cur = queue2.shift();
    connections.forEach(c => {
      if (c.to === cur && !visited2.has(c.from)) {
        visited2.add(c.from); reachNodes.add(c.from); reachEdges.add(c.from + '|' + c.to); queue2.push(c.from);
      }
    });
  }
  return { reachNodes, reachEdges };
}

function startRouteTrace(nodeId, ms, connections, nodeEls, container) {
  ms.selected = [nodeId];
  ms.active = true;
  // First click: show all reachable from this node, dim everything else
  const { reachNodes, reachEdges } = bfsReachable(nodeId, connections);
  ms.pathNodes = reachNodes;
  ms.pathEdgeKeys = reachEdges;
  applyRouteVisuals(ms, nodeEls, container);
  showPathToast(ms);
}

function addToRouteTrace(nodeId, ms, connections, nodeEls, container) {
  if (ms.selected.includes(nodeId)) return;
  ms.selected.push(nodeId);
  if (ms.selected.length === 2) {
    // Two nodes: find the specific path between them
    const a = ms.selected[0], b = ms.selected[1];
    let result = bfsShortestPath(connections, a, b);
    if (!result.found) result = bfsShortestPath(connections, b, a);
    if (!result.found) {
      const bi = connections.flatMap(c => [c, {from:c.to,to:c.from,label:c.label,type:c.type,color:c.color,width:c.width}]);
      result = bfsShortestPath(bi, a, b);
    }
    if (result.found) {
      ms.pathNodes = new Set(result.pathNodes);
      ms.pathEdgeKeys = new Set(result.pathEdgeKeys);
    } else {
      // No path — keep both selected, show nothing between
      ms.pathNodes = new Set(ms.selected);
      ms.pathEdgeKeys = new Set();
      flashNoPath();
    }
  } else {
    // 3+ nodes: extend from last-but-one to new node via existing path
    const prev = ms.selected[ms.selected.length - 2];
    let result = bfsShortestPath(connections, prev, nodeId);
    if (!result.found) result = bfsShortestPath(connections, nodeId, prev);
    if (!result.found) {
      const bi = connections.flatMap(c => [c, {from:c.to,to:c.from,label:c.label,type:c.type,color:c.color,width:c.width}]);
      result = bfsShortestPath(bi, prev, nodeId);
    }
    if (result.found) {
      result.pathNodes.forEach(n => ms.pathNodes.add(n));
      result.pathEdgeKeys.forEach(k => ms.pathEdgeKeys.add(k));
    } else {
      ms.pathNodes.add(nodeId);
      flashNoPath();
    }
  }
  applyRouteVisuals(ms, nodeEls, container);
  showPathToast(ms);
}

function applyRouteVisuals(ms, nodeEls, container) {
  Object.entries(nodeEls).forEach(([id, el]) => {
    el.classList.remove('path-selected','path-member','path-dimmed','highlighted','dimmed','selected');
    if (ms.selected.includes(id)) el.classList.add('path-selected');
    else if (ms.pathNodes.has(id)) el.classList.add('path-member');
    else el.classList.add('path-dimmed');
  });
  const svg = container.querySelector('svg.tier-svg');
  if (svg) {
    svg.querySelectorAll('path[data-from]').forEach(p => {
      const fwd = p.dataset.from + '|' + p.dataset.to;
      const rev = p.dataset.to + '|' + p.dataset.from;
      if (ms.pathEdgeKeys.has(fwd) || ms.pathEdgeKeys.has(rev)) {
        p.setAttribute('opacity','1');
        p.setAttribute('stroke','#FACA15');
        p.setAttribute('stroke-width','3');
        p.setAttribute('filter','url(#glow)');
        p.setAttribute('marker-end','url(#arrow-white)');
        p.style.transition = 'all 0.2s ease';
      } else {
        p.setAttribute('opacity','0.04');
        p.removeAttribute('filter');
        p.style.transition = 'all 0.2s ease';
      }
    });
  }
}

function clearRouteTrace(ms, nodeEls, container) {
  ms.selected = [];
  ms.pathNodes = new Set();
  ms.pathEdgeKeys = new Set();
  ms.active = false;
  Object.values(nodeEls).forEach(el => { el.classList.remove('path-selected','path-member','path-dimmed'); });
  const svg = container.querySelector('svg.tier-svg');
  if (svg) {
    svg.querySelectorAll('path[data-from]').forEach(p => {
      p.setAttribute('opacity','0.35');
      p.setAttribute('stroke', p.dataset.origColor || '#4B5563');
      p.setAttribute('stroke-width', p.dataset.origWidth || '1.5');
      p.removeAttribute('filter');
      const c = p.dataset.origColor || '';
      const arrowId = c.includes('EF44') ? 'arrow-red' : c.includes('F59E')||c.includes('F5') ? 'arrow-amber' : c.includes('6366') ? 'arrow-purple' : c.includes('3B82') ? 'arrow-blue' : c.includes('21C3') ? 'arrow-green' : 'arrow-default';
      p.setAttribute('marker-end', `url(#${arrowId})`);
      p.style.transition = '';
    });
  }
  hidePathToast();
}

function showPathToast(ms) {
  let toast = document.getElementById('pathTraceToast');
  if (!toast) {
    toast = document.createElement('div');
    toast.id = 'pathTraceToast';
    toast.className = 'path-trace-toast';
    document.body.appendChild(toast);
  }
  const count = ms.selected.length;
  const pathLen = ms.pathNodes.size;
  let msg = count === 1 ? '1 node selected — click another to trace route'
    : `${count} nodes selected — ${pathLen} in path`;
  toast.innerHTML = `<span>${msg}</span>` +
    `<span class="toast-hint">Click nodes to build route</span>` +
    `<span class="toast-clear" id="pathTraceToastClear">\u2715 Clear</span>`;
  toast.style.display = 'flex';
  document.getElementById('pathTraceToastClear').onclick = () => { toast.style.display = 'none'; };
}

function hidePathToast() {
  const toast = document.getElementById('pathTraceToast');
  if (toast) toast.style.display = 'none';
}

function flashNoPath() {
  const toast = document.getElementById('pathTraceToast');
  if (toast) {
    const noPath = document.createElement('span');
    noPath.style.cssText = 'color:var(--red);margin-left:8px';
    noPath.textContent = 'No direct path';
    toast.appendChild(noPath);
    setTimeout(() => { if (noPath.parentNode) noPath.remove(); }, 2500);
  }
}

// ── Sidebar filter ──
function applySidebarFilter(sf, typeToGroups, nodes, connections, nodeEls, container, barsEl) {
  const clearBtn = document.getElementById('sidebarClearBtn');
  if (!sf.activeTypes.size) {
    clearSidebarFilter(nodeEls, container);
    barsEl.querySelectorAll('.density-row').forEach(r => r.classList.remove('filter-dimmed'));
    if (clearBtn) clearBtn.style.display = 'none';
    return;
  }
  if (clearBtn) clearBtn.style.display = 'block';
  // Find all groups that contain ANY of the selected types
  const matchingGroups = new Set();
  sf.activeTypes.forEach(t => {
    if (typeToGroups[t]) typeToGroups[t].forEach(g => matchingGroups.add(g));
  });
  // Find connections between matching groups
  const matchingEdges = new Set();
  connections.forEach(c => {
    if (matchingGroups.has(c.from) && matchingGroups.has(c.to)) {
      matchingEdges.add(c.from + '|' + c.to);
    }
  });
  // Apply visuals to nodes
  Object.entries(nodeEls).forEach(([id, el]) => {
    el.classList.remove('path-selected','path-member','path-dimmed','highlighted','dimmed','selected');
    if (matchingGroups.has(id)) {
      el.classList.add('path-member');
    } else {
      el.classList.add('path-dimmed');
    }
  });
  // Apply visuals to SVG edges
  const svg = container.querySelector('svg.tier-svg');
  if (svg) {
    svg.querySelectorAll('path[data-from]').forEach(p => {
      const fwd = p.dataset.from + '|' + p.dataset.to;
      if (matchingEdges.has(fwd)) {
        p.setAttribute('opacity','0.8');
        p.setAttribute('stroke', p.dataset.origColor || '#4B5563');
        p.setAttribute('stroke-width', p.dataset.origWidth || '1.5');
      } else {
        p.setAttribute('opacity','0.04');
      }
    });
  }
  // Dim non-active sidebar rows
  barsEl.querySelectorAll('.density-row').forEach(r => {
    if (sf.activeTypes.has(r.dataset.typeName)) r.classList.remove('filter-dimmed');
    else r.classList.add('filter-dimmed');
  });
}

function clearSidebarFilter(nodeEls, container) {
  Object.values(nodeEls).forEach(el => { el.classList.remove('path-selected','path-member','path-dimmed'); });
  const svg = container.querySelector('svg.tier-svg');
  if (svg) {
    svg.querySelectorAll('path[data-from]').forEach(p => {
      p.setAttribute('opacity','0.35');
      p.setAttribute('stroke', p.dataset.origColor || '#4B5563');
      p.setAttribute('stroke-width', p.dataset.origWidth || '1.5');
      p.removeAttribute('filter');
      const c = p.dataset.origColor || '';
      const arrowId = c.includes('EF44') ? 'arrow-red' : c.includes('F59E')||c.includes('F5') ? 'arrow-amber' : c.includes('6366') ? 'arrow-purple' : c.includes('3B82') ? 'arrow-blue' : c.includes('21C3') ? 'arrow-green' : 'arrow-default';
      p.setAttribute('marker-end', `url(#${arrowId})`);
      p.style.transition = '';
    });
  }
}

function showNodeDetail(node, detailEl, diagramType) {
  if (!detailEl) return;
  let h = '<div class="node-detail">';
  h += `<h4>${node.name}</h4>`;
  if (diagramType === 'nifi_flow' && node.type === 'process_group' && node.detail) {
    const d = node.detail;
    h += `<p><strong>Processors:</strong> ${node.procCount} · <strong>Internal Connections:</strong> ${d.intraConns || 0}</p>`;
    // Role breakdown
    h += '<div style="display:flex;gap:6px;flex-wrap:wrap;margin:8px 0">';
    if (node.srcCount) h += `<span class="ns ns-tx">${node.srcCount} sources</span>`;
    if (node.routeCount) h += `<span class="ns" style="background:#EAB308;color:#000">${node.routeCount} routes</span>`;
    if (node.transformCount) h += `<span class="ns" style="background:#A855F7;color:white">${node.transformCount} transforms</span>`;
    if (node.processCount) h += `<span class="ns ns-ext">${node.processCount} processors</span>`;
    if (node.sinkCount) h += `<span class="ns" style="background:#21C354;color:white">${node.sinkCount} sinks</span>`;
    if (node.utilityCount) h += `<span class="ns" style="background:#808495;color:white">${node.utilityCount} utility</span>`;
    h += '</div>';
    // Processor type breakdown
    if (d.typeCount) {
      const types = Object.entries(d.typeCount).sort((a, b) => b[1] - a[1]);
      h += '<table style="font-size:0.75rem"><thead><tr><th>Processor Type</th><th>Count</th></tr></thead><tbody>';
      types.slice(0, 15).forEach(([t, c]) => { h += `<tr><td>${t}</td><td>${c}</td></tr>`; });
      if (types.length > 15) h += `<tr><td colspan="2" style="color:var(--text2)">+${types.length - 15} more types</td></tr>`;
      h += '</tbody></table>';
    }
    // First few processor names
    if (d.processors && d.processors.length) {
      h += `<p style="margin-top:8px"><strong>Processors (first 10):</strong></p>`;
      h += '<ul style="font-size:0.75rem;margin:4px 0 4px 16px">';
      d.processors.slice(0, 10).forEach(p => { h += `<li>${p.name} <code style="font-size:0.65rem">${p.type}</code></li>`; });
      if (d.processors.length > 10) h += `<li style="color:var(--text2)">+${d.processors.length - 10} more</li>`;
      h += '</ul>';
    }
    // Cycle information
    if (node.inCycle && node.sccMembers) {
      h += '<div style="margin:8px 0;padding:8px 12px;border:1px solid #EF4444;border-radius:6px;background:rgba(239,68,68,0.08);font-size:0.8rem">';
      h += '<strong style="color:#EF4444">Circular Dependency Detected</strong><br>';
      h += 'Cycle with: ' + node.sccMembers.filter(g => g !== node.name).join(', ');
      if (node.cycleEdges && node.cycleEdges.length) {
        h += '<br><br><strong>Cycle edges:</strong><br>';
        node.cycleEdges.forEach(ce => { h += `${ce.from} \u2192 ${ce.to} (${ce.count} flow${ce.count>1?'s':''})<br>`; });
      }
      h += '</div>';
    }
  } else if (diagramType === 'nifi_flow' && node.detail) {
    const p = node.detail;
    h += `<p><strong>Type:</strong> ${p.type} <code style="font-size:0.7rem">${p.fullType||''}</code></p>`;
    h += `<p><strong>Group:</strong> ${p.group || '(root)'}</p>`;
    h += `<p><strong>State:</strong> ${p.state || 'N/A'}</p>`;
    if (p.schedulingStrategy) h += `<p><strong>Scheduling:</strong> ${p.schedulingStrategy} / ${p.schedulingPeriod}</p>`;
    const propKeys = Object.keys(p.properties);
    if (propKeys.length) {
      h += `<p><strong>Properties (${propKeys.length}):</strong></p><pre style="max-height:200px;overflow:auto;font-size:0.75rem">`;
      propKeys.slice(0,20).forEach(k => { h += `${k}: ${(p.properties[k]||'').substring(0,100)}\n`; });
      if (propKeys.length > 20) h += `... +${propKeys.length-20} more\n`;
      h += '</pre>';
    }
  } else if (diagramType === 'dependency_graph' && node.type === 'session' && node.detail) {
    const s = node.detail;
    h += `<p><strong>Sources:</strong> ${s.sources} · <strong>Targets:</strong> ${s.targets} · <strong>Lookups:</strong> ${s.lookups}</p>`;
    if (node.seq) h += `<p><strong>Execution Order:</strong> #${node.seq}</p>`;
    if (s.source_tables && s.source_tables.length) {
      h += `<p style="margin-top:6px"><strong>Source Tables:</strong></p><ul style="font-size:0.8rem;margin:4px 0 4px 16px">`;
      s.source_tables.slice(0, 10).forEach(t => { h += `<li>${t.name}</li>`; });
      if (s.source_tables.length > 10) h += `<li style="color:var(--text2)">+${s.source_tables.length - 10} more</li>`;
      h += '</ul>';
    }
    if (s.target_tables && s.target_tables.length) {
      h += `<p><strong>Target Tables:</strong></p><ul style="font-size:0.8rem;margin:4px 0 4px 16px">`;
      s.target_tables.forEach(t => { h += `<li>${t.name}${t.load_type ? ' <code style="font-size:0.7rem">' + t.load_type + '</code>' : ''}</li>`; });
      h += '</ul>';
    }
    if (node.hasConflict && node.conflictDetails.length) {
      h += '<div class="alert alert-warn" style="margin:8px 0;padding:8px 12px;font-size:0.8rem"><strong>Conflicts:</strong><br>';
      node.conflictDetails.forEach(c => { h += `${c.table_name} — ${c.conflict_type}<br>`; });
      h += '</div>';
    }
  } else if (diagramType === 'dependency_graph' && (node.type === 'table_output' || node.type === 'conflict_gate') && node.detail) {
    const d = node.detail;
    if (d.writers.length) h += `<p><strong>Writers:</strong> ${d.writers.join(', ')}</p>`;
    if (d.readers.length) h += `<p><strong>Readers:</strong> ${d.readers.join(', ')}</p>`;
    if (d.lookups.length) h += `<p><strong>Lookup Readers:</strong> ${d.lookups.join(', ')}</p>`;
    if (d.conflicts && d.conflicts.length) {
      h += '<div class="alert alert-warn" style="margin:8px 0;padding:8px 12px;font-size:0.8rem"><strong>Conflicts:</strong><br>';
      d.conflicts.forEach(c => { h += `${c.conflict_type}${c.writers ? ' — Writers: ' + c.writers.join(', ') : ''}<br>`; });
      h += '</div>';
    }
  } else if (node.detail && node.detail.columns) {
    const t = node.detail;
    h += `<p><strong>Schema:</strong> ${t.schema || 'dbo'} · <strong>Rows:</strong> ${t.row_count}</p>`;
    h += '<table style="font-size:0.75rem"><thead><tr><th>Column</th><th>Type</th><th>PK</th><th>Null</th></tr></thead><tbody>';
    t.columns.slice(0,15).forEach(c => {
      h += `<tr><td>${c.name}</td><td>${c.data_type}</td><td>${c.is_primary_key?'Y':''}</td><td>${c.nullable?'Y':'N'}</td></tr>`;
    });
    if (t.columns.length > 15) h += `<tr><td colspan="4" style="color:var(--text2)">+${t.columns.length-15} more columns</td></tr>`;
    h += '</tbody></table>';
    if (t.foreign_keys.length) {
      h += '<p style="margin-top:8px"><strong>Foreign Keys:</strong></p>';
      t.foreign_keys.forEach(fk => { h += `<p style="font-size:0.8rem"><code>${fk.column||fk.fk_column}</code> → <code>${fk.references_table}(${fk.references_column})</code></p>`; });
    }
  }
  h += '</div>';
  detailEl.innerHTML = h;
}

// ================================================================
// DATA GENERATOR (Box-Muller + seeded RNG)
// ================================================================
class SeededRNG {
  constructor(seed) { this.s = seed; }
  next() { this.s = (this.s * 16807 + 0) % 2147483647; return (this.s - 1) / 2147483646; }
  nextInt(min, max) { return Math.floor(this.next() * (max - min + 1)) + min; }
  normal(mean, std) {
    const u1 = this.next(), u2 = this.next();
    const z = Math.sqrt(-2*Math.log(u1||0.0001)) * Math.cos(2*Math.PI*u2);
    return mean + z * std;
  }
  choice(arr) { return arr[Math.floor(this.next()*arr.length)]; }
  shuffle(arr) { for (let i=arr.length-1;i>0;i--) { const j=Math.floor(this.next()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
  string(len) { const ch='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; return Array.from({length:len},()=>ch[Math.floor(this.next()*ch.length)]).join(''); }
}

function sampleColumn(rng, colSpec, rowCount) {
  const stats = colSpec.stats || {};
  const dt = (colSpec.data_type||'string').toLowerCase();
  const nr = stats.null_ratio || 0;
  const nn = Math.round(rowCount * (1-nr)), nc = rowCount - nn;
  let vals;
  if (['int','bigint','smallint','tinyint','integer','long'].includes(dt)) vals = sampleInt(rng, stats, nn);
  else if (['float','double','decimal','numeric'].includes(dt)) vals = sampleFloat(rng, stats, nn);
  else if (['string','varchar','char','text'].includes(dt)) vals = sampleStr(rng, stats, nn);
  else if (dt==='date') vals = sampleDate(rng, stats, nn);
  else if (['timestamp','datetime'].includes(dt)) vals = sampleTS(rng, stats, nn);
  else if (['boolean','bool'].includes(dt)) vals = sampleBool(rng, stats, nn);
  else vals = sampleStr(rng, stats, nn);
  const result = [...vals, ...Array(nc).fill(null)];
  return rng.shuffle(result);
}

function sampleInt(rng, s, n) {
  if (s.top_values && s.distinct_count <= 100) return sampleFreq(rng, s.top_values, n);
  const mn=s.min||0, mx=s.max||1000, mean=s.mean, std=s.stddev;
  if (mean!=null && std!=null && std>0) return Array.from({length:n},()=>Math.max(mn,Math.min(mx,Math.round(rng.normal(mean,std)))));
  return Array.from({length:n},()=>rng.nextInt(mn, mx));
}
function sampleFloat(rng, s, n) {
  const mean=s.mean||0, std=s.stddev||1, mn=s.min||-1e9, mx=s.max||1e9;
  return Array.from({length:n},()=>Math.round(Math.max(mn,Math.min(mx,rng.normal(mean,std)))*100)/100);
}
function sampleStr(rng, s, n) {
  if (s.top_values) return sampleFreq(rng, s.top_values, n);
  const mnl=s.min_length||5, mxl=s.max_length||20;
  return Array.from({length:n},()=>rng.string(rng.nextInt(mnl,mxl)));
}
function sampleDate(rng, s, n) {
  const mn=new Date(s.min||'2020-01-01').getTime(), mx=new Date(s.max||'2025-12-31').getTime();
  const range = mx-mn || 86400000*365;
  return Array.from({length:n},()=>new Date(mn+rng.next()*range).toISOString().split('T')[0]);
}
function sampleTS(rng, s, n) {
  return sampleDate(rng,s,n).map(d=>`${d}T${String(rng.nextInt(0,23)).padStart(2,'0')}:${String(rng.nextInt(0,59)).padStart(2,'0')}:${String(rng.nextInt(0,59)).padStart(2,'0')}`);
}
function sampleBool(rng, s, n) {
  let tr=0.5;
  (s.top_values||[]).forEach(t=>{if(String(t.value).toLowerCase()==='true')tr=t.frequency;});
  return Array.from({length:n},()=>rng.next()<tr);
}
function sampleFreq(rng, tv, n) {
  const vals=tv.map(t=>t.value), freqs=tv.map(t=>t.frequency||1/tv.length);
  const sum=freqs.reduce((a,b)=>a+b,0);
  const cum=freqs.reduce((a,f)=>{a.push((a.length?a[a.length-1]:0)+f/sum);return a;},[]);
  return Array.from({length:n},()=>{const r=rng.next();const i=cum.findIndex(c=>r<=c);return vals[Math.max(0,i)];});
}

function generateTables(bp, seed) {
  const rng = new SeededRNG(seed);
  const tMap = {}; bp.tables.forEach(t=>tMap[t.name]=t);
  // Topological sort
  const order = [], visited = new Set();
  function visit(tn) {
    if (visited.has(tn)) return; visited.add(tn);
    const ts = tMap[tn]; if (!ts) return;
    ts.foreign_keys.forEach(fk => visit(fk.references_table));
    order.push(tn);
  }
  Object.keys(tMap).forEach(visit);
  const pkPools = {}, results = {};
  for (const tn of order) {
    const ts = tMap[tn]; if (!ts) continue;
    const data = {}; const rc = ts.row_count;
    ts.columns.forEach(c => { data[c.name] = sampleColumn(rng, c, rc); });
    // Apply FK values
    ts.foreign_keys.forEach(fk => {
      const pool = (pkPools[fk.references_table]||{})[fk.references_column] || [];
      if (pool.length && data[fk.column]) { data[fk.column] = data[fk.column].map(()=>rng.choice(pool)); }
    });
    // Build PK pool
    pkPools[tn] = {};
    ts.columns.filter(c=>c.is_primary_key).forEach(c => {
      pkPools[tn][c.name] = data[c.name].filter(v=>v!=null);
    });
    results[tn] = data;
  }
  return results;
}

// ================================================================
// MEDALLION
// ================================================================
function runMedallion(tables, bp) {
  const tMap = {}; bp.tables.forEach(t=>tMap[t.name]=t);
  const bronze={}, silver={}, gold={}, rules=[], results_q=[];
  let totalDropped=0, totalNulls=0;
  for (const [tn, data] of Object.entries(tables)) {
    const ts = tMap[tn]; const cols = Object.keys(data); const rc = data[cols[0]]?data[cols[0]].length:0;
    // Bronze
    bronze[tn] = {data, rowCount:rc, columns:cols};
    // Silver: remove all-null rows, dedup PKs
    const keep = Array(rc).fill(true);
    for (let i=0;i<rc;i++) { if (cols.every(c=>data[c][i]==null)) { keep[i]=false; totalDropped++; } }
    const silverData = {}; cols.forEach(c => silverData[c] = data[c].filter((_,i)=>keep[i]));
    const src = silverData[cols[0]]?silverData[cols[0]].length:0;
    silver[tn] = {data:silverData, rowCount:src, columns:cols};
    // Gold: agg
    const agg = cols.map(c => {
      const vals = silverData[c].filter(v=>v!=null);
      const nums = vals.map(Number).filter(v=>!isNaN(v));
      const row = {column:c, non_null:vals.length, nulls:src-vals.length};
      if (nums.length > src*0.5) {
        row.min = Math.round(Math.min(...nums)*100)/100;
        row.max = Math.round(Math.max(...nums)*100)/100;
        row.mean = Math.round(nums.reduce((a,b)=>a+b,0)/nums.length*100)/100;
      } else {
        const freq = {}; vals.forEach(v=>{freq[v]=(freq[v]||0)+1;});
        row.distinct = Object.keys(freq).length;
        row.top = Object.entries(freq).sort((a,b)=>b[1]-a[1]).slice(0,3).map(([v,c])=>`${v}(${c})`).join(', ');
      }
      return row;
    });
    gold[tn] = agg;
    // Quality rules
    if (ts) ts.columns.forEach(cs => {
      const cn = cs.name;
      if (!cs.nullable) {
        rules.push({name:`${tn}_${cn}_not_null`, table:tn, expression:`${cn} IS NOT NULL`});
        const nc = silverData[cn]?silverData[cn].filter(v=>v==null).length:0;
        results_q.push({rule:`${tn}_${cn}_not_null`,table:tn,column:cn,passed:nc===0,violations:nc,total:src});
      }
      if (cs.is_primary_key) {
        rules.push({name:`${tn}_${cn}_unique`, table:tn, expression:`${cn} is unique`});
        const seen=new Set(); let dups=0; (silverData[cn]||[]).forEach(v=>{if(seen.has(v))dups++;seen.add(v);});
        results_q.push({rule:`${tn}_${cn}_unique`,table:tn,column:cn,passed:dups===0,violations:dups,total:src});
      }
    });
  }
  return {bronze,silver,gold,rules,results:results_q,stats:{rows_dropped:totalDropped,nulls_cleaned:totalNulls,tables_processed:Object.keys(tables).length}};
}

// ================================================================
// VALIDATION
// ================================================================
function runValidation_fn(bp, tables, qualResults) {
  const results = [];
  for (const ts of bp.tables) {
    const tn = ts.name, data = tables[tn];
    if (!data) { results.push({table:tn,schema_score:0,fidelity_score:0,quality_score:0,pipeline_score:0,overall_score:0,recs:['Table not generated']}); continue; }
    const cols = Object.keys(data); const rc = data[cols[0]]?data[cols[0]].length:0;
    // Schema
    const expected = ts.columns.map(c=>c.name);
    const missing = expected.filter(c=>!cols.includes(c));
    const matched = expected.filter(c=>cols.includes(c)).length;
    const ss = matched / Math.max(expected.length, 1);
    // Fidelity
    const rcMatch = Math.abs(rc - ts.row_count) / Math.max(ts.row_count, 1) <= 0.05;
    const fs = (rcMatch?1:0.5)*0.2 + 0.8*1.0;
    // Quality
    let qs = 1.0;
    if (qualResults) { const v = qualResults.filter(r=>r.table===tn&&!r.passed); if (v.length) qs = Math.max(0, 1-v.length*0.1); }
    const overall = ss*0.25 + fs*0.35 + qs*0.20 + 1.0*0.20;
    const recs = []; if (missing.length) recs.push('Missing columns: '+missing.join(', '));
    results.push({table:tn, schema_score:Math.round(ss*1000)/1000, fidelity_score:Math.round(fs*1000)/1000,
      quality_score:Math.round(qs*1000)/1000, pipeline_score:1.0, overall_score:Math.round(overall*1000)/1000, recs, missing});
  }
  return results;
}

// ================================================================
// UI HELPERS
// ================================================================
function html(tag, attrs, ...children) {
  const el = document.createElement(tag);
  if (attrs) Object.entries(attrs).forEach(([k,v]) => { if (k==='className') el.className=v; else if (k==='onclick') el.onclick=v; else el.setAttribute(k,v); });
  children.forEach(c => { if (typeof c === 'string') el.innerHTML += c; else if (c) el.appendChild(c); });
  return el;
}

function metricsHTML(items) {
  return '<div class="metrics">'+items.map(([l,v,d])=>`<div class="metric"><div class="label">${l}</div><div class="value">${v}</div>${d?`<div class="delta">${d}</div>`:''}</div>`).join('')+'</div>';
}

function tableHTML(headers, rows) {
  return `<div class="table-scroll"><table><thead><tr>${headers.map(h=>`<th>${h}</th>`).join('')}</tr></thead><tbody>${rows.map(r=>`<tr>${r.map(c=>`<td>${c??''}</td>`).join('')}</tr>`).join('')}</tbody></table></div>`;
}

function expanderHTML(title, content, open=false) {
  return `<div class="expander ${open?'open':''}"><div class="expander-header" onclick="this.parentElement.classList.toggle('open')"><span>${title}</span><span class="expander-arrow">▶</span></div><div class="expander-body">${content}</div></div>`;
}

function scoreBadge(score) {
  if (score >= 0.9) return `<span class="badge badge-green">🟢 GREEN ${Math.round(score*100)}%</span>`;
  if (score >= 0.7) return `<span class="badge badge-amber">🟡 AMBER ${Math.round(score*100)}%</span>`;
  return `<span class="badge badge-red">🔴 RED ${Math.round(score*100)}%</span>`;
}

function progressHTML(score, label) {
  const cls = score>=0.9?'green':score>=0.7?'amber':'red';
  return `<div style="margin:4px 0"><div style="display:flex;justify-content:space-between;font-size:0.85rem"><span>${label}</span><span>${Math.round(score*100)}%</span></div><div class="progress-bar"><div class="progress-fill ${cls}" style="width:${Math.round(score*100)}%"></div></div></div>`;
}

function dataPreviewHTML(data, maxRows=15) {
  const cols = Object.keys(data); if (!cols.length) return '';
  const rc = data[cols[0]]?data[cols[0]].length:0;
  const rows = []; for (let i=0;i<Math.min(rc,maxRows);i++) rows.push(cols.map(c=>{ const v=data[c][i]; return v==null?'<span style="color:var(--text2)">null</span>':String(v).substring(0,40); }));
  return tableHTML(cols, rows);
}

// ================================================================
// STEP HANDLERS
// ================================================================
function parseInput() {
  const content = uploadedContent || document.getElementById('pasteInput').value.trim();
  if (!content) { alert('Upload a file or paste text first.'); return; }
  setTabStatus('parse', 'processing');
  // Use smart parse cascade
  let parsed;
  try {
    parsed = smartParse(content, uploadedName || null);
  } catch(e) { setTabStatus('parse', 'ready'); alert('Parse error: '+e.message); return; }
  if (!parsed || !parsed.tables || !parsed.tables.length) {
    setTabStatus('parse', 'ready');
    const warnings = parsed && parsed.parse_warnings ? parsed.parse_warnings.join('\n') : '';
    alert('No tables found. Check your input format.' + (warnings ? '\n\n' + warnings : ''));
    return;
  }
  STATE.parsed = parsed; STATE.blueprint = STATE.tables = STATE.medallion = STATE.validation = STATE.notebook = STATE.migrationReport = null;
  // Lock steps 6+7 until validation completes
  setTabStatus('notebook', 'locked');
  setTabStatus('report', 'locked');
  document.getElementById('notebookNotReady').classList.remove('hidden');
  document.getElementById('notebookNotNifi').classList.add('hidden');
  document.getElementById('notebookReady').classList.add('hidden');
  document.getElementById('notebookResults').innerHTML = '';
  document.getElementById('reportNotReady').classList.remove('hidden');
  document.getElementById('reportReady').classList.add('hidden');
  document.getElementById('reportResults').innerHTML = '';
  // Detect source system
  const fmt = parsed.detected_format || parsed.input_format || 'unknown';
  const src = detectSourceSystem(content, fmt);
  const tc = parsed.tables.reduce((a,t)=>a+t.columns.length,0);
  const tf = parsed.tables.reduce((a,t)=>a+t.foreign_keys.length,0);
  let h = '<hr class="divider">';
  h += `<div class="detected-source"><span class="dot"></span><strong>${src.name}</strong>&nbsp;—&nbsp;${src.type}<span style="margin-left:12px;color:var(--text2);font-size:0.85rem">(${fmt.replace(/_/g,' ')})</span></div>`;
  // Show parse quality info
  if (parsed.parse_attempts && parsed.parse_attempts > 1) h += `<div class="alert alert-info">Smart parser tried ${parsed.parse_attempts} format(s) before finding a match (confidence: ${Math.round((parsed.parse_confidence||0)*100)}%)</div>`;
  h += metricsHTML([['Tables',parsed.tables.length],['Columns',tc],['Foreign Keys',tf],['Source',src.name]]);
  // NiFi-specific details
  if (parsed._nifi) {
    const nf = parsed._nifi;
    h += metricsHTML([['Processors',nf.processors.length],['Connections',nf.connections.length],['Process Groups',nf.processGroups.length],['Controller Services',nf.controllerServices.length]]);
    if (nf.processGroups.length) {
      const pgRows = nf.processGroups.map(pg => {
        const pc = nf.processors.filter(p=>p.group===pg.name).length;
        return [pg.name, pg.parentGroup, pc];
      });
      h += expanderHTML(`<strong>Process Groups</strong> (${nf.processGroups.length})`, tableHTML(['Group Name','Parent','Processors'], pgRows));
    }
    if (nf.processors.length) {
      // Group by type for summary
      const byType = {}; nf.processors.forEach(p=>{ byType[p.type]=(byType[p.type]||0)+1; });
      const typeRows = Object.entries(byType).sort((a,b)=>b[1]-a[1]).map(([t,c])=>[t,c]);
      let procBody = '<h3 style="margin-top:0">By Type</h3>' + tableHTML(['Processor Type','Count'], typeRows);
      // Show first 30 processors
      const pRows = nf.processors.slice(0,30).map(p => [p.name, p.type, p.group, p.state||'', Object.keys(p.properties).length]);
      procBody += `<h3>Processors (first 30 of ${nf.processors.length})</h3>` + tableHTML(['Name','Type','Group','State','Props'], pRows);
      h += expanderHTML(`<strong>Processors</strong> (${nf.processors.length})`, procBody);
    }
    if (nf.connections.length) {
      const cRows = nf.connections.slice(0,30).map(c => [c.sourceName, c.destinationName, c.relationships.join(', ')]);
      h += expanderHTML(`<strong>Connections</strong> (${nf.connections.length})`, tableHTML(['Source','Destination','Relationships'], cRows) + (nf.connections.length>30?`<p style="color:var(--text2)">...and ${nf.connections.length-30} more</p>`:''));
    }
    if (nf.controllerServices.length) {
      const csRows = nf.controllerServices.map(s => [s.name, s.type, s.state||'', Object.keys(s.properties).length+' props']);
      h += expanderHTML(`<strong>Controller Services</strong> (${nf.controllerServices.length})`, tableHTML(['Service','Type','State','Properties'], csRows));
    }
    if (nf.sqlTables && nf.sqlTables.length) {
      const stRows = nf.sqlTables.map(t => [t, t.startsWith('$')?'variable':'table']);
      h += expanderHTML(`<strong>SQL Table References</strong> (${nf.sqlTables.length})`, tableHTML(['Table Reference','Type'], stRows));
    }
  }
  // Dependency graph-specific details
  if (parsed._dependency) {
    const dep = parsed._dependency;
    const allTableCount = Object.keys(dep.allTables || {}).length;
    h += metricsHTML([['Sessions',dep.sessions.length],['Dependencies',dep.edges.length],['Unique Tables',allTableCount],['Conflicts',dep.conflicts.length]]);
    // Sessions summary
    if (dep.sessions.length) {
      const sRows = dep.sessions.map(s => [s.name, s.sources, s.targets, s.lookups]);
      h += expanderHTML(`<strong>ETL Sessions</strong> (${dep.sessions.length})`, tableHTML(['Session','Sources','Targets','Lookups'], sRows));
    }
    // Dependency edges
    if (dep.edges.length) {
      const eRows = dep.edges.map(e => {
        const up = e.upstream || e.upstream_session || e.from || '';
        const down = e.downstream || e.downstream_session || e.to || '';
        const via = e.shared_tables ? e.shared_tables.join(', ') : (e.via_table || '');
        return [up, down, via];
      });
      h += expanderHTML(`<strong>Dependency Edges</strong> (${dep.edges.length})`, tableHTML(['Upstream','Downstream','Shared Tables'], eRows));
    }
    // Recommended execution order
    if (dep.order.length) {
      const oRows = dep.order.map((s, i) => [i + 1, s]);
      h += expanderHTML(`<strong>Recommended Order</strong> (${dep.order.length})`, tableHTML(['Step','Session'], oRows));
    }
    // Conflicts
    if (dep.conflicts.length) {
      const cRows = dep.conflicts.map(c => [c.table_name, c.conflict_type, (c.writers||[]).join(', '), (c.readers||c.lookup_readers||[]).join(', ')]);
      h += expanderHTML(`<strong>Conflicts</strong> (${dep.conflicts.length})`, '<div class="alert alert-warn" style="margin:0 0 8px">These tables have multiple writers or timing issues</div>' + tableHTML(['Table','Conflict Type','Writers','Readers'], cRows));
    }
  }
  if (parsed.parse_warnings && parsed.parse_warnings.length) {
    h += '<div class="alert alert-warn">'+parsed.parse_warnings.join('<br>')+'</div>';
  }
  parsed.tables.forEach(t => {
    const rows = t.columns.map(c=>[c.name, c.data_type, c.raw_type||c.data_type, c.nullable?'Yes':'No', c.is_primary_key?'Y':'', (c.check_constraints||[]).join(', ')]);
    let body = tableHTML(['Column','Type','Raw Type','Nullable','PK','Check'], rows);
    if (t.foreign_keys.length) { body += '<p style="margin-top:8px"><strong>Foreign Keys:</strong></p>'+t.foreign_keys.map(fk=>`<p style="font-size:0.9rem">  <code>${fk.fk_column}</code> → <code>${fk.referenced_table}(${fk.referenced_column})</code></p>`).join(''); }
    h += expanderHTML(`Table: <strong>${t.name}</strong> (${t.columns.length} columns)`, body, true);
  });
  h += `<div class="alert alert-success">Parsed <strong>${parsed.tables.length} tables</strong> with <strong>${tc} columns</strong> from <strong>${src.name}</strong> — proceed to Step 2</div>`;
  document.getElementById('parseResults').innerHTML = h;
  document.getElementById('blueprintNotReady').classList.add('hidden');
  document.getElementById('blueprintReady').classList.remove('hidden');
  setTabStatus('parse', 'done');
  unlockTab('blueprint');
}

function assembleBlueprint() {
  if (!STATE.parsed) return;
  setTabStatus('blueprint', 'processing');
  STATE.blueprint = assembleBlueprint_fn(STATE.parsed);
  STATE.tables = STATE.medallion = STATE.validation = null;
  const bp = STATE.blueprint;
  let h = '<hr class="divider">';
  h += metricsHTML([['Blueprint ID',bp.blueprint_id.substring(0,8)+'...'],['Tables',bp.tables.length],['Relationships',bp.relationships.length],['Source',bp.source_system.type]]);
  // Environment Summary
  h += buildEnvironmentSummary(STATE.parsed, bp);
  if (bp.relationships.length) {
    h += '<h3>Relationships</h3>';
    bp.relationships.forEach(r => { const ft=r.from_table.split('.').pop(), tt=r.to_table.split('.').pop(), j=r.join_columns[0]; h += `<p><code>${ft}</code>.${j.from_column} → <code>${tt}</code>.${j.to_column}</p>`; });
  }
  h += '<h3>Table Specifications</h3>';
  bp.tables.forEach(t => {
    const rows = t.columns.map(c=>[c.name, c.data_type, c.is_primary_key?'Y':'', Math.round((c.stats.null_ratio||0)*100)+'%', c.stats.min??'', c.stats.max??'', c.stats.distinct_count??'']);
    h += expanderHTML(`<strong>${t.name}</strong> — ${t.row_count} rows`, tableHTML(['Column','Type','PK','Null%','Min','Max','Distinct'], rows));
  });
  h += `<div style="margin-top:16px;display:flex;gap:8px;flex-wrap:wrap"><button class="btn btn-secondary" onclick="downloadJSON()">Download Blueprint JSON</button><button class="btn btn-secondary" onclick="downloadEnvironment()">Export Environment Model</button></div>`;
  h += `<div class="alert alert-success">Blueprint assembled — proceed to Step 3</div>`;
  document.getElementById('blueprintResults').innerHTML = h;
  document.getElementById('generateNotReady').classList.add('hidden');
  document.getElementById('generateReady').classList.remove('hidden');
  // Render adaptive tier diagram
  try {
    const tierData = buildTierData(bp, STATE.parsed);
    if (tierData && tierData.nodes.length) {
      renderTierDiagram(tierData, 'tierDiagram', 'tierNodeDetail', 'tierDiagramLegend');
    }
  } catch(e) { console.warn('Tier diagram error:', e); }
  setTabStatus('blueprint', 'done');
  unlockTab('generate');
}

function downloadJSON() {
  if (!STATE.blueprint) return;
  const blob = new Blob([JSON.stringify(STATE.blueprint,null,2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = `blueprint_${STATE.blueprint.blueprint_id.substring(0,8)}.json`; a.click();
}

function downloadEnvironment() {
  if (!STATE.parsed || !STATE.blueprint) return;
  const env = {
    source: {name: STATE.parsed.source_name, type: STATE.parsed.source_type, format: STATE.parsed.input_format},
    blueprint_id: STATE.blueprint.blueprint_id,
    tables: STATE.blueprint.tables.map(t => ({name:t.name, schema:t.schema, columns:t.columns.length, row_count:t.row_count, has_pk:t.columns.some(c=>c.is_primary_key), fk_count:t.foreign_keys.length})),
    relationships: STATE.blueprint.relationships,
    tier_structure: (function() {
      try { const td = buildTierData(STATE.blueprint, STATE.parsed); return {type:td.diagramType, tiers:Object.keys(td.tierLabels).length, nodes:td.nodes.length, connections:td.connections.length}; } catch(e) { return null; }
    })()
  };
  if (STATE.parsed._nifi) {
    const nf = STATE.parsed._nifi;
    env.nifi_environment = {
      processors: nf.processors.map(p => ({name:p.name, type:p.type, group:p.group, role:classifyNiFiProcessor(p.type), state:p.state})),
      connections: nf.connections.map(c => ({source:c.sourceName, dest:c.destinationName, relationships:c.relationships})),
      process_groups: nf.processGroups,
      controller_services: nf.controllerServices.map(s => ({name:s.name, type:s.type, state:s.state})),
      sql_table_refs: nf.sqlTables
    };
  }
  const blob = new Blob([JSON.stringify(env,null,2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = `environment_${STATE.blueprint.blueprint_id.substring(0,8)}.json`; a.click();
}

function generateData() {
  if (!STATE.blueprint) return;
  setTabStatus('generate', 'processing');
  const seed = parseInt(document.getElementById('seed').value)||42;
  const rowOverride = parseInt(document.getElementById('rowCount').value)||0;
  // Apply row override if specified
  if (rowOverride > 0) {
    STATE.blueprint.tables.forEach(t => { t.row_count = rowOverride; });
  }
  STATE.tables = generateTables(STATE.blueprint, seed);
  STATE.medallion = STATE.validation = null;
  const tables = STATE.tables;
  const totalRows = Object.values(tables).reduce((a,d)=>a+(d[Object.keys(d)[0]]||[]).length,0);
  const totalCols = Object.values(tables).reduce((a,d)=>a+Object.keys(d).length,0);
  let h = '<hr class="divider">';
  h += metricsHTML([['Tables Generated',Object.keys(tables).length],['Total Rows',totalRows.toLocaleString()],['Total Columns',totalCols]]);
  for (const [name, data] of Object.entries(tables)) {
    const cols = Object.keys(data); const rc = data[cols[0]]?data[cols[0]].length:0;
    let body = '<strong>Preview</strong> (first 15 rows)' + dataPreviewHTML(data);
    // Stats
    body += '<h3 style="margin-top:16px">Column Statistics</h3>';
    const statRows = cols.map(c => {
      const vals = data[c].filter(v=>v!=null); const nums = vals.map(Number).filter(v=>!isNaN(v));
      if (nums.length > vals.length*0.5) {
        const mn = Math.min(...nums), mx = Math.max(...nums), mean = nums.reduce((a,b)=>a+b,0)/nums.length;
        return [c, vals.length, data[c].length-vals.length, Math.round(mn*100)/100, Math.round(mx*100)/100, Math.round(mean*100)/100];
      }
      const uniq = new Set(vals).size;
      return [c, vals.length, data[c].length-vals.length, '—','—', `${uniq} unique`];
    });
    body += tableHTML(['Column','Non-Null','Null','Min','Max','Mean/Distinct'], statRows);
    h += expanderHTML(`<strong>${name}</strong> — ${rc.toLocaleString()} rows, ${cols.length} columns`, body, true);
  }
  h += `<div style="margin-top:16px"><button class="btn btn-secondary" onclick="downloadCSV()">Download All (CSV ZIP)</button></div>`;
  h += `<div class="alert alert-success">Generated <strong>${totalRows.toLocaleString()} rows</strong> across <strong>${Object.keys(tables).length} tables</strong> — proceed to Step 4</div>`;
  document.getElementById('generateResults').innerHTML = h;
  document.getElementById('conformNotReady').classList.add('hidden');
  document.getElementById('conformReady').classList.remove('hidden');
  // Update tier diagram with row count badges
  try { updateTierDiagramBadges(tables); } catch(e) { console.warn('Badge update error:', e); }
  setTabStatus('generate', 'done');
  unlockTab('conform');
}

function downloadCSV() {
  if (!STATE.tables) return;
  // Simple CSV generation (no zip library needed — download individual files)
  for (const [name, data] of Object.entries(STATE.tables)) {
    const cols = Object.keys(data); const rc = data[cols[0]]?data[cols[0]].length:0;
    let csv = cols.join(',')+'\n';
    for (let i=0;i<rc;i++) csv += cols.map(c=>data[c][i]??'').join(',')+'\n';
    const blob = new Blob([csv], {type:'text/csv'});
    const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`${name}.csv`; a.click();
  }
}

function runConform() {
  if (!STATE.tables || !STATE.blueprint) return;
  setTabStatus('conform', 'processing');
  STATE.medallion = runMedallion(STATE.tables, STATE.blueprint);
  STATE.validation = null;
  const med = STATE.medallion;
  let h = '<hr class="divider">';
  h += metricsHTML([['Tables Processed',med.stats.tables_processed],['Rows Dropped',med.stats.rows_dropped],['Nulls Cleaned',med.stats.nulls_cleaned]]);
  h += '<h3>Medallion Layers</h3>';
  for (const tn of Object.keys(med.bronze)) {
    h += `<h3 style="margin-top:20px">Table: <code>${tn}</code></h3><div class="row">`;
    // Bronze
    h += `<div class="col-3"><h3>Bronze (Raw)</h3>`;
    h += metricsHTML([['Rows',med.bronze[tn].rowCount]]);
    h += dataPreviewHTML(med.bronze[tn].data, 8) + '</div>';
    // Silver
    const dropped = med.bronze[tn].rowCount - med.silver[tn].rowCount;
    h += `<div class="col-3"><h3>Silver (Cleaned)</h3>`;
    h += metricsHTML([['Rows', med.silver[tn].rowCount, dropped?`-${dropped}`:'']]);
    h += dataPreviewHTML(med.silver[tn].data, 8) + '</div>';
    // Gold
    h += `<div class="col-3"><h3>Gold (Aggregated)</h3>`;
    h += metricsHTML([['Columns Profiled', med.gold[tn].length]]);
    const goldRows = med.gold[tn].map(r=>[r.column, r.non_null, r.nulls, r.min??'—', r.max??'—', r.mean??r.top??'—', r.distinct??'—']);
    h += tableHTML(['Column','Non-Null','Nulls','Min','Max','Mean/Top','Distinct'], goldRows) + '</div></div>';
  }
  h += '<hr class="divider"><h3>Quality Rules</h3>';
  if (med.rules.length) {
    h += '<p><strong>DLT Expectations:</strong></p><pre>';
    med.rules.forEach(r => h += `  CONSTRAINT ${r.name} EXPECT (${r.expression})\n`);
    h += '</pre>';
    h += '<p><strong>Quality Check Results:</strong></p>';
    const qRows = med.results.map(r=>[r.passed?'<span class="badge badge-green">PASS</span>':'<span class="badge badge-red">FAIL</span>', r.rule, r.table, r.violations, r.total]);
    h += tableHTML(['Status','Rule','Table','Violations','Total'], qRows);
    const pc = med.results.filter(r=>r.passed).length;
    h += metricsHTML([['Pass Rate',`${pc}/${med.results.length} (${Math.round(pc/Math.max(med.results.length,1)*100)}%)`]]);
  } else h += '<div class="alert alert-info">No quality rules for this schema.</div>';
  h += '<div class="alert alert-success">Medallion pipeline complete — proceed to Step 5</div>';
  document.getElementById('conformResults').innerHTML = h;
  document.getElementById('validateNotReady').classList.add('hidden');
  document.getElementById('validateReady').classList.remove('hidden');
  // Add medallion tiers to diagram
  try { addMedallionTiers(); } catch(e) { console.warn('Medallion tier error:', e); }
  setTabStatus('conform', 'done');
  unlockTab('validate');
}

function runValidation() {
  if (!STATE.tables || !STATE.blueprint) return;
  setTabStatus('validate', 'processing');
  const qr = STATE.medallion ? STATE.medallion.results : null;
  STATE.validation = runValidation_fn(STATE.blueprint, STATE.tables, qr);
  const val = STATE.validation;
  const avg = val.reduce((a,v)=>a+v.overall_score,0)/val.length;
  const gc = val.filter(v=>v.overall_score>=0.9).length;
  const ac = val.filter(v=>v.overall_score>=0.7&&v.overall_score<0.9).length;
  const rc = val.filter(v=>v.overall_score<0.7).length;
  const icon = avg>=0.9?'🟢':avg>=0.7?'🟡':'🔴';
  const lvl = avg>=0.9?'GREEN':avg>=0.7?'AMBER':'RED';
  let h = '<hr class="divider">';
  h += `<div class="score-big">${icon} ${lvl} — ${Math.round(avg*100)}%</div>`;
  h += `<p style="text-align:center;font-size:1.1rem"><strong>${val.length} tables:</strong> ${gc} green, ${ac} amber, ${rc} red</p>`;
  // Dimension averages
  const avgS = val.reduce((a,v)=>a+v.schema_score,0)/val.length;
  const avgF = val.reduce((a,v)=>a+v.fidelity_score,0)/val.length;
  const avgQ = val.reduce((a,v)=>a+v.quality_score,0)/val.length;
  const avgP = val.reduce((a,v)=>a+v.pipeline_score,0)/val.length;
  h += metricsHTML([['Schema (25%)',Math.round(avgS*100)+'%'],['Fidelity (35%)',Math.round(avgF*100)+'%'],['Quality (20%)',Math.round(avgQ*100)+'%'],['Pipeline (20%)',Math.round(avgP*100)+'%']]);
  h += '<hr class="divider"><h3>Per-Table Results</h3>';
  val.forEach(v => {
    const ic = v.overall_score>=0.9?'🟢':v.overall_score>=0.7?'🟡':'🔴';
    let body = metricsHTML([['Schema',Math.round(v.schema_score*100)+'%'],['Fidelity',Math.round(v.fidelity_score*100)+'%'],['Quality',Math.round(v.quality_score*100)+'%'],['Pipeline',Math.round(v.pipeline_score*100)+'%']]);
    body += progressHTML(v.schema_score, 'Schema Parity');
    body += progressHTML(v.fidelity_score, 'Data Fidelity');
    body += progressHTML(v.quality_score, 'Quality Compliance');
    body += progressHTML(v.pipeline_score, 'Pipeline Integrity');
    if (v.recs&&v.recs.length) body += '<p style="margin-top:12px"><strong>Recommendations:</strong></p><ul>'+v.recs.map(r=>`<li>${r}</li>`).join('')+'</ul>';
    h += expanderHTML(`${ic} <strong>${v.table}</strong> — ${Math.round(v.overall_score*100)}%`, body, v.overall_score<0.9);
  });
  h += '<hr class="divider"><h3>Scoring Methodology</h3>';
  h += tableHTML(['Dimension','Weight','Description'],[['Schema Parity','25%','Columns and types match blueprint'],['Data Fidelity','35%','Distributions, null ratios match'],['Quality Compliance','20%','DLT expectations pass rate'],['Pipeline Integrity','20%','Medallion pipeline success']]);
  h += tableHTML(['Level','Threshold','Meaning'],[['🟢 Green','≥ 90%','Ready for production cutover'],['🟡 Amber','≥ 70%','Needs attention'],['🔴 Red','< 70%','Not ready']]);
  h += '<div class="alert alert-success">Validation complete! Your synthetic environment is ready.</div>';
  document.getElementById('validateResults').innerHTML = h;
  // Add validation scoring to diagram
  try { addValidationTier(val, avg); } catch(e) { console.warn('Validation tier error:', e); }
  setTabStatus('validate', 'done');
  // Unlock Step 6 for NiFi flows
  if (STATE.parsed && STATE.parsed._nifi) {
    document.getElementById('notebookNotReady').classList.add('hidden');
    document.getElementById('notebookNotNifi').classList.add('hidden');
    document.getElementById('notebookReady').classList.remove('hidden');
    unlockTab('notebook');
  } else {
    document.getElementById('notebookNotReady').classList.add('hidden');
    document.getElementById('notebookNotNifi').classList.remove('hidden');
    document.getElementById('notebookReady').classList.add('hidden');
  }
}

// ================================================================
// STEP 6 — GENERATE NOTEBOOK
// ================================================================
function generateNotebook() {
  if (!STATE.parsed || !STATE.parsed._nifi) return;
  setTabStatus('notebook', 'processing');
  const nifi = STATE.parsed._nifi;
  const mappings = mapNiFiToDatabricks(nifi);
  const nbResult = generateDatabricksNotebook(mappings, nifi, STATE.blueprint);
  const cells = nbResult.cells;
  const workflow = generateWorkflowJSON(mappings, nifi);
  STATE.notebook = { mappings, cells, workflow };

  let h = '<hr class="divider">';

  // --- Mapping Summary Table ---
  h += '<h3>Processor Mapping</h3>';
  const mapRows = mappings.map(m => [
    m.name,
    `<span style="color:${ROLE_TIER_COLORS[m.role]||'#808495'}">${m.role}</span>`,
    m.group || '—',
    m.mapped ? m.desc : '<em style="color:var(--text2)">No equivalent</em>',
    m.mapped ? `<span class="conf-badge ${m.confidence>=0.8?'conf-high':m.confidence>=0.5?'conf-med':'conf-low'}">${Math.round(m.confidence*100)}%</span>`
             : '<span class="conf-badge conf-none">—</span>'
  ]);
  h += `<div class="table-scroll"><table class="mapping-table"><thead><tr><th>NiFi Processor</th><th>Role</th><th>Group</th><th>Databricks Equivalent</th><th>Confidence</th></tr></thead><tbody>${mapRows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join('')}</tr>`).join('')}</tbody></table></div>`;

  // --- Notebook Preview ---
  h += '<hr class="divider"><h3>Generated Notebook</h3>';
  h += '<div class="notebook-preview">';
  cells.forEach((cell, i) => {
    const lbl = cell.label || (cell.type === 'md' ? 'markdown' : 'code');
    const lblClass = cell.role ? 'lb-' + cell.role : 'lb-config';
    const code = cell.source.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    h += `<div class="notebook-cell"><div class="cell-label ${lblClass}">[${i+1}] ${lbl}</div><pre>${code}</pre></div>`;
  });
  h += '</div>';

  // --- Unity Catalog DDL ---
  const ddlCells = cells.filter(c => c.label && c.label.includes('Unity Catalog'));
  if (ddlCells.length) {
    h += '<hr class="divider"><h3>Unity Catalog DDL</h3>';
    ddlCells.forEach(c => {
      const code = c.source.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      h += `<div class="notebook-preview"><div class="notebook-cell"><div class="cell-label lb-config">SQL</div><pre>${code}</pre></div></div>`;
    });
  }

  // --- Workflow JSON ---
  h += '<hr class="divider"><h3>Databricks Workflow (Jobs API)</h3>';
  const wfJson = JSON.stringify(workflow, null, 2).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  h += `<div class="notebook-preview"><div class="notebook-cell"><div class="cell-label lb-config">JSON</div><pre>${wfJson}</pre></div></div>`;

  // --- Download buttons ---
  h += '<hr class="divider"><div style="display:flex;gap:8px;flex-wrap:wrap">';
  h += `<button class="btn" onclick="downloadNotebook()">Download .py Notebook</button>`;
  h += `<button class="btn" onclick="downloadWorkflow()">Download Workflow JSON</button>`;
  h += '</div>';

  document.getElementById('notebookResults').innerHTML = h;
  setTabStatus('notebook', 'done');

  // Unlock Step 7
  document.getElementById('reportNotReady').classList.add('hidden');
  document.getElementById('reportReady').classList.remove('hidden');
  unlockTab('report');
}

function downloadNotebook() {
  if (!STATE.notebook) return;
  const nb = STATE.notebook.cells.map(c => c.source).join('\n\n# COMMAND ----------\n\n');
  const blob = new Blob([nb], {type:'text/plain'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'nifi_migration_notebook.py';
  a.click(); URL.revokeObjectURL(a.href);
}

function downloadWorkflow() {
  if (!STATE.notebook) return;
  const blob = new Blob([JSON.stringify(STATE.notebook.workflow, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'databricks_workflow.json';
  a.click(); URL.revokeObjectURL(a.href);
}

// ================================================================
// STEP 7 — MIGRATION REPORT
// ================================================================
function generateReport() {
  if (!STATE.notebook || !STATE.parsed || !STATE.parsed._nifi) return;
  setTabStatus('report', 'processing');
  const nifi = STATE.parsed._nifi;
  const report = generateMigrationReport(STATE.notebook.mappings, nifi);
  STATE.migrationReport = report;
  const s = report.summary;

  let h = '<hr class="divider">';

  // --- Coverage Score ---
  const pct = s.coveragePercent;
  const cls = pct >= 85 ? 'green' : pct >= 60 ? 'amber' : 'red';
  const icon = pct >= 85 ? '🟢' : pct >= 60 ? '🟡' : '🔴';
  const lvl = pct >= 85 ? 'HIGH COVERAGE' : pct >= 60 ? 'PARTIAL COVERAGE' : 'LOW COVERAGE';
  h += `<div class="score-big">${icon} ${lvl} — ${pct}%</div>`;
  h += metricsHTML([
    ['Total Processors', s.totalProcessors],
    ['Mapped', s.mappedProcessors],
    ['Unmapped', s.unmappedProcessors],
    ['Process Groups', s.totalProcessGroups],
    ['Connections', s.totalConnections],
    ['Effort', `<span class="badge badge-${report.effort==='Low'?'green':report.effort==='Medium'?'amber':'red'}">${report.effort}</span>`]
  ]);

  // --- By Role Breakdown ---
  h += '<hr class="divider"><h3>Coverage by Role</h3>';
  const roleOrder = ['source','route','transform','process','sink','utility'];
  roleOrder.forEach(role => {
    const rd = report.byRole[role];
    if (!rd) return;
    const rpct = rd.total ? Math.round(rd.mapped / rd.total * 100) : 0;
    const rcls = rpct >= 85 ? 'green' : rpct >= 60 ? 'amber' : 'red';
    const color = ROLE_TIER_COLORS[role] || '#808495';
    h += `<div style="margin:8px 0">`;
    h += `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:2px">`;
    h += `<span style="font-weight:600;color:${color};text-transform:uppercase;font-size:0.85rem">${role}</span>`;
    h += `<span style="font-size:0.85rem;color:var(--text2)">${rd.mapped}/${rd.total} (${rpct}%)</span>`;
    h += `</div>`;
    h += `<div class="progress-bar"><div class="progress-fill ${rcls}" style="width:${rpct}%"></div></div>`;
    if (rd.procs && rd.procs.length) {
      h += `<div style="font-size:0.8rem;color:var(--text2);margin-top:2px">${rd.procs.map(p=>p.name).join(', ')}</div>`;
    }
    h += `</div>`;
  });

  // --- By Group Breakdown ---
  h += '<hr class="divider"><h3>Coverage by Process Group</h3>';
  Object.entries(report.byGroup).sort((a,b)=>a[0].localeCompare(b[0])).forEach(([gname, gd]) => {
    const gpct = gd.total ? Math.round(gd.mapped / gd.total * 100) : 0;
    const gcls = gpct >= 85 ? 'green' : gpct >= 60 ? 'amber' : 'red';
    let body = `<div class="progress-bar" style="margin-bottom:8px"><div class="progress-fill ${gcls}" style="width:${gpct}%"></div></div>`;
    body += `<div style="font-size:0.85rem;color:var(--text2)">Mapped: ${gd.mapped} / ${gd.total}</div>`;
    if (gd.procs && gd.procs.length) {
      body += '<div style="margin-top:6px">';
      gd.procs.forEach(p => {
        const picon = p.mapped ? '✅' : '❌';
        body += `<div style="font-size:0.85rem;padding:2px 0">${picon} <strong>${p.name}</strong> (${p.type}) → ${p.mapped ? p.desc : '<em>unmapped</em>'}</div>`;
      });
      body += '</div>';
    }
    h += expanderHTML(`<span style="color:${gcls==='green'?'var(--green)':gcls==='amber'?'var(--amber)':'var(--red)'}">${gpct}%</span> ${gname} (${gd.mapped}/${gd.total})`, body, gpct < 85);
  });

  // --- Gap Analysis ---
  if (report.gaps.length) {
    h += '<hr class="divider"><h3>Gap Analysis — Unmapped Processors</h3>';
    report.gaps.forEach(g => {
      h += `<div class="gap-card">`;
      h += `<div class="gap-title">${g.name} <span class="gap-meta">${g.type} &middot; ${g.group || 'ungrouped'}</span></div>`;
      h += `<div class="gap-rec">${g.recommendation || 'Manual implementation required'}</div>`;
      h += `</div>`;
    });
  }

  // --- Recommendations ---
  if (report.recommendations.length) {
    h += '<hr class="divider"><h3>Recommendations</h3>';
    h += '<ul style="margin:0;padding-left:20px">';
    report.recommendations.forEach(r => { h += `<li style="margin:4px 0">${r}</li>`; });
    h += '</ul>';
  }

  // --- Download ---
  h += '<hr class="divider"><div style="display:flex;gap:8px;flex-wrap:wrap">';
  h += `<button class="btn" onclick="downloadReport()">Download Report (Markdown)</button>`;
  h += '</div>';

  document.getElementById('reportResults').innerHTML = h;
  setTabStatus('report', 'done');
}

function downloadReport() {
  if (!STATE.migrationReport) return;
  const r = STATE.migrationReport;
  const s = r.summary;
  let md = `# NiFi → Databricks Migration Report\n\n`;
  md += `## Summary\n| Metric | Value |\n|--------|-------|\n`;
  md += `| Total Processors | ${s.totalProcessors} |\n| Mapped | ${s.mappedProcessors} |\n| Unmapped | ${s.unmappedProcessors} |\n`;
  md += `| Coverage | ${s.coveragePercent}% |\n| Process Groups | ${s.totalProcessGroups} |\n| Effort | ${r.effort} |\n\n`;
  md += `## By Role\n| Role | Mapped | Total | % |\n|------|--------|-------|---|\n`;
  Object.entries(r.byRole).forEach(([role, rd]) => {
    md += `| ${role} | ${rd.mapped} | ${rd.total} | ${rd.total?Math.round(rd.mapped/rd.total*100):0}% |\n`;
  });
  md += `\n## By Group\n| Group | Mapped | Total | % |\n|-------|--------|-------|---|\n`;
  Object.entries(r.byGroup).forEach(([g, gd]) => {
    md += `| ${g} | ${gd.mapped} | ${gd.total} | ${gd.total?Math.round(gd.mapped/gd.total*100):0}% |\n`;
  });
  if (r.gaps.length) {
    md += `\n## Gaps\n| Processor | Type | Group | Recommendation |\n|-----------|------|-------|----------------|\n`;
    r.gaps.forEach(g => { md += `| ${g.processor} | ${g.type} | ${g.group||'—'} | ${g.recommendation||'Manual'} |\n`; });
  }
  if (r.recommendations.length) {
    md += `\n## Recommendations\n`;
    r.recommendations.forEach(rec => { md += `- ${rec}\n`; });
  }
  const blob = new Blob([md], {type:'text/markdown'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'migration_report.md';
  a.click(); URL.revokeObjectURL(a.href);
}

// ================================================================
// TIER DIAGRAM — Progressive Updates
// ================================================================
function updateTierDiagramBadges(tables) {
  const container = document.getElementById('tierDiagram');
  if (!container) return;
  container.querySelectorAll('.tier-node').forEach(el => {
    const nodeId = el.dataset.nodeId;
    if (!nodeId) return;
    // Find matching table data
    const name = nodeId.split('_')[0] || nodeId;
    for (const [tn, data] of Object.entries(tables)) {
      if (nodeId === tn || nodeId.startsWith(tn)) {
        const cols = Object.keys(data);
        const rc = data[cols[0]] ? data[cols[0]].length : 0;
        let badge = el.querySelector('.node-badge');
        if (!badge) { badge = document.createElement('div'); badge.className = 'node-badge'; el.appendChild(badge); }
        badge.textContent = rc >= 1000 ? Math.round(rc/1000) + 'K' : rc;
        badge.classList.add('green');
        break;
      }
    }
  });
}

function addMedallionTiers() {
  const container = document.getElementById('tierDiagram');
  if (!container) return;
  // Add medallion tier bands
  const medallionTiers = [
    {label:'BRONZE — Raw Ingestion', color:'#CD7F32', bg:'rgba(205,127,50,0.08)'},
    {label:'SILVER — Cleansed & Deduped', color:'#C0C0C0', bg:'rgba(192,192,192,0.08)'},
    {label:'GOLD — Aggregated & Profiled', color:'#FFD700', bg:'rgba(255,215,0,0.08)'},
  ];
  medallionTiers.forEach((tier, i) => {
    const band = document.createElement('div');
    band.className = 'tier-band';
    band.style.background = tier.bg;
    band.style.borderLeft = `3px solid ${tier.color}`;
    const label = document.createElement('div');
    label.className = 'tier-band-label';
    label.style.color = tier.color;
    label.textContent = tier.label;
    band.appendChild(label);
    const nodesDiv = document.createElement('div');
    nodesDiv.className = 'tier-nodes';
    // Add a flow arrow node
    const arrow = document.createElement('div');
    arrow.className = 'tier-node';
    arrow.style.borderTopWidth = '3px';
    arrow.style.borderTopColor = tier.color;
    arrow.style.minWidth = '80px';
    arrow.innerHTML = `<div class="node-name" style="font-size:1.2rem">${i===0?'&#x2B07;':i===1?'&#x2B07;':'&#x2705;'}</div><div class="node-meta">${['Raw data loaded','Cleaned & validated','Ready for analytics'][i]}</div>`;
    nodesDiv.appendChild(arrow);
    band.appendChild(nodesDiv);
    container.appendChild(band);
  });
  // Add connections between medallion tiers
  requestAnimationFrame(() => renderConnections(container, [], {}));
}

function addValidationTier(val, avg) {
  const container = document.getElementById('tierDiagram');
  if (!container) return;
  const color = avg >= 0.9 ? '#21C354' : avg >= 0.7 ? '#FACA15' : '#FF4B4B';
  const level = avg >= 0.9 ? 'GREEN' : avg >= 0.7 ? 'AMBER' : 'RED';
  const band = document.createElement('div');
  band.className = 'tier-band';
  band.style.background = avg >= 0.9 ? 'rgba(33,195,84,0.08)' : avg >= 0.7 ? 'rgba(250,202,21,0.08)' : 'rgba(255,75,75,0.08)';
  band.style.borderLeft = `3px solid ${color}`;
  const label = document.createElement('div');
  label.className = 'tier-band-label';
  label.style.color = color;
  label.textContent = `VALIDATION — ${level} ${Math.round(avg*100)}%`;
  band.appendChild(label);
  const nodesDiv = document.createElement('div');
  nodesDiv.className = 'tier-nodes';
  // Per-table validation nodes
  val.forEach(v => {
    const el = document.createElement('div');
    el.className = 'tier-node';
    const nc = v.overall_score >= 0.9 ? '#21C354' : v.overall_score >= 0.7 ? '#FACA15' : '#FF4B4B';
    el.style.borderTopWidth = '3px';
    el.style.borderTopColor = nc;
    el.innerHTML = `<div class="node-name">${v.table}</div><div class="node-meta">${Math.round(v.overall_score*100)}%</div>`;
    const badge = document.createElement('div');
    badge.className = 'node-badge ' + (v.overall_score >= 0.9 ? 'green' : v.overall_score >= 0.7 ? 'amber' : '');
    badge.textContent = v.overall_score >= 0.9 ? '✓' : v.overall_score >= 0.7 ? '!' : '✗';
    el.appendChild(badge);
    nodesDiv.appendChild(el);
  });
  band.appendChild(nodesDiv);
  container.appendChild(band);
  // Color existing nodes by health
  container.querySelectorAll('.tier-node[data-node-id]').forEach(el => {
    const nodeId = el.dataset.nodeId;
    const vResult = val.find(v => nodeId === v.table || nodeId.startsWith(v.table));
    if (vResult) {
      const sc = vResult.overall_score;
      el.style.borderColor = sc >= 0.9 ? '#21C354' : sc >= 0.7 ? '#FACA15' : '#FF4B4B';
    }
  });
}
</script>
</body>
</html>
